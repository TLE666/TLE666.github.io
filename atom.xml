<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P_Wang&#39;s Blog</title>
  
  <subtitle>自己选择的路，跪着也要走完。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tle666.github.io/"/>
  <updated>2019-02-02T11:51:56.279Z</updated>
  <id>http://tle666.github.io/</id>
  
  <author>
    <name>P_Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[BZOJ5165] 树上倍增</title>
    <link href="http://tle666.github.io/2019/02/02/%5BBZOJ5165%5D%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    <id>http://tle666.github.io/2019/02/02/[BZOJ5165]树上倍增/</id>
    <published>2019-02-02T09:59:01.000Z</published>
    <updated>2019-02-02T11:51:56.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>维护一棵支持插入节点与求$k$个节点的$LCA$的树。</p><p>总节点数 $n\leq 3 \times 10^6$  ，操作次数 $m \leq 10^3$，$k \leq 10^3$</p><a id="more"></a><p>题目链接： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5165" target="_blank" rel="noopener">BZOJ P5165</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>思路题目名称已经给了好嘛。。。</p><p>就是倍增啊。。</p><p>其实这题的难点不是在于思路想法，而是在于<strong>卡空间</strong>！</p><h2 id="操作1"><a href="#操作1" class="headerlink" title="操作1"></a>操作1</h2><blockquote><p>$A \ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1​$。</p></blockquote><p>维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$</p><p>具体的维护方法见下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = <span class="number">1</span></span><br><span class="line">st[i][j] = k 代表 编号为i的节点向上跳<span class="number">2</span> ^ j个点到编号为k的节点</span><br><span class="line">因此st[i][<span class="number">0</span>]即为节点i的父亲</span><br><span class="line"></span><br><span class="line">dep[++n] = dep[x] + <span class="number">1</span>; <span class="comment">// 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 2 ^ 21 &gt; 3e6，因此只需维护到20即可</span></span><br><span class="line">    st[n][i] = st[st[n][i - <span class="number">1</span>]][i - <span class="number">1</span>]; <span class="comment">// 倍增数组标准维护语句</span></span><br></pre></td></tr></table></figure><h2 id="操作2"><a href="#操作2" class="headerlink" title="操作2"></a>操作2</h2><blockquote><p>$Q \ k\  p1\  p2\ p3\ …$ 查询$p1,\ p2,\ p3\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。</p></blockquote><p>这个我想没什么好讲的吧。</p><p>就是依次求$LCA$就行啦。<del>如果不懂详见代码</del></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3000003</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>, m, dep[MAXN], st[MAXN][<span class="number">21</span>], P;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>]; <span class="comment">// 读入操作用，char可能会咕掉</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 新建节点操作，上文讲过</span></span><br><span class="line">    dep[++n] = dep[x] + <span class="number">1</span>, st[n][<span class="number">0</span>] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        st[n][i] = st[st[n][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 基本的LCA操作，不解释</span></span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[v] - dep[u] &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(st[u][i] != st[v][i])</span><br><span class="line">            u = st[u][i],</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">return</span> st[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, lca; dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 将root的深度设为1</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, ch, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'A'</span>) insert(k);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;lca); <span class="comment">//依次求LCA</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P), lca = LCA(lca, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;维护一棵支持插入节点与求$k$个节点的$LCA$的树。&lt;/p&gt;
&lt;p&gt;总节点数 $n\leq 3 \times 10^6$  ，操作次数 $m \leq 10^3$，$k \leq 10^3$&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="LCA" scheme="http://tle666.github.io/tags/LCA/"/>
    
      <category term="倍增" scheme="http://tle666.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>快速读入详解</title>
    <link href="http://tle666.github.io/2019/01/27/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>http://tle666.github.io/2019/01/27/快速读入详解/</id>
    <published>2019-01-27T03:41:50.000Z</published>
    <updated>2019-01-27T03:52:07.671Z</updated>
    
    <content type="html"><![CDATA[<p>快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板</p><a id="more"></a><p>当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！</p><h2 id="卡常！"><a href="#卡常！" class="headerlink" title="卡常！"></a>卡常！</h2><blockquote><p>程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。</p><p>常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。</p></blockquote><pre><code>                    ——来自~~某度~~百科……</code></pre><h2 id="快速读入"><a href="#快速读入" class="headerlink" title="快速读入"></a>快速读入</h2><blockquote><p>简称快读，是信息学竞赛中卡常数最为常见的方法。</p></blockquote><p>一般来讲，大多数题目的出题人都不会到这种<del>丧心病狂的</del>地步。</p><p>不过，以防万一肯定没坏处啊~ <del>反正代码很简单啦</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>先上代码！讲解在后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123; <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125; <span class="comment">// 这是能判负数的C++快读模板</span></span><br></pre></td></tr></table></figure><p>在代码中，只需将<code>cin &gt;&gt; n</code>或<code>scanf(&quot;%d&quot;, &amp;n)</code>改成<code>n  = read()</code>即可！</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>为什么$cin$慢？因为它需要和$stdio$保持同步，也就是<code>sync_with_stdio</code>。</p><p>为什么$scanf$慢？原因有点复杂。</p><ol><li>它可以接受多种形式的输入（数字、字符串等等），因此需要判断。</li><li>它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。</li></ol><p>其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。</p><p>在实际的文件中，会有许多不必要的隐藏字符，比如换行符<code>\n</code>等。</p><p>因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。</p><p>于是，我们要特判！<code>if(ch == ‘-’) w = -1;</code>这就是判负号的语句。</p><p>下一个循环中，就是<a href="https://wenku.baidu.com/view/7fdcf9727dd184254b35eefdc8d376eeafaa1716.html" target="_blank" rel="noopener">位值原理</a>。数$\overline{abcd} = 10 \times (10 \times (10 \times a + b) + c) + d$，读者自证不难。</p><p>最后返回$n = sgn(n) \times |n|$，其中$sgn(x)$为$x$的符号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="卡常" scheme="http://tle666.github.io/tags/%E5%8D%A1%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>浅谈二分</title>
    <link href="http://tle666.github.io/2019/01/27/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/"/>
    <id>http://tle666.github.io/2019/01/27/浅谈二分/</id>
    <published>2019-01-27T03:39:50.000Z</published>
    <updated>2019-01-27T03:59:03.795Z</updated>
    
    <content type="html"><![CDATA[<p> 二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。</p><a id="more"></a><ul><li>大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。</li></ul><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li>首先，令$L = -1$，$R = 1$。</li><li>然后进行如下操作，直到$f(mid) = 0$为止。</li></ul><ol><li>算出$L$和$R$的代数平均数$mid$，且$mid \in \mathbb{Z}$，即整数$mid = \lfloor \dfrac{a + b}{2} \rfloor$。</li><li><ul><li>若$f(mid) = 0$，找到答案<ul><li>若$f(mid) &gt; 0$，让$b = mid$，缩小区间</li><li>若$f(mid) &lt; 0$，让$a = mid$，缩小区间</li></ul></li></ul></li><li>回到步骤$1$。<br> 如果你没有明白的话，那就看图吧。。。</li></ol><p><img src="https://s1.ax1x.com/2018/12/20/FDTt1S.png" alt="函数求零点"></p><ol><li>$L = 0, R = 4, mid = \lfloor \dfrac{0 + 4}{2} \rfloor = 2$</li><li>$f(mid) = f(2) = 3 &gt; 0$</li><li>因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。</li><li>缩小范围至$[0,2]$，$R = 2$。</li><li>此时$mid = \lfloor \dfrac{0 + 2}{2} \rfloor= 1$</li><li>$f(mid) = f(1) = 0$！</li><li>找到答案$0$。</li></ol><h3 id="例题回顾（条件）"><a href="#例题回顾（条件）" class="headerlink" title="例题回顾（条件）"></a>例题回顾（条件）</h3><ul><li>在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢?</li><li>显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。</li></ul><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ul><li>对于区间$[a, b]$上连续不断且$f(a) \times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。</li></ul><p>在信息学中，二分法最常见的体现就是<strong>二分答案</strong>。</p><p>在这篇随笔中，我主要讲解的就是二分答案。</p><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><ul><li>二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>猜数字</strong></p><ul><li><p>事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。</p></li><li><p>朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。</p></li><li>二分答案：<br>  $L = 1, R = 100, mid = \lfloor \dfrac{L + R}{2} \rfloor = 50$，设答案为$ans$。<br>  只要$L \leqslant R$，尝试$mid$，<script type="math/tex; mode=display">\left\{  \begin{aligned}  & 若mid > ans，则R = mid； \\  & 若mid < ans，则L = mid + 1； \\  & 若mid = ans，猜对了。  \end{aligned}  \right.</script>  时间复杂度为$O(log n)$。</li></ul><h3 id="为什么二分"><a href="#为什么二分" class="headerlink" title="为什么二分"></a>为什么二分</h3><ul><li>更充分地利用已知条件，大幅度减少遍历范围</li><li>二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销</li></ul><h3 id="在什么情况下可以二分"><a href="#在什么情况下可以二分" class="headerlink" title="在什么情况下可以二分"></a>在什么情况下可以二分</h3><ul><li>答案存在单调性<br>  <img src="https://s2.ax1x.com/2019/01/27/kucZo8.png" alt=""></li></ul><p>什么意思呢？</p><p>我们不妨假设答案满足条件为$1$，不满足为$0$；</p><p>那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以；</p><p>而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。</p><h3 id="能够解决的问题"><a href="#能够解决的问题" class="headerlink" title="能够解决的问题"></a>能够解决的问题</h3><p>二分答案能够解决哪些问题呢？如下：</p><ul><li>最大的最小值</li><li>最小的最大值</li><li>在满足条件的情况下的最小（大）值</li><li>最接近一个值的值</li><li>…… 在一个单调序列中特殊的点基本上都能二分。</li></ul><h3 id="模板（-C-）"><a href="#模板（-C-）" class="headerlink" title="模板（$C++$）"></a>模板（$C++$）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个求满足条件的最小值的二分模板</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = MAX, mid, ans; <span class="comment">// left为左边界，right为右边界</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">// 只要存在区间</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// 等价于(left + right) / 2，只不过这样写运行速度会稍快一些</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) ans = mid, right = mid - <span class="number">1</span>; <span class="comment">// 如果mid满足条件，那ans（答案）肯定不大于mid</span></span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 如果不能满足条件，ans区间最小值肯定大于mid</span></span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure><p>为什么第五行要加上<code>ans = mid</code>呢？</p><p>原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么）</p><p>这就出现了另一种写法——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个求满足条件的最小值的二分模板</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = MAX, mid; <span class="comment">// left为左边界，right为右边界</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">// #注意这里改变#</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// 等价于(left + right) / 2，只不过这样写运行速度会稍快一些</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) right = mid; <span class="comment">// #注意这里也改变#</span></span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 如果不能满足条件，ans区间最小值肯定大于mid</span></span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, right); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure><p>不过我个人建议还是写第一种好（更好理解，不容易错）。</p><p>那这两段代码中的$check$函数是干什么的呢？</p><p>其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li><a href="https://www.luogu.org/problemnew/show/P1843" target="_blank" rel="noopener">奶牛晒衣服</a></li><li><a href="https://www.luogu.org/problemnew/show/P1396" target="_blank" rel="noopener">营救</a> （如果不会最小生成树请自动跳过~）</li><li><a href="https://www.luogu.org/problemnew/show/P2678" target="_blank" rel="noopener">$NOIP2015$ 跳石头</a></li><li><p><a href="https://www.luogu.org/problemnew/show/P1439" target="_blank" rel="noopener">【模板】最长公共子序列</a></p></li><li><p>……</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="二分" scheme="http://tle666.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1462通往奥格瑞玛的道路</title>
    <link href="http://tle666.github.io/2019/01/27/%E6%B4%9B%E8%B0%B7P1462%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF/"/>
    <id>http://tle666.github.io/2019/01/27/洛谷P1462通往奥格瑞玛的道路/</id>
    <published>2019-01-27T03:36:50.000Z</published>
    <updated>2019-01-27T03:48:18.675Z</updated>
    
    <content type="html"><![CDATA[<p>看完题面感觉语文要挂科。。。o(╥﹏╥)o</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>$n$个点$m$条边的带权无向图</p><p>每个点还有一个点权</p><p>求$1-n$的一条最短路径，使得路径长度比$b$断，并且经过的点权之和最大。</p><p>输出这个最大值</p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题正解 <strong>$SPFA$ $+$ 二分</strong></p><p>_只看思路的同志们到此为止_</p><hr><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p><del>很简单，</del>先来个二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了$QAQ$</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (int)1e9</span></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; <span class="comment">//pre[u]代表u到1的最短路的上一个节点</span></span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> v, w;</span><br><span class="line">edge *next;</span><br><span class="line">&#125;pool[MAXN &lt;&lt; <span class="number">1</span>], *h[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//建边函数</span></span><br><span class="line">edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt];</span><br><span class="line">p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123; <span class="comment">//money代表这次至少收取多少钱，所能够走道的最短路</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) dis[i] = INF;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>, Q.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">u = Q.front(), Q.pop(), flag[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line"><span class="keyword">if</span>(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; <span class="comment">//注意这里要判一下点权（钱）是否满足要求（money）</span></span><br><span class="line">dis[v] = dis[u] + p-&gt;w, pre[v] = u;</span><br><span class="line"><span class="keyword">if</span>(!flag[v])</span><br><span class="line">Q.push(v), flag[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">//最短路回溯函数（递归调用）</span></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">1</span>) <span class="keyword">return</span> f[<span class="number">1</span>]; <span class="comment">//到头</span></span><br><span class="line"><span class="keyword">if</span>(u != <span class="number">1</span> &amp;&amp; !pre[u]) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//走不通了（不连通）</span></span><br><span class="line"><span class="keyword">return</span> max(f[u], path(pre[u])); <span class="comment">//最多一次的钱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//二分函数</span></span><br><span class="line">spfa(x);</span><br><span class="line"><span class="keyword">int</span> tmp = path(n);</span><br><span class="line"><span class="keyword">if</span>(tmp &lt;= x &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; dis[n] &lt;= blood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w, left = INF, right = <span class="number">0</span>, mid, Max = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;blood);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i]);</span><br><span class="line">left = min(left, f[i]), Max = right = max(right, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left &gt; Max) <span class="built_in">puts</span>(<span class="string">"AFK"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, left);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完题面感觉语文要挂科。。。o(╥﹏╥)o&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="题解" scheme="http://tle666.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="http://tle666.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1627中位数</title>
    <link href="http://tle666.github.io/2019/01/27/%E6%B4%9B%E8%B0%B7P1627%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://tle666.github.io/2019/01/27/洛谷P1627中位数/</id>
    <published>2019-01-27T03:33:40.000Z</published>
    <updated>2019-01-27T03:48:44.349Z</updated>
    
    <content type="html"><![CDATA[<h5 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.luogu.org/problem/show?pid=1627" target="_blank" rel="noopener">题目传送门</a></h5><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="标记一遍相对大小，大的标1，小的标-1。只要连续-n-项和为0，就能满足题目条件。"><a href="#标记一遍相对大小，大的标1，小的标-1。只要连续-n-项和为0，就能满足题目条件。" class="headerlink" title="标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。"></a>标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。</h3><h3 id="首先一遍找到中位数位置-pos，放个数组-flag-标记查找中的数与目标中位数的相对大小："><a href="#首先一遍找到中位数位置-pos，放个数组-flag-标记查找中的数与目标中位数的相对大小：" class="headerlink" title="首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小："></a>首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：</h3><p>1 -&gt; 比中位数大</p><p>-1 -&gt; 比中位数小</p><p>0 -&gt; 找到中位数！标记pos</p><p>还是举个实例吧……</p><p>数组：1 1 -1 -1 -1 pos 1 -1 1</p><h3 id="然后从-pos-1-走一遍到1，也就是反过来。再拿一个变量-sum-标记每往左走一个时数组-flag-这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组-f-）那万一-sum-值为负怎么办？数组的下标可没有负的！凉拌-把所有-sum-值统统加上一个足够大的值-“KEY”-。妈妈再也不用担心下标的值为负啦！"><a href="#然后从-pos-1-走一遍到1，也就是反过来。再拿一个变量-sum-标记每往左走一个时数组-flag-这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组-f-）那万一-sum-值为负怎么办？数组的下标可没有负的！凉拌-把所有-sum-值统统加上一个足够大的值-“KEY”-。妈妈再也不用担心下标的值为负啦！" class="headerlink" title="然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。妈妈再也不用担心下标的值为负啦！"></a>然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。妈妈再也不用担心下标的值为负啦！</h3><p>这时的 sum 数组：-1 -2 -3 -2 -1</p><p>这时的 f 数组：f [ -1 + KEY ] = 2 ;  f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ;</p><h3 id="做完这些以后，最后从-pos-1-走一遍到-n-正着走。和上边一样，记录-sum-值。不过这次得多一个步骤——每次要找-pos-左边的对应值。"><a href="#做完这些以后，最后从-pos-1-走一遍到-n-正着走。和上边一样，记录-sum-值。不过这次得多一个步骤——每次要找-pos-左边的对应值。" class="headerlink" title="做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。"></a>做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。</h3><p>从 pos 向右</p><ol><li><p>sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2;</p></li><li><p>sum=0 -&gt; 左边 sum=0 -&gt; 无</p></li><li><p>sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2;</p></li></ol><h3 id="最后输出-ans-即可。"><a href="#最后输出-ans-即可。" class="headerlink" title="最后输出 ans 即可。"></a>最后输出 ans 即可。</h3><p>C++ 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;//头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;//头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//命名空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY 100001<span class="comment">//定义一个足够大的数</span></span></span><br><span class="line"><span class="keyword">int</span> n,b,pos,a[<span class="number">100010</span>],flag[<span class="number">100010</span>],f[<span class="number">200010</span>],s,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;b);<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第一次循环</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b) pos=i;<span class="comment">//就是中位数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;b) flag[i]=<span class="number">1</span>;<span class="comment">//大的标1</span></span><br><span class="line">        <span class="keyword">else</span> flag[i]=<span class="number">-1</span>;<span class="comment">//小的标-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//第二次循环</span></span><br><span class="line">        s+=flag[i];<span class="comment">//计算此次sum值</span></span><br><span class="line">        f[s+KEY]++;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) ans++;<span class="comment">//找到满足题意只在 pos 左侧的连续子序列！</span></span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="number">0</span>;<span class="comment">//为第三次循环的累加做准备</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第三次循环</span></span><br><span class="line">        s+=flag[i];<span class="comment">//计算此次sum值</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) ans++;<span class="comment">//找到满足题意只在 pos 右侧的连续子序列！</span></span><br><span class="line">        ans+=f[-s+KEY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,++ans);<span class="comment">//还少一次只由 pos 自己组成的连续子序列（也满足条件！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;题目传送门&quot;&gt;&lt;a href=&quot;#题目传送门&quot; class=&quot;headerlink&quot; title=&quot;题目传送门&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.org/problem/show?pid=1627&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送门&lt;/a&gt;&lt;/h5&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="题解" scheme="http://tle666.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>并查集入门</title>
    <link href="http://tle666.github.io/2018/10/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://tle666.github.io/2018/10/04/并查集/</id>
    <published>2018-10-04T03:21:10.000Z</published>
    <updated>2019-01-27T03:43:34.209Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并查集</strong>是维护集合相关问题的利器！</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>并查集是个好东西！</strong></p><blockquote><h2 id="它能搞和集合相关的东西……"><a href="#它能搞和集合相关的东西……" class="headerlink" title="它能搞和集合相关的东西……"></a>它能搞和集合相关的东西……</h2><p>常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_</p></blockquote><hr><p>二话不说，先上代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n,m,fa[MAXN];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; fa[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v; init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(Find(u)!=Find(v)) Union(Find(u),Find(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$Find()$函数是路径压缩，<del>不用理解，以后自然会懂</del></p><p>$Union()$是将两个队列合到一起。</p><p>E.G. 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><ul><li><ol><li>将1, 2所在的集合合并</li><li>$Find(1)=2, Find(2)=2, Find(3)=3$</li></ol></li><li><ol><li>将2, 3所在的集合合并</li><li>$Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩</li></ol></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="修复公路"><a href="#修复公路" class="headerlink" title="修复公路"></a><a href="https://www.luogu.org/problemnew/show/P1111" target="_blank" rel="noopener">修复公路</a></h3><p>最小生成树模板题！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="keyword">int</span> n,m,ans,fa[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="comment">//所有的边（图）</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> edge &amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;x.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[MAXN*MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> !fa[i]?i:fa[i]=Find(fa[i]);&#125;<span class="comment">//并查集部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; fa[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(Find(e[i].u)!=Find(e[i].v))&#123;<span class="comment">//最小生成树 Kruskal</span></span><br><span class="line">            ans=e[i].w;</span><br><span class="line">            Union(Find(e[i].u),Find(e[i].v));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(Find(i)!=Find(j))&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;并查集&lt;/strong&gt;是维护集合相关问题的利器！&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://tle666.github.io/tags/C/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="并查集" scheme="http://tle666.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
