<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>P_Wang&#39;s Blog</title>
  
  <subtitle>自己选择的路，跪着也要走完。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tle666.github.io/"/>
  <updated>2019-11-14T07:27:00.231Z</updated>
  <id>http://tle666.github.io/</id>
  
  <author>
    <name>P_Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「USACO07MAR」Gold Balanced Lineup</title>
    <link href="http://tle666.github.io/2019/11/13/%5BUSACO07MAR%5D%20Gold%20Balanced%20Lineup/"/>
    <id>http://tle666.github.io/2019/11/13/[USACO07MAR] Gold Balanced Lineup/</id>
    <published>2019-11-13T13:54:18.000Z</published>
    <updated>2019-11-14T07:27:00.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有 $n$ 天， $m$ 种能力。每天都对应着一个给定的二进制数，第 $i$ 位是 $1$ 代表第 $i$ 种能力提升 $1$ 次。否则不提升。如果在连续的一段时间内，每项能力都提升了相同的次数，就称这段时间为一个均衡时期。求均衡时期的最大长度。</p><p>对于 $100 \%$ 的数据，有 $n \leq 10^5,m \leq 30$ </p><a id="more"></a><p><a href="https://www.luogu.org/problem/P1360" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>我们发现 $m$ 不大，于是考虑一次对每个能力算出前缀和。设第 $i$ 天所有 $m$ 个能力所构成的序列为 $S_i$ ，则一个从第 $l$ 天到第 $r$ 天的均衡时期肯定满足 $S_{l - 1}$ 和 $S_r$ 对应每项的差相同。比如 $\texttt{[1, 3, 2, 4]}$ 和 $\texttt{[3, 5, 4, 6]}$</p><p>由此，我们能够想到哈希。</p><p>我们希望给出一种对应法则使所有 对应每项的差相同 的序列都对应成一个哈希值。因为满足这个条件的序列之间一定是一个均衡时期。例如 $\texttt{[2, 1, 4, 0]}$ ， $\texttt{[4, 3, 6, 2]}$ ， 和 $\texttt{[5, 4, 7, 3]}$ 这三个序列应该对应同一种。</p><p>由于 $m$ 很小，可以直接把整个序列加上或减去一个数 $d$ ，使得序列的第一个数为 $0$ ，也就是把整个序列同时减去第一个数。比如把 $\texttt{[2, 1, 4, 0]}$ 全部减二，变为 $\texttt{[0, -1, 2, -2]}$ 。（负数也无妨，毕竟哈希跟正负无关）</p><p>现在，只需求出依次累积的能力即可。</p><p>对于每一次哈希的值：</p><ul><li>若没有出现过，则把当前时间（天数）记录到一个数组中。</li><li>若出现过，即当前哈希值对应的数组已经有值，则说明 当前 与 数组中记录的时间 这两者间是一个均衡时期。更新答案即可。</li></ul><p><strong>特别提醒：如果经过操作（即全序列减去第一个数）后得到全 0 序列，则第 1 天到它也是一个均衡时期，因为第 0 天的序列也是全 0 序列。</strong></p><p>（感谢 $\text{wzj dalao}$ 的帮助）</p><p>例如第 $5$ 天时序列为 $\texttt{[3, 3, 3, 3]}$ ，则对应着 $\texttt{[0, 0, 0, 0]}$ 序列，说明和第 $0$ 天之后一天（第 $1$ 天）构成了一个均衡时期。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for (int i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bas = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bs2 = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> md2 = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bs3 = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> md3 = <span class="number">9291433</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bs4 = <span class="number">67</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> md4 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span> &lt;ll, <span class="keyword">int</span>&gt; mp; <span class="comment">// 哈希和时间的对应</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Hash</span><span class="params">()</span> </span>&#123; <span class="comment">// 多重哈希，以防被卡</span></span><br><span class="line">  ll num = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">  rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    res += b[i] * num;</span><br><span class="line">    res %= mod;</span><br><span class="line">    num *= bas;</span><br><span class="line">  &#125;</span><br><span class="line">  ll rs2 = <span class="number">0</span>; num = <span class="number">1</span>;</span><br><span class="line">  rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    rs2 += b[i] * num;</span><br><span class="line">    res %= md2;</span><br><span class="line">    num *= bs2;</span><br><span class="line">  &#125;</span><br><span class="line">  ll rs3 = <span class="number">0</span>; num = <span class="number">1</span>;</span><br><span class="line">  rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">    rs3 += b[i] * num;</span><br><span class="line">    res %= md3;</span><br><span class="line">    num *= bs3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (res * bs4 * bs4 + rs2 * bs4 + rs3) % md4; <span class="comment">// “哈希 套 哈希”</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 对应序列。把 b 数组对应成上述序列（即第一个数为 0 ）</span></span><br><span class="line">  per(i, m - <span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">      x -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      a[i + <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  b[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  rep(i, <span class="number">2</span>, m) b[i] = a[i] - a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">  mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">    chg(d);</span><br><span class="line">    ll tmp = Hash();</span><br><span class="line">    <span class="keyword">if</span> (!mp.count(tmp)) mp[tmp] = i; <span class="comment">// 记录第一次时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ans = max(ans, i - mp[tmp]); <span class="comment">// 计算答案，更新答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;有 $n$ 天， $m$ 种能力。每天都对应着一个给定的二进制数，第 $i$ 位是 $1$ 代表第 $i$ 种能力提升 $1$ 次。否则不提升。如果在连续的一段时间内，每项能力都提升了相同的次数，就称这段时间为一个均衡时期。求均衡时期的最大长度。&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，有 $n \leq 10^5,m \leq 30$ &lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="哈希" scheme="http://tle666.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="前缀和" scheme="http://tle666.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>「POJ3971」Scales</title>
    <link href="http://tle666.github.io/2019/08/12/%5BPOJ3971%5D%20Scales/"/>
    <id>http://tle666.github.io/2019/08/12/[POJ3971] Scales/</id>
    <published>2019-08-12T06:25:02.000Z</published>
    <updated>2019-08-12T06:57:26.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有一个物品重量为 $w$ ，现在你有 $1,2,4,\cdots,2^{N - 1}$ 重量的砝码，问有多少种方法可以使天平平衡。</p><p>对于 $100 \%$ 的数据，有 $N \leq 10^6$</p><a id="more"></a><p><a href="http://poj.org/problem?id=3971" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>要使天平平衡，我们设左边的砝码总重为 $x$ ，右边砝码总重为 $y$ 。则我们有</p><script type="math/tex; mode=display">w + x = y</script><p>其中 $x\ \text{AND}\ y = 0$ （ $x\ \text{AND}\ y$ 即 $x$ 与 $y$ ）。有这个限制的原因是因为一个重量的砝码只有一个，若 $x\ \text{AND}\ y \neq 0$ 则说明天平左右两边至少有一组相同砝码，与题意不符。</p><p>令 <code>dp[i][0 / 1]</code> 表示第 $i$ 位是否进位到第 $i - 1$ 位时的方案数。</p><p>显然当前位是否需要进位需要考虑到低位的进位情况，所以要从低位向高位 DP 。</p><p>现在讨论一下转移方程，假设当前算到了第 $i$ 位。</p><p>不明白的地方可以列竖式模拟一下，注意 $x\ \text{AND}\ y = 0$ 这个条件。</p><ul><li><p>若 $w_i = 0,\ x_i = 0$  则</p><p>  <code>dp[i][0] += dp[i + 1][0] + dp[i + 1][1]</code></p><p>  <code>dp[i][1] += 0</code></p></li><li><p>若 $w_i = 0,\ x_i = 1$ 则</p><p>  <code>dp[i][0] += 0</code> （如果不仅位 $x$ 和 $y$ 的这一位都是 1 了，与起来不为 0 ）</p><p>  <code>dp[i][1] += dp[i + 1][1]</code></p></li><li><p>若 $w_i = 1,\ x_i = 0$ 则</p><p>  <code>dp[i][0] += dp[i + 1][0]</code></p><p>  <code>dp[i][1] += dp[i + 1][1]</code></p></li><li><p>若 $w_i = 1,\ x_i = 1$ 则</p><p>  <code>dp[i][0] = 0</code></p><p>  <code>dp[i][1] = dp[i + 1][0]</code> （注意与的条件，同上）</p></li></ul><p>最后把 $w_i$ 相等的情况合并一下就行啦（见代码）。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for (int i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> trv(p, u) for (edg *p = h[u]; p; p = p-&gt;nxt)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) w = <span class="number">-1</span>; c = getchar(); &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">  <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, l, d, dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> w[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T = rd();</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    n = rd(), l = rd(), d = rd();</span><br><span class="line">    rep(i, <span class="number">0</span>, n) dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 清空</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    rep(i, <span class="number">0</span>, n - l - <span class="number">1</span>) w[i] = <span class="number">0</span>; <span class="comment">// 补全 重量 和 最大砝码 二进制表示下的长度差</span></span><br><span class="line">    <span class="comment">// 比如样例的 case 1: 将 1000 补成 001000 与 n 相等</span></span><br><span class="line">    rep(i, n - l, n - <span class="number">1</span>) w[i] = s[i - (n - l)] - <span class="string">'0'</span>;</span><br><span class="line">    dp[n][<span class="number">0</span>] = <span class="number">1</span>, dp[n][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    per(i, n - <span class="number">1</span>, <span class="number">0</span>) &#123; <span class="comment">// n - 1 是最低位 “个位”</span></span><br><span class="line">      <span class="keyword">if</span> (w[i] == <span class="number">0</span>) &#123; <span class="comment">// 合并情况</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = (dp[i + <span class="number">1</span>][<span class="number">0</span>] + dp[i + <span class="number">1</span>][<span class="number">1</span>]) % d; <span class="comment">// 注意取模</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i + <span class="number">1</span>][<span class="number">1</span>] % d;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (w[i] == <span class="number">1</span>) &#123; <span class="comment">// 合并情况</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i + <span class="number">1</span>][<span class="number">0</span>] % d;</span><br><span class="line">        dp[i][<span class="number">1</span>] = (dp[i + <span class="number">1</span>][<span class="number">0</span>] + dp[i + <span class="number">1</span>][<span class="number">1</span>]) % d;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">0</span>][<span class="number">0</span>]); <span class="comment">// 注意答案不能进位</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;有一个物品重量为 $w$ ，现在你有 $1,2,4,\cdots,2^{N - 1}$ 重量的砝码，问有多少种方法可以使天平平衡。&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，有 $N \leq 10^6$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="http://tle666.github.io/tags/DP/"/>
    
      <category term="数位DP" scheme="http://tle666.github.io/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="http://tle666.github.io/2019/08/09/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://tle666.github.io/2019/08/09/莫比乌斯反演/</id>
    <published>2019-08-09T12:30:32.000Z</published>
    <updated>2019-08-09T13:38:57.922Z</updated>
    
    <content type="html"><![CDATA[<p>已知一个函数 $F(n) = \sum_{d | n} f(d)$ ，我们怎么用 $F$ 去表示 $f$ 呢？</p><a id="more"></a><h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a><strong>积性函数</strong></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>$\forall a,b \in \mathbb{Z}$ 且 $\gcd(a,b) = 1$ ，若数论函数 $f(x)$ 满足 $f(ab) = f(a) \cdot f(b)$ ，则 $f(x)$ 为积性函数。</p><p>特别地， $\forall a,b \in \mathbb{Z}$ ，若数论函数 $f(x)$ 满足 $f(ab) = f(a) \cdot f(b)$ ，则 $f(x)$ 为完全积性函数。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h2><p>$\varphi(x) = x \prod _{i = 1}^{n} (1- \frac{1}{p_i})$</p><p>$d(x) = \sum_{a|x} 1$</p><p>$\sigma(x) = \sum_{a | x} a$</p><p>$id(x) = x$</p><p>$e(x) = [x = 1]$ （即 $e(x) = 1 \Leftrightarrow x = 1$ 否则 $e(x) = 0$）</p><p>$1(x) = 1$</p><p>$\mu(x)$ （莫比乌斯函数）</p><h1 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a><strong>狄利克雷卷积</strong></h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>两个数论函数的卷积 $h$ ：$h = f * g$</p><p>则 $h(x) = \sum_{d | x}f(d) \cdot g(\frac{x}{d})$</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a><strong>性质</strong></h2><script type="math/tex; mode=display">f * g = g * f</script><script type="math/tex; mode=display">a * b * c  = a * (b * c)</script><p>若 $f,g$ 为积性函数，则 $h = f * g$ 也是积性函数。</p><p>$f * e = f$ （ $e$ 前面提到的数论函数）</p><h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a><strong>莫比乌斯函数</strong></h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>$\mu(n) = (-1)^k \Leftrightarrow n = \prod _{i = 1}^{k} p_i$ （即没有平方因子）</p><p>特别地，$\mu(1) = (-1)^0 = 1$</p><p>$\mu(n) = 0$ 若 $n$ 有平方因子</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a><strong>性质</strong></h2><p>$\mu * 1 = e$ </p><p>证明：</p><script type="math/tex; mode=display">\mu * 1 = \sum_{d | n} \mu(d) * 1(\frac{n}{d}) = \sum_{d | n} \mu(d)</script><p>当 $n = 1$ 时显然 $(\mu * 1)(1) = e(1) = 1$</p><p>当 $n \neq 1$ 时，</p><p>设 $n = p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdots p_m^{\alpha_m}$ ， $d = p_1^{x_1} \cdot p_2 ^ {x _ 2} \cdots p_m^{x_m}$</p><p>根据 $\mu$ 的定义，我们只需要考虑 $x_i \leq 1$ 的情况。</p><p>我们设 $d$ 中存在 $k$ 个 $x_i$ 为 1，那么有</p><script type="math/tex; mode=display">\sum_{d\mid n}\mu(d) = \sum_{r = 0}^m\binom m r(-1)^r(n \neq 1)</script><p>根据二项式定理，$(x+y)^{n}=\sum _{k=0}^{n}\binom n kx^{n-k}y^{k}$</p><p>令 $x = 1,\ y = -1$ 则</p><script type="math/tex; mode=display">\sum_{r = 0}^m\binom m r(-1)^r = (1 - 1)^m = 0(n \neq 1)</script><p>所以 $\mu * 1 = \sum_{d | n} \mu(d) = e$</p><p>证毕。</p><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a><strong>莫比乌斯反演</strong></h1><p>若 $F(n) = \sum_{d | n} f(d)$ ，则 $f(n) = \sum_{d | n} \mu(d) * F(\frac{n}{d})$</p><p>证明：</p><script type="math/tex; mode=display">F = f * 1</script><script type="math/tex; mode=display">\Leftrightarrow F * \mu = (f * 1) * \mu = f * (1 * \mu)</script><script type="math/tex; mode=display">\Leftrightarrow F * \mu = f * e</script><script type="math/tex; mode=display">\Leftrightarrow F * \mu = f</script><p>证毕。</p><h1 id="小例题"><a href="#小例题" class="headerlink" title="小例题"></a><strong>小例题</strong></h1><p><a href="https://www.luogu.org/problem/P1829" target="_blank" rel="noopener">「国家集训队」Crash 的数字表格 / JZPTAB</a></p><p><a href="https://www.luogu.org/problem/P2522" target="_blank" rel="noopener">「HAOI2011」Problem b</a></p><p><a href="https://www.luogu.org/problem/P3312" target="_blank" rel="noopener">「SDOI2014」数表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已知一个函数 $F(n) = \sum_{d | n} f(d)$ ，我们怎么用 $F$ 去表示 $f$ 呢？&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/categories/OI/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="http://tle666.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://tle666.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>「国家集训队」种树</title>
    <link href="http://tle666.github.io/2019/07/23/%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%20%E7%A7%8D%E6%A0%91/"/>
    <id>http://tle666.github.io/2019/07/23/[国家集训队] 种树/</id>
    <published>2019-07-23T14:45:02.000Z</published>
    <updated>2019-07-23T15:03:40.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一个圆环上有 $n$ 个点，每个点都有美观度，要取 $m$ 个点使它们不相邻且总美观度最大。</p><p>对于 $100 \%$ 的数据，有 $n \leq 200000,m \leq n$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1792" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>十分神奇的贪心。。</p><p>首先先种上美观度最大的一棵，然后将其左右两棵合并到中间，且其美观度为 $val_l + val_r - val_i$ 。</p><p>其中 $val_x$ 是 $x$ 的美观度，$i$ 是美观度最大的那棵， $l,r$ 分别是其左边和右边的两棵。</p><p>这中操作其实就是一种反悔机制：如果后来发现一开始选 $i$ 左边和右边的收益更大，那其实加上 $val_l + val_r - val_i$ 后就能把一开始的 $val_i$ 抵消掉，也就是 $val_i + (val_l + val_r - val_i) = val_l + val_r$ 。这时就相当于把一开始不好的 $i$ 替换成更好的 $l,r$ 。</p><p>但如果 $i$ 更好，那么后来也就选不上 $l$ 和 $r$ 了，因为每步都会有个排序。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans; <span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span> &#123;</span> <span class="keyword">int</span> val, l, r; &#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val, id;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;node&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  p[x].l = p[p[x].l].l, p[x].r = p[p[x].r].r;</span><br><span class="line">  p[p[x].l].r = x, p[p[x].r].l = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">if</span> ((m &lt;&lt; <span class="number">1</span>) &gt; n) &#123; <span class="built_in">puts</span>(<span class="string">"Error!"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i].val);</span><br><span class="line">    p[i].l = i - <span class="number">1</span>, p[i].r = i + <span class="number">1</span>;</span><br><span class="line">    Q.push((node) &#123;p[i].val, i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  p[<span class="number">1</span>].l = n, p[n].r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (vis[Q.top().id]) Q.pop();</span><br><span class="line">    node cur = Q.top(); Q.pop();</span><br><span class="line">    ans += cur.val, vis[p[cur.id].l] = vis[p[cur.id].r] = <span class="literal">true</span>;</span><br><span class="line">    p[cur.id].val = p[p[cur.id].l].val + p[p[cur.id].r].val - p[cur.id].val;</span><br><span class="line">    Q.push((node) &#123;p[cur.id].val, cur.id&#125;); del(cur.id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;一个圆环上有 $n$ 个点，每个点都有美观度，要取 $m$ 个点使它们不相邻且总美观度最大。&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，有 $n \leq 200000,m \leq n$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://tle666.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ3850」ZCC Loves Codefires</title>
    <link href="http://tle666.github.io/2019/07/23/%5BBZOJ3850%5D%20ZCC%20Loves%20Codefires/"/>
    <id>http://tle666.github.io/2019/07/23/[BZOJ3850] ZCC Loves Codefires/</id>
    <published>2019-07-23T13:36:07.000Z</published>
    <updated>2019-07-23T14:13:10.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有 $n$ 道题，每道题有两个参数 $E,\ K$ ；需要 $E$ 时间来做完这道题，而在 $T$ 时间完成这道题时，会损失 $K \times T$ 分。要给这 $n$ 道题排个做题顺序，使得最后总损失的分数最少。</p><p>对于 $100 \%$ 的数据，有 $n \leq 10^5;\ E,K \leq 10^4$ 。</p><a id="more"></a><p><a href="http://ruanx.pw/bzojch/p/3850.html" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>其实这纯是一道推式子的题……</p><p>我们考虑如果交换 $i,j$ 两题的顺序会发生什么。</p><p>令 $S_i$ 表示在 $i$ 前面做（不包括 $i$ ）的所有题所需的总时间。</p><p>若 $i$ 在 $j$ 前面做时两题总损失分数：</p><script type="math/tex; mode=display">(S_i + E_i) \times K_i + (S_i + E_i + E_{j}) \times K_j</script><script type="math/tex; mode=display">\Leftrightarrow S_i \times (K_i + K_j) + E_i \times K_i + E_j \times K_j + E_i \times K_j</script><p>若 $j$ 在 $i$ 前面做时两题总损失分数：</p><script type="math/tex; mode=display">(S_j + E_j) \times K_j + (S_j + E_j + E_i) \times K_i</script><p>而由于 $i$ 和 $j$ 只是交换了位置，所以 $S_j = S_i$ ；</p><script type="math/tex; mode=display">\Leftrightarrow S_i \times (K_i + K_j) + E_i \times K_i + E_j \times K_j + E_j \times K_i</script><p>对比两式可发现，我们只需判断 $E_i \times K_j$ 与 $E_j \times K_i$ 的大小关系即可。</p><p>所以只需将题目按照上述排序。</p><p>最后答案就用定义 $O(n)$ 算一遍就行了。</p><p><strong>注意开 <code>long long</code></strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> e, k;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e * rhs.k &lt; rhs.e * k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].k);</span><br><span class="line">  sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>); <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += (s += a[i].e) * a[i].k;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a><strong>Submission</strong></h1><p>由于这是一道权限题，在这里提供一下数据（好像只有一组但超大）</p><p><a href="https://www.lanzous.com/i54n1dg" target="_blank" rel="noopener">一组数据</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;有 $n$ 道题，每道题有两个参数 $E,\ K$ ；需要 $E$ 时间来做完这道题，而在 $T$ 时间完成这道题时，会损失 $K \times T$ 分。要给这 $n$ 道题排个做题顺序，使得最后总损失的分数最少。&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，有 $n \leq 10^5;\ E,K \leq 10^4$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://tle666.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>「HEOI2014」南园满地堆轻絮</title>
    <link href="http://tle666.github.io/2019/07/23/%5BHEOI2014%5D%20%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E5%A0%86%E8%BD%BB%E7%B5%AE/"/>
    <id>http://tle666.github.io/2019/07/23/[HEOI2014] 南园满地堆轻絮/</id>
    <published>2019-07-23T11:29:30.000Z</published>
    <updated>2019-07-23T11:44:34.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>对于一个正整数数列 $A_1 \cdots A_n$ ，求另一个正整数数列 $B_1 \cdots B_n$ ，使得对于任意的 $1 \leq i &lt; n$ 有 $B_i \leq B_{i + 1}$ ，而且使得 $ans = \max\{|A_j - B_j|,\ 1 \leq j \leq n\}$ 尽量小。</p><p>定义生成函数 $F(x) = S_a \times x^3 + S_b \times x^2 + S_c \times x + S_d$ ，则数列 $A$ 的递推公式为 $A_i = (F(A_{i - 1}) + F(A_{i - 2})) \% mod$</p><p>对于 $100\%$ 的数据，有 $n \leq 5000000,\ S_a,S_b,S_c,S_d,A_1 \leq 10000,\ mod \leq 1000000007$</p><a id="more"></a><p><a href="https://www.luogu.org/fe/problem/P4105" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>由于时让 $ans$ 中的最大值最小，所以很容易能想到二分答案。假设现在的答案为 $k$ ，则对于所有的 $i$ 满足 $1 \leq i \leq n$ ，都有 $|A_i - B_i| \leq k$ 。也就是说，</p><script type="math/tex; mode=display">A_i - k \leq B_i \leq A_i + k</script><p>因此我们只需每次都贪心使 $B_i$ 尽可能小即可。而如果 $B_i$ 再怎么大也大不到 $B_{i - 1}$ 时，那就说明 $k$ 不行啦！</p><p><strong>注意对 F 函数频繁取模！！！</strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000500</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s[<span class="number">5</span>], a[N], mod, ans, b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  (res += s[<span class="number">1</span>] * x % mod * x % mod * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">2</span>] * x % mod * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">3</span>] * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">4</span>] % mod) %= mod;</span><br><span class="line">  <span class="keyword">return</span> (res + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">1</span>] = a[<span class="number">1</span>] - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt;= b[i - <span class="number">1</span>]) b[i] = max(a[i] - k, b[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (b[i - <span class="number">1</span>] - a[i] &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      b[i] = b[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld%lld"</span>, &amp;n, &amp;s[<span class="number">1</span>], &amp;s[<span class="number">2</span>], &amp;s[<span class="number">3</span>], &amp;s[<span class="number">4</span>], &amp;a[<span class="number">1</span>], &amp;mod);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) a[i] = (F(a[i - <span class="number">1</span>]) + F(a[i - <span class="number">2</span>])) % mod;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = mod; <span class="comment">// 要取模，所以 r 最大也超不过 mod</span></span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (chk(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l % mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对于一个正整数数列 $A_1 \cdots A_n$ ，求另一个正整数数列 $B_1 \cdots B_n$ ，使得对于任意的 $1 \leq i &amp;lt; n$ 有 $B_i \leq B_{i + 1}$ ，而且使得 $ans = \max\{|A_j - B_j|,\ 1 \leq j \leq n\}$ 尽量小。&lt;/p&gt;
&lt;p&gt;定义生成函数 $F(x) = S_a \times x^3 + S_b \times x^2 + S_c \times x + S_d$ ，则数列 $A$ 的递推公式为 $A_i = (F(A_{i - 1}) + F(A_{i - 2})) \% mod$&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，有 $n \leq 5000000,\ S_a,S_b,S_c,S_d,A_1 \leq 10000,\ mod \leq 1000000007$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://tle666.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="二分" scheme="http://tle666.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「USACO10MAR」Great Cow Gathering</title>
    <link href="http://tle666.github.io/2019/07/22/%5BUSACO10MAR%5D%20Great%20Cow%20Gathering/"/>
    <id>http://tle666.github.io/2019/07/22/[USACO10MAR] Great Cow Gathering/</id>
    <published>2019-07-22T14:03:33.000Z</published>
    <updated>2019-11-13T13:55:34.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给一个带边权与点权的树 $T$ （ $N$ 个结点 ），找一个点 $x$ 使 $\sum_{u \in T\ \&amp;\ u \neq x} dis_{u,x} \times c_u$ 取最大值。</p><p>对于 $100\%$ 的数据，有 $1 \leq N \leq 100000,\ 1 \leq C_i \leq 1000$ 。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P2986" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>树形 DP 。其实也不能完全算是 DP 。</p><p>我们使用调整法。对于点 $1$ ，我们可以 $O(n)$ 地算出 $f_1 = \sum_{u \in T\ \&amp;\ u \neq 1} dis_{u,1} \times C_u$</p><p>然后递归考虑 $1$ 的儿子结点 $u$ 。我们比较一下 $f_1$ 和 $f_u$ 。可以将这棵树分为两部分。其中一部分（ $up$ ）与点 $1$ 在点 $u$ 的同一边，而另一部分（ $dn$ ）则与点 $u$ 在点 $1$ 同一边。当我们的注意力从 $1$ 转到 $u$ 上时，我们发现 $f$ 的值发生了一些变化。对于 $up$ 那部分的所有点，它们都被加上了一段路程 $dis_{1,u}$ ；而对于 $dn$ 那部分的所有点，它们都减去了 $dis_{1, u}$ 。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/22/5d35c8f32385195587.png" alt="题目中的样例" title>                </div>                <div class="image-caption">题目中的样例</div>            </figure><p>举个例子。对于图上的 $3$ ，我们发现 $f_3 = 1\times 1 + 1 \times 2 + 2 \times 6 = 15$ 。把它分成 $up$ 和 $dn$ ， $up = 3,\ dn = 12$ 。同理对于 $4$ ， $up = up_3 + 3 \times (1 + 1) = 9,\ dn = dn_3 - 3 \times 2 = 6$ 。</p><p>结果，我们发现 $up$ 和 $dn$ 都与前面有关系，所以只用记变化值就行啦。</p><p><strong>注意开 <code>long long</code> 。。</strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], f[N], up[N], dn[N], size[N], ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="comment">// f up dn 如上文；size[u] 以 u 为根的子树大小（此处指子树中 c[i] 之和）</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, w; edge *next; &#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cur = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge *p = ++cur, *q = ++cur;</span><br><span class="line">  p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">  q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dis, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 f[1]</span></span><br><span class="line">  <span class="keyword">int</span> v, res = c[u] * dis;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      res += calc(v, dis + p-&gt;w, u);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 size</span></span><br><span class="line">  <span class="keyword">int</span> v; size[u] = c[u];</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      pre(v, u); size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 f</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      up[v] = (size[<span class="number">1</span>] - size[v]) * p-&gt;w;</span><br><span class="line">      dn[v] = -size[v] * p-&gt;w;</span><br><span class="line">      f[v] = f[u] + up[v] + dn[v]; <span class="comment">// 记得 up 和 dn 只是相对 u 的变化值</span></span><br><span class="line">      dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;c[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    addedge(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  pre(<span class="number">1</span>, <span class="number">0</span>); f[<span class="number">1</span>] = calc(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, f[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;给一个带边权与点权的树 $T$ （ $N$ 个结点 ），找一个点 $x$ 使 $\sum_{u \in T\ \&amp;amp;\ u \neq x} dis_{u,x} \times c_u$ 取最大值。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，有 $1 \leq N \leq 100000,\ 1 \leq C_i \leq 1000$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="http://tle666.github.io/tags/DP/"/>
    
      <category term="树形DP" scheme="http://tle666.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>「AtCoder Grand Contest 025 B」RGB Coloring</title>
    <link href="http://tle666.github.io/2019/07/20/%5BAtCoder%20Grand%20Contest%20025%20B%5D%20RGB%20Coloring/"/>
    <id>http://tle666.github.io/2019/07/20/[AtCoder Grand Contest 025 B] RGB Coloring/</id>
    <published>2019-07-20T11:12:41.000Z</published>
    <updated>2019-07-20T11:31:33.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一个 n 层塔，每层可以不涂颜色或涂红绿蓝三种颜色之一。不涂颜色美观度 $0$ ，涂红色美观度 $A$ ，涂绿色美观度 $A + B$ ，涂蓝色美观度 $B$ 。求使所有层的美观度之和 $=K$ 的涂色方案数 $\pmod {998244353}$</p><p>对于 $100 \%$ 的数据，</p><p>$1 \leq N \leq 3 \times 10^5$</p><p>$1 \leq A,B \leq 3 \times 10^5$</p><p>$0 \leq K \leq 18 \times 10^{10}$</p><a id="more"></a><p><a href="https://atcoder.jp/contests/agc025/tasks/agc025_b" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>好像不是特别难吧（雾</p><p>换一个角度想，我们从 $A$ 和 $B$ 处入手。对于 $A$ 和 $B$ ， 我们发现这两个数可以随便地放到任意一层中，即只需满足 $0 \leq num_A,num_B \leq N$ 即可，其中 $num_x$ 表示 $x$ 在塔中出现的次数。因此可以写成</p><script type="math/tex; mode=display">Ax + By = K (0 \leq x,y \leq N)</script><p>的形式。我们只需要 $O(N)$ 枚举 $x$ 的取值，再判断与之对应的 $y$ 是否是整数。一对 $x,y$ 对答案的贡献是 $C(n, x) \times C(n, y)$ ，即 $\binom{n}{x} \times \binom{n}{y}$ 。至于为什么呢，就是因为 $A$ 和 $B$ 两个数并不冲突 —— 可以同时放在一层中，可以独自一层，也可以一层两个都没有；所以 $x$ 个 $A$ 和 $y$ 个 $B$ 可以随便在 $n$ 层中分布。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(x) (((x) + mod) % mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, k, c[N], inv[N], s[N], t[N], fac[N], ans, inv2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= mod;</span><br><span class="line">    (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 注意赋初值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mod; <span class="comment">// 阶乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = <span class="number">1l</span>l * s[i - <span class="number">1</span>] * fac[i] % mod;</span><br><span class="line">  t[n] = qpow(s[n], mod - <span class="number">2</span>); <span class="comment">// 前缀积 O(n + logP) 逆元求法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) t[i - <span class="number">1</span>] = <span class="number">1l</span>l * t[i] * fac[i] % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) inv[i] = <span class="number">1l</span>l * t[i] * s[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span> </span>&#123; <span class="comment">// C(M, N)</span></span><br><span class="line">  <span class="keyword">if</span> (N &lt; <span class="number">0</span> || N &gt; M) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> M(<span class="number">1l</span>l * fac[M] * M(inv[N] * inv[M - N]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;a, &amp;b, &amp;k);</span><br><span class="line">  prework();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y; x &lt;= n; x++) <span class="comment">// 枚举 x</span></span><br><span class="line">    <span class="keyword">if</span> ((k - a * x) % b == <span class="number">0</span>) &#123; <span class="comment">// 判断 y 是不是整数</span></span><br><span class="line">      y = (k - a * x) / b;</span><br><span class="line">      ans += M(<span class="number">1l</span>l * C(n, x) * C(n, y)); <span class="comment">// 贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, M(ans));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;一个 n 层塔，每层可以不涂颜色或涂红绿蓝三种颜色之一。不涂颜色美观度 $0$ ，涂红色美观度 $A$ ，涂绿色美观度 $A + B$ ，涂蓝色美观度 $B$ 。求使所有层的美观度之和 $=K$ 的涂色方案数 $\pmod {998244353}$&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，&lt;/p&gt;
&lt;p&gt;$1 \leq N \leq 3 \times 10^5$&lt;/p&gt;
&lt;p&gt;$1 \leq A,B \leq 3 \times 10^5$&lt;/p&gt;
&lt;p&gt;$0 \leq K \leq 18 \times 10^{10}$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="http://tle666.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数学" scheme="http://tle666.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="排列组合" scheme="http://tle666.github.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ3884」上帝与集合的正确用法</title>
    <link href="http://tle666.github.io/2019/07/18/%5BBZOJ3884%5D%20%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/"/>
    <id>http://tle666.github.io/2019/07/18/[BZOJ3884] 上帝与集合的正确用法/</id>
    <published>2019-07-18T14:03:50.000Z</published>
    <updated>2019-07-18T14:19:38.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>求 <script type="math/tex">2^{2^{2 \cdots}} \bmod p</script></p><p>对于 $100\%$ 的数据，有数据组数 $T \leq 1000$ ， $p \leq 10^7$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P4139" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>根据 <strong>扩展欧拉定理</strong> ，即当 $b \geq \varphi (p)$ 时，</p><script type="math/tex; mode=display">a ^ b \equiv a ^ {b \bmod \varphi(p) + \varphi(p)} \pmod{p}</script><p>而当 $b &lt; \varphi(p)$ 时，</p><script type="math/tex; mode=display">a^b \equiv a ^ {b \bmod \varphi(p)} \equiv a^b \pmod{p}</script><p><del>貌似没啥用？</del></p><p>由于题目中的 $b$ 是 $2^{2 \cdots}$ ，所以一定有 $b \geq \varphi(p)$，因此递归一下式子就做完了。</p><p>具体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 带入算一下就能得出 0</span></span><br><span class="line">  <span class="keyword">return</span> qpow(<span class="number">2</span>, work(phi[m]) + phi[m], m); <span class="comment">// 递归， qpow 是快速幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000100</span>;</span><br><span class="line"></span><br><span class="line">ll T, P, p[<span class="number">700700</span>], phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= <span class="number">1e7</span>; j++) &#123;</span><br><span class="line">      vis[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123; phi[i * p[j]] = phi[i] * p[j]; <span class="keyword">break</span> ; &#125;</span><br><span class="line">      <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= mod;</span><br><span class="line">    (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> qpow(<span class="number">2</span>, work(phi[m]) + phi[m], m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prework();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (work(P) + P) % P);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我没有研究 <code>long long</code> 是否必要，只是保险罢了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;求 &lt;script type=&quot;math/tex&quot;&gt;2^{2^{2 \cdots}} \bmod p&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，有数据组数 $T \leq 1000$ ， $p \leq 10^7$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="欧拉函数" scheme="http://tle666.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="欧拉定理" scheme="http://tle666.github.io/tags/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最小表示法</title>
    <link href="http://tle666.github.io/2019/07/14/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://tle666.github.io/2019/07/14/最小表示法/</id>
    <published>2019-07-14T12:13:27.000Z</published>
    <updated>2019-07-14T12:37:04.498Z</updated>
    
    <content type="html"><![CDATA[<p>有一个字符串，当我们要寻找一个位置，使其从这个位置向后形成一个新字符串，这个新字符串的字典序最小时，就能用到这个算法。</p><p>比如对于 $ABCD$ ，就有 $ABCD$ ， $BCDA$ ， $CDAB$ ， $DABC$ 这四种新字符串。</p><p>而最小的那个是 $ABCD$ 。</p><a id="more"></a><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a><strong>Operations</strong></h1><p>令 <code>i = 0, j = 1, k = 0</code> ，表示 <strong>从 i 开始 k 长度 和 从 j 开始 k 长度 的字符串相同</strong> 。</p><p>当 <code>str[i] == str[j]</code> 时，不难发现需要进行将 <code>k++</code> 的操作；</p><p>当 <code>str[i] &gt; str[j]</code> 时，我们发现 i 位置比 j 位置字典序要大，因此不能以 i 作为开头了。所以要将 i 向后移动。而 i 开头和 j 开头都有 k 个相同字符，因此要将 <code>i += (k + 1)</code> ；</p><p>同理，当 <code>str[i] &lt; str[j]</code> 时， <code>j += (k + 1)</code> 。</p><p>最后 i 和 j 中较小的那个就是答案啦。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">0</span>, t;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123;</span><br><span class="line">    t = str[(i + k) % n] - str[(j + k) % n]; <span class="comment">// 通过 t 与 0 的大小关系来判断</span></span><br><span class="line">    <span class="keyword">if</span> (!t) k++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t &gt; <span class="number">0</span>) i += (k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> j += (k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (i == j) j++;</span><br><span class="line">      k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmin() + <span class="number">1</span>); <span class="comment">// +1 是因为字符串从第零个开始，这样更容易分辨</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个字符串，当我们要寻找一个位置，使其从这个位置向后形成一个新字符串，这个新字符串的字典序最小时，就能用到这个算法。&lt;/p&gt;
&lt;p&gt;比如对于 $ABCD$ ，就有 $ABCD$ ， $BCDA$ ， $CDAB$ ， $DABC$ 这四种新字符串。&lt;/p&gt;
&lt;p&gt;而最小的那个是 $ABCD$ 。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/categories/OI/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://tle666.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="最小表示法" scheme="http://tle666.github.io/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「HNOI2003」消防局的设立</title>
    <link href="http://tle666.github.io/2019/06/18/%5BHNOI2003%5D%20%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/"/>
    <id>http://tle666.github.io/2019/06/18/[HNOI2003] 消防局的设立/</id>
    <published>2019-06-18T13:29:01.000Z</published>
    <updated>2019-08-12T00:55:42.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一棵 $n$ 个结点的树，问最少几个特殊点能覆盖满整个图。</p><p>其中，一个特殊点能覆盖与它距离不超过 2 的所有点。</p><p>对于 $100\%$ 的数据，满足 $n \leq 1000$ </p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>就是个大贪心。。</p><p>每次找到深度最大的未覆盖的结点，并贪心地在它祖父结点处放个消防站（即特殊点）。由于前提，所以这个点的所有子结点全部都被覆盖了。因此放在祖父结点处最优。</p><p>那么如何判断这个点是否被覆盖了呢？问题在于兄弟结点。其实，可以用 <code>dis</code> 数组维护距离一个特殊点的最短距离；此时当 <code>dis[fa] == 1</code> 时，就能确定它被覆盖了。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, que[N], dep[N], fa[N], dis[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &gt; dep[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = fa[u], g = fa[f];</span><br><span class="line">  dis[u] = min(dis[u], min(dis[f] + <span class="number">1</span>, dis[g] + <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">if</span> (dis[u] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    dis[g] = <span class="number">0</span>, ans++;</span><br><span class="line">    dis[fa[g]] = min(dis[fa[g]], <span class="number">1</span>),</span><br><span class="line">    dis[fa[fa[g]]] = min(dis[fa[fa[g]]], <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); dis[<span class="number">0</span>] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = INF, que[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa[i]);</span><br><span class="line">    dep[i] = dep[fa[i]] + <span class="number">1</span>;</span><br><span class="line">    que[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(que + <span class="number">1</span>, que + n + <span class="number">1</span>, cmp); <span class="comment">// 按深度排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) upd(que[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;一棵 $n$ 个结点的树，问最少几个特殊点能覆盖满整个图。&lt;/p&gt;
&lt;p&gt;其中，一个特殊点能覆盖与它距离不超过 2 的所有点。&lt;/p&gt;
&lt;p&gt;对于 $100\%$ 的数据，满足 $n \leq 1000$ &lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://tle666.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Coding Style</title>
    <link href="http://tle666.github.io/2019/06/13/Coding%20Style/"/>
    <id>http://tle666.github.io/2019/06/13/Coding Style/</id>
    <published>2019-06-13T13:11:46.000Z</published>
    <updated>2019-08-10T03:20:19.929Z</updated>
    
    <content type="html"><![CDATA[<p>这是本人的代码风格。</p><a id="more"></a><p>在下列规则中，部分来自于文末的谷歌代码规范。</p><h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><ul><li>两空格缩进</li><li>使用 $Source\ Code\ Pro$ 字体，大小为 14 号</li><li>$Sublime$ 编辑器最佳</li><li>一行的长度通常不要超过 60 列，一定不能超过 90</li><li>大括号不换行，但要在大括号前加空格</li><li>运算符间通常有空格， <code>++</code> 除外</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a><strong>模板</strong></h1><ul><li>update 2019/8/10</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = (a); i &lt;= (b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for (int i = (a); i &gt;= (b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> trv(u) for (edg *p = h[u]; p; p = p-&gt;nxt)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) w = <span class="number">-1</span>; c = getchar(); &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">  <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>通常在程序第一行 （ <code>#pragma</code> 时除外 ）</li><li><code>include</code> 和 <code>&lt;头文件&gt;</code> 之间有一个空格</li><li>通常只用一个万能头</li><li><code>#include &lt;bits/stdc++.h&gt;</code></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li><p>在头文件之后，与头文件之间空一行</p></li><li><p>在它后面也空一行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>在命名空间之后</p></li><li><p>通常只需一个定义数组大小的函数 <code>const int N = 100100;</code></p></li><li><p>如果有 <code>typedef ... ...</code> ，则将其置于 <code>const int</code> 之前</p></li><li><p>如果有 <code>#define int long long</code> 这种，则放到 <code>const int</code> 之后</p></li><li><p>如果有多个恒量（ <code>const int</code> ），则将他们分开</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>在定义之后，与定义间有空行</p></li><li><p>单行长度尽量不超过 60</p></li><li><p>两行之间不空行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll x1, x2, x3, x4, AVeryLongVariableName, a, b, c, d, e, f, g;</span><br><span class="line">ll LengthOver60NeedToChangeLine;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>在变量之后，与变量间有空行</p></li><li><p>在结构体名称与后方大括号间有空格</p></li><li><p>末尾右括号右侧加空格</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>在结构体之后，不同函数间有空行，函数内部没有空行</p></li><li><p>不管是什么函数都要加上 <code>inline</code> （尽管可能没啥用。。</p></li><li><p>关于程序中语句的一些要点也就揉到这里面了</p></li><li><p><code>for</code> 、 <code>if</code> 和 <code>while</code> 后括号左侧要加空格</p></li><li><p>循环变量一般不加 <code>register</code></p></li><li><p>如果循环内语句不小于两句，就加大括号，通常两句间用分号连接</p></li><li><p>循环和判断能不加大括号就不加</p></li><li><p>不加大括号时如果把循环（判断）内的语句放到循环（判断）的同一行内的长度不超过 60 就放到同一行</p></li><li><p>永远不要把任何语句放到大括号右边</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u; <span class="keyword">bool</span> x;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[<span class="number">2</span>] = a[<span class="number">3</span>] = a[<span class="number">4</span>] = a[<span class="number">5</span>] = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (i) </span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// do while 要加大括号，就算只有一句</span></span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="built_in">puts</span>(<span class="string">"This is wrong!"</span>); <span class="comment">// 不能这样</span></span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><ul><li><p>通常把初始化写在一个函数内，在主函数内调用</p></li><li><p>通常使用 <code>int main()</code> ，除非 <code>#define int long long</code> 时才用 <code>signed main()</code></p></li><li><p>最后要 <code>return 0</code></p></li><li><p>散碎的变量统一放在主函数的开头，如果太多分两行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> left, right, s, tag;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; tag += x, s += (right - left + <span class="number">1</span>) * x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; s = ls-&gt;s + rs-&gt;s;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ls) ls-&gt;seta(tag);</span><br><span class="line">      <span class="keyword">if</span> (rs) rs-&gt;seta(tag);</span><br><span class="line">      tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">3</span>], *root, *cnt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">  <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">    r-&gt;s = a[left];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">  r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">  build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">    r-&gt;seta(d);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;push();</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d);</span><br><span class="line">  <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right, d),</span><br><span class="line">       change(r-&gt;rs, r-&gt;rs-&gt;left, right, d);</span><br><span class="line">  r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, d;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  build(root = ++cnt, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    sacnf(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">    change(root, l, r, d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谷歌代码风格"><a href="#谷歌代码风格" class="headerlink" title="谷歌代码风格"></a>谷歌代码风格</h2><p> ( 建议在新标签页中查看大图 )</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/11/5cd6cdf9517df.jpg" alt="google" title>                </div>                <div class="image-caption">google</div>            </figure><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/" target="_blank" rel="noopener">更详细的中文文字版在这里</a></p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>如果您有什么修改意见，也请在评论区留言，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本人的代码风格。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="其它" scheme="http://tle666.github.io/categories/OI/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="优化" scheme="http://tle666.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 518D」Ilya and Escalator</title>
    <link href="http://tle666.github.io/2019/06/05/%5BCodeforces%20518D%5D%20Ilya%20and%20Escalator/"/>
    <id>http://tle666.github.io/2019/06/05/[Codeforces 518D] Ilya and Escalator/</id>
    <published>2019-06-05T14:19:23.000Z</published>
    <updated>2019-08-11T10:47:43.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有 $n$ 个人排成一列，每秒中队伍最前面的人 $p$ 的概率走上电梯（一旦走上就不会下电梯）或者有 $(1-p)$ 的概率不动。问 $t$ 秒过后，在电梯上的人的数量的期望。</p><p>对于 $100 \%$ 的数据，满足 $n,t\leq2000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/CF518D" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>期望 $DP$ 。</p><p>设 $dp_{i,j}$ 表示第 $i$ 秒已经走上 $j$ 个人的概率。</p><p>则有</p><script type="math/tex; mode=display">ans = \sum_{i = 1}^n dp_{t, i}</script><p>转移方程如下（一定注意边界！）：</p><script type="math/tex; mode=display">dp_{i, j}=\left\{ \begin{array}{ll}dp_{i -1,0}\times(1-p)  & j=0\\dp_{i - 1, j - 1}\times p+dp_{i-1,j}\times (1-p) & 1\le j<n \\dp_{i - 1, n}+dp_{i - 1, n - 1}\times p & j=n\end{array} \right.\ \ \\\</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p, dp[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = (<span class="number">1.0</span> - p) * dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * p + (<span class="number">1.0</span> - p) * dp[i - <span class="number">1</span>][j];</span><br><span class="line">    dp[i][n] = dp[i - <span class="number">1</span>][n] + p * dp[i - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%lf%d"</span>, &amp;n, &amp;p, &amp;t);</span><br><span class="line">  DP();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    ans += (<span class="keyword">double</span>) (i * dp[t][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;有 $n$ 个人排成一列，每秒中队伍最前面的人 $p$ 的概率走上电梯（一旦走上就不会下电梯）或者有 $(1-p)$ 的概率不动。问 $t$ 秒过后，在电梯上的人的数量的期望。&lt;/p&gt;
&lt;p&gt;对于 $100 \%$ 的数据，满足 $n,t\leq2000$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DP" scheme="http://tle666.github.io/tags/DP/"/>
    
      <category term="期望" scheme="http://tle666.github.io/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>「HAOI2007」反素数</title>
    <link href="http://tle666.github.io/2019/05/17/%5BHAOI2007%5D%20%E5%8F%8D%E7%B4%A0%E6%95%B0/"/>
    <id>http://tle666.github.io/2019/05/17/[HAOI2007] 反素数/</id>
    <published>2019-05-17T11:14:38.000Z</published>
    <updated>2019-07-22T14:05:14.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>对于一个数 $x$ ，只要它满足对于任意一个 $&lt; x$ 的数 $i$ ，均有 $g(i) &lt; g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1463" target="_blank" rel="noopener">题目连接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>设答案为 ans 。则有</p><script type="math/tex; mode=display">ans = 2^{\alpha_1} \cdot 3^{\alpha_2} \cdot 5^{\alpha_3} \cdot ... \cdot 31^{\alpha_{11}}</script><p>我们能够得出结论：若果 ans 为反素数，则 $\alpha_1 \geq \alpha_2 \geq \alpha_3 \geq … \geq \alpha_{11}$</p><p><del>口糊</del> 证明：</p><p>对于 ${p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$ ，假设 $p_1 &lt; p_2$ 且 $\alpha_1 &lt; \alpha_2$ ，则数 ${p_1}^{\alpha_2} \cdot {p_2}^{\alpha_1}$ 必定 $&lt;{p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$</p><p>但两数的约数个数相等，矛盾！</p><p>比如说 $2^3\cdot3^5$ ，则 $2^5\cdot3^3&lt;2^3\cdot3^5$ 但这两个数的约数和却相等。矛盾！</p><p>只需暴力递归即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans, mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 不必须的快速幂</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">    a *= a, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">// 更新答案</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>, tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++)</span><br><span class="line">  res *= (a[i] + <span class="number">1</span>);</span><br><span class="line">  tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++)</span><br><span class="line">    tmp *= qpow(p[i], a[i]);</span><br><span class="line">  <span class="keyword">if</span> (mx &lt; res) &#123;</span><br><span class="line">    mx = res;</span><br><span class="line">    ans = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mx == res &amp;&amp; ans &gt; tmp) <span class="comment">// 注意这种情况！</span></span><br><span class="line">    ans = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> last)</span> </span>&#123; <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i) last *= p[cur];</span><br><span class="line">    <span class="keyword">if</span> (last &gt; n) &#123;</span><br><span class="line">      upd(cur);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    a[cur] = i;</span><br><span class="line">    <span class="keyword">if</span> (!i) upd(cur);</span><br><span class="line">    <span class="keyword">else</span> dfs(cur + <span class="number">1</span>, i, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">31</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;对于一个数 $x$ ，只要它满足对于任意一个 $&amp;lt; x$ 的数 $i$ ，均有 $g(i) &amp;lt; g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="http://tle666.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「JZOJ4964」Rhyme</title>
    <link href="http://tle666.github.io/2019/05/08/%5BJZOJ4964%5D%20Rhyme/"/>
    <id>http://tle666.github.io/2019/05/08/[JZOJ4964] Rhyme/</id>
    <published>2019-05-08T14:53:33.000Z</published>
    <updated>2019-05-19T03:45:10.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>由于多次交换邮票没有满足所有人的需求，小$Z$被赶出了集邮部。无处可去的小$Z$决定加入音乐部，为了让音乐部的人注意到自己的才华，小$Z$想写一首曲子。为了让自己的曲子更好听，小$Z$找到了一些好听曲子作为模板。曲谱可以表示成只包含小写字母的字符串，小$Z$希望自己最终的曲谱中任意一个长度为$K$的子串都是一个模板的子串。现在小$Z$想知道自己的曲谱最长可以是多长，如果可以无限长的话请输出<code>INF</code>。</p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><p>本题的每个测试点有多组数据，对于每组数据：</p><p>第一行两个整数$N$，$K$分别表示模板的个数与$K$值。</p><p>接下来$N$行，每行一个字符串表示一个模板。（只包含$’a’$~$’z’$）</p><p>每组数据字符串总长不超过$100000$，$1\leq K\leq100000$。每个测试点数据不超过$10$组。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组数据输出一行表示曲子最长可以是多长，如果可以无限长的话输出$INF$。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br><span class="line">abcabc</span><br><span class="line">1 5</span><br><span class="line">abcabc</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INF</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p> 第一个样例的曲子可以是$”abc”$不断循环。 第二个样例的曲子最长是$”abcabc”$。</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于一个$K$值来说，任意一个长度小于$K$的字符串均可行。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>字符串哈希 + 拓扑排序。</p><p>题目中给了固定的$K$，因此很容易想到字符串哈希。</p><p>于是我们可以哈希一下所有长度为$(K-1)$的子串，前一个与后一个以哈希值连边。最后拓扑一下就行了。</p><p>特别地，如果图上有环，那就说明是$INF$。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e6</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> T, n, k, ans;</span><br><span class="line"><span class="keyword">int</span> ind[M], S[N], f[M];</span><br><span class="line">ull hs[M], K;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[M], *cnt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt; ind[v]++;</span><br><span class="line">    vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">qpow</span><span class="params">(ull a, ull b)</span> </span>&#123;</span><br><span class="line">    ull res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>, (a *= a) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">Hash</span><span class="params">(ull d)</span> </span>&#123;</span><br><span class="line">    ull p = d % M;</span><br><span class="line">    <span class="keyword">while</span>(hs[p] &amp;&amp; hs[p] != d) &#123;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= M) p -= M;</span><br><span class="line">    &#125;</span><br><span class="line">    hs[p] = d;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tpsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        u = Q.front(); Q.pop();</span><br><span class="line">        ans = max(ans, f[u]);</span><br><span class="line">        <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(--ind[v = p-&gt;v]))</span><br><span class="line">                Q.push(v);</span><br><span class="line">            f[v] = max(f[v], f[u] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    K = qpow(<span class="number">26</span>, k - <span class="number">1</span>);</span><br><span class="line">    cnt = pool;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span>(ind));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;k) != EOF) &#123;</span><br><span class="line">        prework();</span><br><span class="line">        <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">            n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; k) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                S[i] = num(str[i]);</span><br><span class="line">            ull tmp = <span class="number">0</span>, u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">                (tmp *= <span class="number">26</span>) += S[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">                u = Hash(tmp);</span><br><span class="line">                (tmp *= <span class="number">26</span>) += (ull) (S[i] - S[i - k + <span class="number">1</span>] * K);</span><br><span class="line">                v = Hash(tmp);</span><br><span class="line">                addedge(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i] &amp;&amp; !ind[i])</span><br><span class="line">                Q.push(i), f[i] = k - <span class="number">1</span>;</span><br><span class="line">        tpsort();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">if</span>(ind[i] &amp;&amp; vis[i]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"INF"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;由于多次交换邮票没有满足所有人的需求，小$Z$被赶出了集邮部。无处可去的小$Z$决定加入音乐部，为了让音乐部的人注意到自己的才华，小$Z$想写一首曲子。为了让自己的曲子更好听，小$Z$找到了一些好听曲子作为模板。曲谱可以表示成只包含小写字母的字符串，小$Z$希望自己最终的曲谱中任意一个长度为$K$的子串都是一个模板的子串。现在小$Z$想知道自己的曲谱最长可以是多长，如果可以无限长的话请输出&lt;code&gt;INF&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://tle666.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="字符串哈希" scheme="http://tle666.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    
      <category term="拓扑排序" scheme="http://tle666.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>决策单调性</title>
    <link href="http://tle666.github.io/2019/05/04/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    <id>http://tle666.github.io/2019/05/04/决策单调性/</id>
    <published>2019-05-04T08:42:42.000Z</published>
    <updated>2019-05-19T03:47:18.019Z</updated>
    
    <content type="html"><![CDATA[<p>在做动归题时，我们常会遇到复杂度过高的情况。</p><p>决策单调性可以帮你减轻复杂度带来的负担。</p><a id="more"></a><h1 id="Monge-Condition"><a href="#Monge-Condition" class="headerlink" title="Monge Condition"></a><strong>Monge Condition</strong></h1><p>即 <strong>四边形不等式</strong>；</p><p>对于 $w(i,j)$ 和依次递增的四个数 $a, b, c, d$</p><p>只要</p><script type="math/tex; mode=display">w(a, c) + w(b, d) \leq w(a, d) + w(b, c)</script><p>那么我们就说函数 $w(i, j)$ 满足四边形不等式。</p><p>就好比一个矩形，其左上角为 $(a, c)$，右下角为 $(b, d)$，左上角的值加右下角的值</p><p>其名称也是因此而来的。</p><h1 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a><strong>决策单调性</strong></h1><p>对于一个转移方程</p><script type="math/tex; mode=display">f_i = \min(f_j + w_{j, i})</script><p>其中 $1 \leq j &lt; i$；</p><p>设 $opt(i)$ 代表 $(f_j + w_{j, i})$ 最小时的 $j$，即</p><script type="math/tex; mode=display">f_i = f_{opt(i)} + w_{opt(i), i}</script><p>这里显然有 $opt(i) &lt; i$</p><p><strong>决策单调性</strong>就是指 $opt(i) \leq opt(i + 1)$</p><p>结论：若 $w_{i, j}$ 满足四边形不等式，则转移方程满足决策单调性，即</p><p><strong>四边形不等式推出决策单调性</strong>。</p><p>证明:</p><p>由定义，</p><script type="math/tex; mode=display">f_i = f_{opt(i)} + w_{opt(i), i}</script><script type="math/tex; mode=display">f_{i + 1} = f_{opt(i + 1)} + w_{opt(i + 1), i + 1}</script><p>$w$ 满足 $Monge\ Condition$；</p><p>若 $opt(i) &gt; opt(i + 1)$，即决策单调性不成立；</p><script type="math/tex; mode=display">opt(i + 1) < opt(i) \leq i < i + 1</script><p>令 $a = opt(i + 1),\ b = opt(i),\ c = i,\ d = i + 1$；</p><p>由 $Monge\ Condition$，</p><script type="math/tex; mode=display">w(a, c) + w(b, d) \leq w(a, d) + w(b, c)</script><p>因为 $f_i$ 和 $f_{i + 1}$ 都取到了最小值，所以 $(f_i + f_{i + 1})_{\min}$</p><p>而</p><p>$(f_i + f_{i + 1}) = f_a + f_b + w(a, d) + w(b, c)$</p><p>​                 $\geq f_a + f_b + w(a, c) + w(b, d)$</p><p>矛盾！</p><p>取法：</p><p>令 $f_i = f_{opt(i + 1)} + w_{opt(i + 1), i}$，$f_(i + 1) = f_{opt(i)} + w_{opt(i), i + 1}$，</p><p>即互换 $opt(i),\ opt(i + 1)$ 即可。</p><p>∴$opt(i) \leq opt(i + 1)$</p><p>证毕。</p><p>简单例题：</p><p><a href="https://www.luogu.org/problemnew/show/CF321E" target="_blank" rel="noopener">「CF321E」Ciel and Gondolas</a></p><p><a href="https://www.luogu.org/problemnew/show/P1912" target="_blank" rel="noopener">「NOI2009」诗人小G</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做动归题时，我们常会遇到复杂度过高的情况。&lt;/p&gt;
&lt;p&gt;决策单调性可以帮你减轻复杂度带来的负担。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="算法讲解" scheme="http://tle666.github.io/categories/OI/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="优化" scheme="http://tle666.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="DP" scheme="http://tle666.github.io/tags/DP/"/>
    
      <category term="四边形不等式" scheme="http://tle666.github.io/tags/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
      <category term="公式" scheme="http://tle666.github.io/tags/%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>「SPOJ1811」LCS - Longest Common Substring</title>
    <link href="http://tle666.github.io/2019/04/27/%5BSPOJ1811%5D%20LCS%20-%20Longest%20Common%20Substring/"/>
    <id>http://tle666.github.io/2019/04/27/[SPOJ1811] LCS - Longest Common Substring/</id>
    <published>2019-04-27T12:34:13.000Z</published>
    <updated>2019-05-19T03:46:07.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出<code>0</code> 。</p><p>对于$100 \%$的数据，$|S| \leq 250000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/SP1811" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>这道题可以作为后缀数组的练手题。<del>调了5个小时。。。</del></p><p>后缀数组是对一个字符串的操作啊，那这道题不是2个嘛？</p><p>把它整到一个里面就行啦！</p><p>忽然想到$Manacher$算法，中间每两个字符不是用<code>$</code>隔开了吗？</p><p>对啊！</p><p>就在两个单词中间加个<code>$</code>就行啦~</p><p>举个栗子：</p><script type="math/tex; mode=display">S_1 = "firststring"</script><script type="math/tex; mode=display">S_2 = "secondstring"</script><p>（双引号不包括在字符串中）</p><p>则整合后的字符串</p><script type="math/tex; mode=display">S = "firststring$secondstring"</script><p>很简单吧、</p><p>于是这个问题就转化为了在一个字符串里找最长重复子串啦</p><p>——这不就是$height$数组嘛</p><p>但是注意有一个小条件</p><p><strong>两个最长子串必须在不同的单词之间哦！</strong></p><p>这个<del>随便</del>判断一下就行啦。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, len, x[N], y[N];</span><br><span class="line"><span class="keyword">int</span> rk[N], sa[N], h[N], c[N], a[N];</span><br><span class="line"><span class="comment">// 其中 h 数组就是 height 数组</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        c[x[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        x[i] = a[i], y[i] = i;</span><br><span class="line">    rsort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(sa[i] &gt; k)</span><br><span class="line">                y[++p] = sa[i] - k;</span><br><span class="line"></span><br><span class="line">        rsort();</span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, p = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">            &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k])</span><br><span class="line">                x[sa[i]] = p - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x[sa[i]] = p++;</span><br><span class="line"></span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        rk[sa[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(L) L--;</span><br><span class="line">        <span class="keyword">while</span>(a[i + L] == a[j + L])</span><br><span class="line">            L++;</span><br><span class="line">        h[rk[i]] = L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">    len = n = <span class="built_in">strlen</span>(s[<span class="number">0</span>]),</span><br><span class="line">    m = <span class="built_in">strlen</span>(s[<span class="number">1</span>]);</span><br><span class="line">    n += m + <span class="number">1</span>, m = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        a[i] = s[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    a[len + <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len + <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = s[<span class="number">1</span>][i - len - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    getSA();</span><br><span class="line">    getH();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &gt; len &amp;&amp; sa[i - <span class="number">1</span>] &lt; len)</span><br><span class="line">        || (sa[i] &lt; len &amp;&amp; sa[i - <span class="number">1</span>] &gt; len))</span><br><span class="line">            ans = max(ans, h[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出&lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对于$100 \%$的数据，$|S| \leq 250000$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="后缀数组" scheme="http://tle666.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「BZOJ2561」最小生成树</title>
    <link href="http://tle666.github.io/2019/03/27/%5BBZOJ2561%5D%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://tle666.github.io/2019/03/27/[BZOJ2561] 最小生成树/</id>
    <published>2019-03-27T12:53:07.000Z</published>
    <updated>2019-05-19T03:44:27.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。</p><p>对于$100\%$的数据，$N,\ L \leq 20000$，$M \leq 200000$</p><a id="more"></a><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2561" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>思路妙啊！</p><p>如果$L$那条边可能出现在最小生成树上，那么就有边权$&lt;L$的边不能连通其两端点$(u, v)$，否则将$u$和$v$连起来再删除$L$那条边显然更小。这不就是最小割嘛！</p><p>最大生成树也同理，于是答案就是两次最小割之和。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T, L, lev[N], ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    edge *next, *rev;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool)),</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(h)),</span><br><span class="line">    cnt = pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt, *q = ++cnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;c = c, p-&gt;next = h[u], h[u] = p, p-&gt;rev = q;</span><br><span class="line">    q-&gt;v = u, q-&gt;c = c, q-&gt;next = h[v], h[v] = q, q-&gt;rev = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">makelev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">memset</span>(lev, <span class="number">-1</span>, <span class="keyword">sizeof</span>(lev));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(S), lev[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        u = Q.front(), Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(!(lev[v = p-&gt;v] + <span class="number">1</span>) &amp;&amp; p-&gt;c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lev[v] = lev[u] + <span class="number">1</span>;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> (lev[T] != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">if</span>(u == T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(lev[v = p-&gt;v] == lev[u] + <span class="number">1</span> &amp;&amp; p-&gt;c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f = dfs(v, min(p-&gt;c, flow));</span><br><span class="line">            flow -= f, p-&gt;c -= f;</span><br><span class="line">            res += f, p-&gt;rev-&gt;c += f;</span><br><span class="line">            <span class="keyword">if</span>(!flow) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res) lev[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(makelev()) res += dfs(S, INF);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a[i].u, &amp;a[i].v, &amp;a[i].c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;S, &amp;T, &amp;L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].c &gt; L)</span><br><span class="line">            addedge(a[i].u, a[i].v, <span class="number">1</span>); <span class="comment">// 注意这里的边权</span></span><br><span class="line">    ans += dinic();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].c &lt; L)</span><br><span class="line">            addedge(a[i].u, a[i].v, <span class="number">1</span>); <span class="comment">// 这里也是</span></span><br><span class="line">    ans += dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">3 2 1</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。&lt;/p&gt;
&lt;p&gt;对于$100\%$的数据，$N,\ L \leq 20000$，$M \leq 200000$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://tle666.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://tle666.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="http://tle666.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="最小割" scheme="http://tle666.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>「HDU6203」ping ping ping</title>
    <link href="http://tle666.github.io/2019/03/21/%5BHDU6203%5D%20ping%20ping%20ping/"/>
    <id>http://tle666.github.io/2019/03/21/[HDU6203] ping ping ping/</id>
    <published>2019-03-21T14:25:47.000Z</published>
    <updated>2019-05-19T03:44:58.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 <code>U V</code> 无法连通。问无法通行的点最少有多少个。</p><p>对于$100 \%$的数据，$3 \leq n \leq 10^4$，$p \leq 5 \times 10^4$</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6203" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>考虑到我们要求的是$u$到$v$上不能通行，<del>很显然</del> 能想到可以通过树上前序与后序$DFS$序来维护。具体方法如下：</p><p>根据所给的树预处理出每个点的前序 $DFS$ 序和后序$DFS$ 序（需一起标号），和每个点的深度。</p><p>根据 $p$ 组 <code>U V</code> 处理<strong>每组两点之间的 $LCA$</strong> 。压入优先队列（$LCA$ 深度大的点优先，即往前走）。</p><p>对于出队的<code>U V</code>及其<strong>对应的 $LCA$</strong> ，判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。</p><p>判断点 $U$ 或点 $V$ 是否在<strong>之前已禁止的某点的子树中</strong>。</p><p><strong>处理方式</strong>：由于之前已经处理出每个点的前后序 $DFS$ 序 $in$ 和 $out$ 。</p><p>对于某点 $U$ 若在已禁止通行点 $P$ 的子树中，则 $In[P]≤In[U]≤Out[U]≤Out[P]In[P]≤In[U]≤Out[U]≤Out[P]$ 一定成立。</p><p>故利用树状数组区间更新单点查询。对每个禁止通行点 $P$ ，标记区间 $[In[P],Out[P]][In[P],Out[P]]$ 中所有点。查询时，若点 $In[U]$ 被标记，则说明 <code>U V</code> 已经被隔断。</p><p>同时，由于优先处理 $LCA$ 深度大的点，不会出现点 <code>U V</code> 同时在同一个被禁止通行点 $P$ 的子树内。</p><p>若 $U$ ，$V$ 均不在被禁止的点在子树内，则禁止 <code>U V</code> 的 $LCA$ 点，同时对答案贡献 $+1$ 。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, p, in[N], out[N], tot, dep[N];</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">25</span>], fa[N], C[N &lt;&lt; <span class="number">1</span>], ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, lca;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dep[lca] &lt; dep[x.lca];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; rec;</span><br><span class="line">priority_queue&lt;P&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123; <span class="comment">// 注意多组数据的清空</span></span><br><span class="line">    ans = tot = <span class="number">0</span>, cnt = pool, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(h)),</span><br><span class="line">    <span class="built_in">memset</span>(pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool)),</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in)),</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out)),</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep)),</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st)),</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)),</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis)),</span><br><span class="line">    <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt, *q = ++cnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">    q-&gt;v = u, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; in[u] = ++tot;</span><br><span class="line">    dep[u] = depth, vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(!vis[v = p-&gt;v]) &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dfs(v, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    out[u] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[v] - dep[u] &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(st[u][i] != st[v][i])</span><br><span class="line">            u = st[u][i],</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">return</span> fa[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= lowbit(x))</span><br><span class="line">        res += C[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt; (N &lt;&lt; <span class="number">1</span>); x += lowbit(x))</span><br><span class="line">        C[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// 主要函数</span></span><br><span class="line">    <span class="keyword">int</span> u, v; prework();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addedge(++u, ++v);</span><br><span class="line">    &#125; ++n, dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        st[i][<span class="number">0</span>] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            st[j][i] = st[st[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        rec.u = ++u, rec.v = ++v,</span><br><span class="line">        rec.lca = LCA(u, v);</span><br><span class="line">        pq.push(rec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        rec = pq.top(), pq.pop();</span><br><span class="line">        <span class="keyword">if</span>(!(sum(in[rec.u]) + sum(in[rec.v])))</span><br><span class="line">            change(in[rec.lca], <span class="number">1</span>),</span><br><span class="line">            change(out[rec.lca] + <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">            ans++;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">        work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 &lt;code&gt;U V&lt;/code&gt; 无法连通。问无法通行的点最少有多少个。&lt;/p&gt;
&lt;p&gt;对于$100 \%$的数据，$3 \leq n \leq 10^4$，$p \leq 5 \times 10^4$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LCA" scheme="http://tle666.github.io/tags/LCA/"/>
    
      <category term="倍增" scheme="http://tle666.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="树状数组" scheme="http://tle666.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DFS序" scheme="http://tle666.github.io/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「SPOJ1043」GSS1</title>
    <link href="http://tle666.github.io/2019/03/17/%5BSPOJ1043%5D%20GSS1/"/>
    <id>http://tle666.github.io/2019/03/17/[SPOJ1043] GSS1/</id>
    <published>2019-03-17T01:51:27.000Z</published>
    <updated>2019-05-19T03:45:58.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给一段可能有负数的序列，查询最大子段和。</p><p>对于$100 \%$的数据，序列长度$N \leq 50000$，$a[i] \leq 15007$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>线段树查询最大子段和。</p><p>这里需要维护四个信息：</p><ul><li>$s$ 区间和</li><li>$mx$ 区间最大子段和</li><li>$lmx$ 区间前缀和最大值</li><li>$rmx$ 区间后缀和最大值</li></ul><p>则维护的时候就像这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = ls-&gt;s + rs-&gt;s,</span><br><span class="line">mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), <span class="comment">// 注意有三种情况</span></span><br><span class="line">lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),</span><br><span class="line">rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx);</span><br></pre></td></tr></table></figure><p>其中$ls$，$rs$分别是左子，右子。</p><p>还有一个注意事项：$query$（查询）的时候返回值要是$node*$！只有这样才能够维护四个信息。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><p><del>码风在这种题里很重要</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1001000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, mx, lmx, rmx, s;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = ls-&gt;s + rs-&gt;s,</span><br><span class="line">        mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)),</span><br><span class="line">        lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),</span><br><span class="line">        rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">5</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;s = r-&gt;mx = r-&gt;lmx = r-&gt;rmx = a[left];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node *<span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node *L, *R, *res;</span><br><span class="line">        L = query(r-&gt;ls, left, r-&gt;ls-&gt;right),</span><br><span class="line">        R = query(r-&gt;rs, r-&gt;rs-&gt;left, right),</span><br><span class="line">        res = ++cnt,</span><br><span class="line">        res-&gt;s = L-&gt;s + R-&gt;s,</span><br><span class="line">        res-&gt;left = L-&gt;left, res-&gt;right = R-&gt;right,</span><br><span class="line">        res-&gt;mx = max(L-&gt;rmx + R-&gt;lmx, max(L-&gt;mx, R-&gt;mx)),</span><br><span class="line">        res-&gt;lmx = max(L-&gt;s + R-&gt;lmx, L-&gt;lmx),</span><br><span class="line">        res-&gt;rmx = max(R-&gt;s + L-&gt;rmx, R-&gt;rmx);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    build(root = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;left, &amp;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(root, left, right)-&gt;mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;给一段可能有负数的序列，查询最大子段和。&lt;/p&gt;
&lt;p&gt;对于$100 \%$的数据，序列长度$N \leq 50000$，$a[i] \leq 15007$&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://tle666.github.io/categories/OI/"/>
    
      <category term="题解" scheme="http://tle666.github.io/categories/OI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://tle666.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
</feed>
