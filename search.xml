<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并查集入门]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：最小生成树（$Kruskal$）；判联通块、连通图…… 二话不说，先上代码！ 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts("-1"); return 0; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI中卡常的那些事儿]]></title>
    <url>%2F2018%2F10%2F01%2FOI%E4%B8%AD%E5%8D%A1%E5%B8%B8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[在$OI$竞赛中，我们有时经常会被卡常…… 怎么办呢？？？ 下面是几种 较为常用（$C++$中的） 的卡常方法： 1.快读十分常用，建议背下模板！ 原理：$getchar()$比$scanf()$快。 12345678910111213#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;inline int read()&#123; int s=0,w=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') w=-1;ch=getchar();&#125;//如果输入的是换行符、负号……需要判一下！ while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar();//输入数字部分 return s*w;//返回值：符号(+,-) × 数的绝对值&#125;int main()&#123; printf("%d\n",read());//酷(zuo)炫(si)写法 return 0;&#125; 2.函数声明的$inline$注意：只能在简单函数中使用（才有效）！ 如果这个函数中有$for$或者递归；那就不算简单函数！ 123456789101112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int a,b;inline int add(int a,int b)&#123; return a+b;&#125;int main()&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",add(a,b)); return 0;&#125; 3.$for$循环的$register$将频繁出现的变量临时寄存在$CPU$中，不可访问位置(&amp;n) 1234567891011#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,a[MAXN];int main()&#123; scanf("%d",&amp;n); for(register int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); return 0;&#125; 4.逗号替代分号$RT.$ 12c=a+b;c++;//慢c=a+b,c++;//快 大概日常能够用到的就这些了吧。。。 $END.$]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, Hexo Blog!]]></title>
    <url>%2F2018%2F08%2F29%2FHello-Hexo-Blog%2F</url>
    <content type="text"><![CDATA[经过这么长时间终于弄成了！！！其实还是蛮难弄的嘛……比我一开始想象的要难得多现在弄成了好开森！！！]]></content>
      <tags>
        <tag>其它文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[王泽华：本人乃无实力瑟瑟发抖萌新C++是个好东西。。。$QQ$邮箱：patrick_rdfz@qq.com大力推荐洛谷！！！ https://www.luogu.org/ 欢迎加好友]]></content>
  </entry>
  <entry>
    <title><![CDATA[搜索]]></title>
    <url>%2Fsearch%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
