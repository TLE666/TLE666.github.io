<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「BZOJ3850」ZCC Loves Codefires</title>
      <link href="/2019/07/23/%5BBZOJ3850%5D%20ZCC%20Loves%20Codefires/"/>
      <url>/2019/07/23/%5BBZOJ3850%5D%20ZCC%20Loves%20Codefires/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有 $n$ 道题，每道题有两个参数 $E,\ K$ ；需要 $E$ 时间来做完这道题，而在 $T$ 时间完成这道题时，会损失 $K \times T$ 分。要给这 $n$ 道题排个做题顺序，使得最后总损失的分数最少。</p><p>对于 $100 \%$ 的数据，有 $n \leq 10^5;\ E,K \leq 10^4$ 。</p><a id="more"></a><p><a href="http://ruanx.pw/bzojch/p/3850.html" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>其实这纯是一道推式子的题……</p><p>我们考虑如果交换 $i,j$ 两题的顺序会发生什么。</p><p>令 $S_i$ 表示在 $i$ 前面做（不包括 $i$ ）的所有题所需的总时间。</p><p>若 $i$ 在 $j$ 前面做时两题总损失分数：</p><script type="math/tex; mode=display">(S_i + E_i) \times K_i + (S_i + E_i + E_{j}) \times K_j</script><script type="math/tex; mode=display">\Leftrightarrow S_i \times (K_i + K_j) + E_i \times K_i + E_j \times K_j + E_i \times K_j</script><p>若 $j$ 在 $i$ 前面做时两题总损失分数：</p><script type="math/tex; mode=display">(S_j + E_j) \times K_j + (S_j + E_j + E_i) \times K_i</script><p>而由于 $i$ 和 $j$ 只是交换了位置，所以 $S_j = S_i$ ；</p><script type="math/tex; mode=display">\Leftrightarrow S_i \times (K_i + K_j) + E_i \times K_i + E_j \times K_j + E_j \times K_i</script><p>对比两式可发现，我们只需判断 $E_i \times K_j$ 与 $E_j \times K_i$ 的大小关系即可。</p><p>所以只需将题目按照上述排序。</p><p>最后答案就用定义 $O(n)$ 算一遍就行了。</p><p><strong>注意开 <code>long long</code></strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> e, k;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e * rhs.k &lt; rhs.e * k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].e);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i].k);</span><br><span class="line">  sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>); <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += (s += a[i].e) * a[i].k;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Submission"><a href="#Submission" class="headerlink" title="Submission"></a><strong>Submission</strong></h1><p>由于这是一道权限题，在这里提供一下数据（好像只有一组但超大）</p><p><a href="https://www.lanzous.com/i54n1dg" target="_blank" rel="noopener">一组数据</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HEOI2014」南园满地堆轻絮</title>
      <link href="/2019/07/23/%5BHEOI2014%5D%20%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E5%A0%86%E8%BD%BB%E7%B5%AE/"/>
      <url>/2019/07/23/%5BHEOI2014%5D%20%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E5%A0%86%E8%BD%BB%E7%B5%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>对于一个正整数数列 $A_1 \cdots A_n$ ，求另一个正整数数列 $B_1 \cdots B_n$ ，使得对于任意的 $1 \leq i &lt; n$ 有 $B_i \leq B_{i + 1}$ ，而且使得 $ans = \max\{|A_j - B_j|,\ 1 \leq j \leq n\}$ 尽量小。</p><p>定义生成函数 $F(x) = S_a \times x^3 + S_b \times x^2 + S_c \times x + S_d$ ，则数列 $A$ 的递推公式为 $A_i = (F(A_{i - 1}) + F(A_{i - 2})) \% mod$</p><p>对于 $100\%$ 的数据，有 $n \leq 5000000,\ S_a,S_b,S_c,S_d,A_1 \leq 10000,\ mod \leq 1000000007$</p><a id="more"></a><p><a href="https://www.luogu.org/fe/problem/P4105" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>由于时让 $ans$ 中的最大值最小，所以很容易能想到二分答案。假设现在的答案为 $k$ ，则对于所有的 $i$ 满足 $1 \leq i \leq n$ ，都有 $|A_i - B_i| \leq k$ 。也就是说，</p><script type="math/tex; mode=display">A_i - k \leq B_i \leq A_i + k</script><p>因此我们只需每次都贪心使 $B_i$ 尽可能小即可。而如果 $B_i$ 再怎么大也大不到 $B_{i - 1}$ 时，那就说明 $k$ 不行啦！</p><p><strong>注意对 F 函数频繁取模！！！</strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000500</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s[<span class="number">5</span>], a[N], mod, ans, b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  (res += s[<span class="number">1</span>] * x % mod * x % mod * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">2</span>] * x % mod * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">3</span>] * x % mod) %= mod,</span><br><span class="line">  (res += s[<span class="number">4</span>] % mod) %= mod;</span><br><span class="line">  <span class="keyword">return</span> (res + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  b[<span class="number">1</span>] = a[<span class="number">1</span>] - k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt;= b[i - <span class="number">1</span>]) b[i] = max(a[i] - k, b[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (b[i - <span class="number">1</span>] - a[i] &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      b[i] = b[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld%lld"</span>, &amp;n, &amp;s[<span class="number">1</span>], &amp;s[<span class="number">2</span>], &amp;s[<span class="number">3</span>], &amp;s[<span class="number">4</span>], &amp;a[<span class="number">1</span>], &amp;mod);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) a[i] = (F(a[i - <span class="number">1</span>]) + F(a[i - <span class="number">2</span>])) % mod;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = mod; <span class="comment">// 要取模，所以 r 最大也超不过 mod</span></span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (chk(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, l % mod);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO10MAR」Great Cow Gathering</title>
      <link href="/2019/07/22/%5BUSACO10MAR%5D%20Great%20Cow%20Gathering/"/>
      <url>/2019/07/22/%5BUSACO10MAR%5D%20Great%20Cow%20Gathering/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给一个带边权与点权的树 $T$ （ $N$ 个结点 ），找一个点 $x$ 使 $\sum_{u \in T\ \&amp;\ u \neq x} dis_{u,x} \times c_u$ 取最大值。</p><p>对于 $100\%$ 的数据，有 $1 \leq N \leq 100000,\ 1 \leq C_i \leq 1000$ 。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P2986" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>树形 DP 。其实也不能完全算是 DP 。</p><p>我们使用调整法。对于点 $1$ ，我们可以 $O(n)$ 地算出 $f_1 = \sum_{u \in T\ \&amp;\ u \neq 1} dis_{u,1} \times C_u$</p><p>然后递归考虑 $1$ 的儿子结点 $u$ 。我们比较一下 $f_1$ 和 $f_u$ 。可以将这棵树分为两部分。其中一部分（ $up$ ）与点 $1$ 在点 $u$ 的同一边，而另一部分（ $dn$ ）则与点 $u$ 在点 $1$ 同一边。当我们的注意力从 $1$ 转到 $u$ 上时，我们发现 $f$ 的值发生了一些变化。对于 $up$ 那部分的所有点，它们都被加上了一段路程 $dis_{1,u}$ ；而对于 $dn$ 那部分的所有点，它们都减去了 $dis_{1, u}$ 。</p><p><img src="https://i.loli.net/2019/07/22/5d35c8f32385195587.png" alt="题目中的样例"></p><p>举个例子。对于图上的 $3$ ，我们发现 $f_3 = 1\times 1 + 1 \times 2 + 2 \times 6 = 15$ 。把它分成 $up$ 和 $dn$ ， $up = 3,\ dn = 12$ 。同理对于 $4$ ， $up = up_3 + 3 \times (1 + 1) = 9,\ dn = dn_3 - 3 \times 2 = 6$ 。</p><p>结果，我们发现 $up$ 和 $dn$ 都与前面有关系，所以只用记变化值就行啦。</p><p><strong>注意开 <code>long long</code> 。。</strong></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c[N], f[N], up[N], dn[N], size[N], ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="comment">// f up dn 如上文；size[u] 以 u 为根的子树大小（此处指子树中 c[i] 之和）</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> v, w; edge *next; &#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cur = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge *p = ++cur, *q = ++cur;</span><br><span class="line">  p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">  q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> dis, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 f[1]</span></span><br><span class="line">  <span class="keyword">int</span> v, res = c[u] * dis;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      res += calc(v, dis + p-&gt;w, u);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 size</span></span><br><span class="line">  <span class="keyword">int</span> v; size[u] = c[u];</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      pre(v, u); size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123; <span class="comment">// 求 f</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> ((v = p-&gt;v) != fa) &#123;</span><br><span class="line">      up[v] = (size[<span class="number">1</span>] - size[v]) * p-&gt;w;</span><br><span class="line">      dn[v] = -size[v] * p-&gt;w;</span><br><span class="line">      f[v] = f[u] + up[v] + dn[v]; <span class="comment">// 记得 up 和 dn 只是相对 u 的变化值</span></span><br><span class="line">      dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u, v, w;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;c[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    addedge(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  pre(<span class="number">1</span>, <span class="number">0</span>); f[<span class="number">1</span>] = calc(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = min(ans, f[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「AtCoder Grand Contest 025 B」RGB Coloring</title>
      <link href="/2019/07/20/%5BAtCoder%20Grand%20Contest%20025%20B%5D%20RGB%20Coloring/"/>
      <url>/2019/07/20/%5BAtCoder%20Grand%20Contest%20025%20B%5D%20RGB%20Coloring/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一个 n 层塔，每层可以不涂颜色或涂红绿蓝三种颜色之一。不涂颜色美观度 $0$ ，涂红色美观度 $A$ ，涂绿色美观度 $A + B$ ，涂蓝色美观度 $B$ 。求使所有层的美观度之和 $=K$ 的涂色方案数 $\pmod {998244353}$</p><p>对于 $100 \%$ 的数据，</p><p>$1 \leq N \leq 3 \times 10^5$</p><p>$1 \leq A,B \leq 3 \times 10^5$</p><p>$0 \leq K \leq 18 \times 10^{10}$</p><a id="more"></a><p><a href="https://atcoder.jp/contests/agc025/tasks/agc025_b" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>好像不是特别难吧（雾</p><p>换一个角度想，我们从 $A$ 和 $B$ 处入手。对于 $A$ 和 $B$ ， 我们发现这两个数可以随便地放到任意一层中，即只需满足 $0 \leq num_A,num_B \leq N$ 即可，其中 $num_x$ 表示 $x$ 在塔中出现的次数。因此可以写成</p><script type="math/tex; mode=display">Ax + By = K (0 \leq x,y \leq N)</script><p>的形式。我们只需要 $O(N)$ 枚举 $x$ 的取值，再判断与之对应的 $y$ 是否是整数。一对 $x,y$ 对答案的贡献是 $C(n, x) \times C(n, y)$ ，即 $\binom{n}{x} \times \binom{n}{y}$ 。至于为什么呢，就是因为 $A$ 和 $B$ 两个数并不冲突 —— 可以同时放在一层中，可以独自一层，也可以一层两个都没有；所以 $x$ 个 $A$ 和 $y$ 个 $B$ 可以随便在 $n$ 层中分布。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300300</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(x) (((x) + mod) % mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, k, c[N], inv[N], s[N], t[N], fac[N], ans, inv2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= mod;</span><br><span class="line">    (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = s[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 注意赋初值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % mod; <span class="comment">// 阶乘</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = <span class="number">1l</span>l * s[i - <span class="number">1</span>] * fac[i] % mod;</span><br><span class="line">  t[n] = qpow(s[n], mod - <span class="number">2</span>); <span class="comment">// 前缀积 O(n + logP) 逆元求法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) t[i - <span class="number">1</span>] = <span class="number">1l</span>l * t[i] * fac[i] % mod;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) inv[i] = <span class="number">1l</span>l * t[i] * s[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span> </span>&#123; <span class="comment">// C(M, N)</span></span><br><span class="line">  <span class="keyword">if</span> (N &lt; <span class="number">0</span> || N &gt; M) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> M(<span class="number">1l</span>l * fac[M] * M(inv[N] * inv[M - N]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;a, &amp;b, &amp;k);</span><br><span class="line">  prework();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y; x &lt;= n; x++) <span class="comment">// 枚举 x</span></span><br><span class="line">    <span class="keyword">if</span> ((k - a * x) % b == <span class="number">0</span>) &#123; <span class="comment">// 判断 y 是不是整数</span></span><br><span class="line">      y = (k - a * x) / b;</span><br><span class="line">      ans += M(<span class="number">1l</span>l * C(n, x) * C(n, y)); <span class="comment">// 贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, M(ans));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ3884」上帝与集合的正确用法</title>
      <link href="/2019/07/18/%5BBZOJ3884%5D%20%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/"/>
      <url>/2019/07/18/%5BBZOJ3884%5D%20%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>求 <script type="math/tex">2^{2^{2 \cdots}} \bmod p</script></p><p>对于 $100\%$ 的数据，有数据组数 $T \leq 1000$ ， $p \leq 10^7$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P4139" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>根据 <strong>扩展欧拉定理</strong> ，即当 $b \geq \varphi (p)$ 时，</p><script type="math/tex; mode=display">a ^ b \equiv a ^ {b \bmod \varphi(p) + \varphi(p)} \pmod{p}</script><p>而当 $b &lt; \varphi(p)$ 时，</p><script type="math/tex; mode=display">a^b \equiv a ^ {b \bmod \varphi(p)} \equiv a^b \pmod{p}</script><p><del>貌似没啥用？</del></p><p>由于题目中的 $b$ 是 $2^{2 \cdots}$ ，所以一定有 $b \geq \varphi(p)$，因此递归一下式子就做完了。</p><p>具体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 带入算一下就能得出 0</span></span><br><span class="line">  <span class="keyword">return</span> qpow(<span class="number">2</span>, work(phi[m]) + phi[m], m); <span class="comment">// 递归， qpow 是快速幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000100</span>;</span><br><span class="line"></span><br><span class="line">ll T, P, p[<span class="number">700700</span>], phi[N], cnt;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1e7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) p[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt;= <span class="number">1e7</span>; j++) &#123;</span><br><span class="line">      vis[i * p[j]] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123; phi[i * p[j]] = phi[i] * p[j]; <span class="keyword">break</span> ; &#125;</span><br><span class="line">      <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= mod;</span><br><span class="line">    (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(ll m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> qpow(<span class="number">2</span>, work(phi[m]) + phi[m], m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  prework();</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;P);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (work(P) + P) % P);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我没有研究 <code>long long</code> 是否必要，只是保险罢了</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小表示法</title>
      <link href="/2019/07/14/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2019/07/14/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有一个字符串，当我们要寻找一个位置，使其从这个位置向后形成一个新字符串，这个新字符串的字典序最小时，就能用到这个算法。</p><p>比如对于 $ABCD$ ，就有 $ABCD$ ， $BCDA$ ， $CDAB$ ， $DABC$ 这四种新字符串。</p><p>而最小的那个是 $ABCD$ 。</p><a id="more"></a><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a><strong>Operations</strong></h1><p>令 <code>i = 0, j = 1, k = 0</code> ，表示 <strong>从 i 开始 k 长度 和 从 j 开始 k 长度 的字符串相同</strong> 。</p><p>当 <code>str[i] == str[j]</code> 时，不难发现需要进行将 <code>k++</code> 的操作；</p><p>当 <code>str[i] &gt; str[j]</code> 时，我们发现 i 位置比 j 位置字典序要大，因此不能以 i 作为开头了。所以要将 i 向后移动。而 i 开头和 j 开头都有 k 个相同字符，因此要将 <code>i += (k + 1)</code> ；</p><p>同理，当 <code>str[i] &lt; str[j]</code> 时， <code>j += (k + 1)</code> 。</p><p>最后 i 和 j 中较小的那个就是答案啦。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">0</span>, t;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123;</span><br><span class="line">    t = str[(i + k) % n] - str[(j + k) % n]; <span class="comment">// 通过 t 与 0 的大小关系来判断</span></span><br><span class="line">    <span class="keyword">if</span> (!t) k++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t &gt; <span class="number">0</span>) i += (k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> j += (k + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (i == j) j++;</span><br><span class="line">      k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> min(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmin() + <span class="number">1</span>); <span class="comment">// +1 是因为字符串从第零个开始，这样更容易分辨</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 最小表示法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HNOI2003」消防局的设立</title>
      <link href="/2019/06/18/%5BHNOI2003%5D%20%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/"/>
      <url>/2019/06/18/%5BHNOI2003%5D%20%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一棵 $n$ 个结点的树，问最少几个特殊点能覆盖满整个图。</p><p>其中，一个特殊点能覆盖与它距离不超过 2 的所有点。</p><p>对于 $100\%$ 的数据，满足 $n \leq 1000$ </p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>就是个大贪心。。</p><p>每次找到深度最大的未覆盖的结点，并贪心地在它祖父结点处放个消防站（即特殊点）。由于前提，所以这个点的所有子结点全部都被覆盖了。因此放在祖父结点处最优。</p><p>那么如何判断这个点是否被覆盖了呢？问题在于兄弟结点。其实，可以用 <code>dis</code> 数组维护距离一个特殊点的最短距离；此时当 <code>dis[fa] == 1</code> 时，就能确定它被覆盖了。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, que[N], dep[N], fa[N], dis[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] &gt; dep[y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = fa[u], g = fa[f];</span><br><span class="line">  dis[u] = min(dis[u], min(dis[f] + <span class="number">1</span>, dis[g] + <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">if</span> (dis[u] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    dis[g] = <span class="number">0</span>, ans++;</span><br><span class="line">    dis[fa[g]] = min(dis[fa[g]], <span class="number">1</span>),</span><br><span class="line">    dis[fa[fa[g]]] = min(dis[fa[fa[g]]], <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); dis[<span class="number">0</span>] = INF;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = INF, que[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa[i]);</span><br><span class="line">    dep[i] = dep[fa[i]] + <span class="number">1</span>;</span><br><span class="line">    que[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(que + <span class="number">1</span>, que + n + <span class="number">1</span>, cmp); <span class="comment">// 按深度排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) upd(que[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coding Style</title>
      <link href="/2019/06/13/Coding%20Style/"/>
      <url>/2019/06/13/Coding%20Style/</url>
      
        <content type="html"><![CDATA[<p>这是本人的代码风格。</p><a id="more"></a><p>在下列规则中，部分来自于文末的谷歌代码规范。</p><h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><ul><li>两空格缩进</li><li>使用 $Fira\ Mono$ 字体，大小为 14 号</li><li>$Sublime$ 编辑器最佳</li><li>一行的长度通常不要超过 60 列，一定不能超过 90</li><li>大括号不换行，但要在大括号前加空格</li><li>运算符间通常有空格， <code>++</code> 除外</li></ul><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>通常在程序第一行 （ <code>#pragma</code> 时除外 ）</li><li><code>include</code> 和 <code>&lt;头文件&gt;</code> 之间有一个空格</li><li>通常只用一个万能头</li><li><code>#include &lt;bits/stdc++.h&gt;</code></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li><p>在头文件之后，与头文件之间空一行</p></li><li><p>在它后面也空一行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>在命名空间之后</p></li><li><p>通常只需一个定义数组大小的函数 <code>const int N = 100100;</code></p></li><li><p>如果有 <code>typedef ... ...</code> ，则将其置于 <code>const int</code> 之前</p></li><li><p>如果有 <code>#define int long long</code> 这种，则放到 <code>const int</code> 之后</p></li><li><p>如果有多个恒量（ <code>const int</code> ），则将他们分开</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>在定义之后，与定义间有空行</p></li><li><p>单行长度尽量不超过 60</p></li><li><p>两行之间不空行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll x1, x2, x3, x4, AVeryLongVariableName, a, b, c, d, e, f, g;</span><br><span class="line">ll LengthOver60NeedToChangeLine;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>在变量之后，与变量间有空行</p></li><li><p>在结构体名称与后方大括号间有空格</p></li><li><p>末尾右括号右侧加空格</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v;</span><br><span class="line">  edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>在结构体之后，不同函数间有空行，函数内部没有空行</p></li><li><p>不管是什么函数都要加上 <code>inline</code> （尽管可能没啥用。。</p></li><li><p>关于程序中语句的一些要点也就揉到这里面了</p></li><li><p><code>for</code> 、 <code>if</code> 和 <code>while</code> 后括号左侧要加空格</p></li><li><p>循环变量一般不加 <code>register</code></p></li><li><p>如果循环内语句不小于两句，就加大括号，通常两句间用分号连接</p></li><li><p>循环和判断能不加大括号就不加</p></li><li><p>不加大括号时如果把循环（判断）内的语句放到循环（判断）的同一行内的长度不超过 60 就放到同一行</p></li><li><p>永远不要把任何语句放到大括号右边</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> u; <span class="keyword">bool</span> x;</span><br><span class="line">  <span class="keyword">for</span> (edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        a[<span class="number">1</span>] = a[<span class="number">2</span>] = a[<span class="number">3</span>] = a[<span class="number">4</span>] = a[<span class="number">5</span>] = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (i) </span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// do while 要加大括号，就算只有一句</span></span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="built_in">puts</span>(<span class="string">"This is wrong!"</span>); <span class="comment">// 不能这样</span></span><br><span class="line"> <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><ul><li><p>通常把初始化写在一个函数内，在主函数内调用</p></li><li><p>通常使用 <code>int main()</code> ，除非 <code>#define int long long</code> 时才用 <code>signed main()</code></p></li><li><p>最后要 <code>return 0</code></p></li><li><p>散碎的变量统一放在主函数的开头，如果太多分两行</p></li><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> left, right, s, tag;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; tag += x, s += (right - left + <span class="number">1</span>) * x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; s = ls-&gt;s + rs-&gt;s;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ls) ls-&gt;seta(tag);</span><br><span class="line">      <span class="keyword">if</span> (rs) rs-&gt;seta(tag);</span><br><span class="line">      tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">3</span>], *root, *cnt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">  r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">  <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">    r-&gt;s = a[left];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">  r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">  build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">    r-&gt;seta(d);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;push();</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d);</span><br><span class="line">  <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right, d),</span><br><span class="line">       change(r-&gt;rs, r-&gt;rs-&gt;left, right, d);</span><br><span class="line">  r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l, r, d;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  build(root = ++cnt, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    sacnf(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">    change(root, l, r, d);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谷歌代码风格"><a href="#谷歌代码风格" class="headerlink" title="谷歌代码风格"></a>谷歌代码风格</h2><p> ( 建议在新标签页中查看大图 )</p><p><img src="https://i.loli.net/2019/05/11/5cd6cdf9517df.jpg" alt="google"></p><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/" target="_blank" rel="noopener">更详细的中文文字版在这里</a></p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>如果您有什么修改意见，也请在评论区留言，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF518D」Ilya and Escalator</title>
      <link href="/2019/06/05/%5BCF518D%5D%20Ilya%20and%20Escalator/"/>
      <url>/2019/06/05/%5BCF518D%5D%20Ilya%20and%20Escalator/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>有 $n$ 个人排成一列，每秒中队伍最前面的人 $p$ 的概率走上电梯（一旦走上就不会下电梯）或者有 $(1-p)$ 的概率不动。问 $t$ 秒过后，在电梯上的人的数量的期望。</p><p>对于 $100 \%$ 的数据，满足 $n,t\leq2000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/CF518D" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>期望 $DP$ 。</p><p>设 $dp_{i,j}$ 表示第 $i$ 秒已经走上 $j$ 个人的概率。</p><p>则有</p><script type="math/tex; mode=display">ans = \sum_{i = 1}^n dp_{t, i}</script><p>转移方程如下（一定注意边界！）：</p><script type="math/tex; mode=display">dp_{i, j}=\left\{ \begin{array}{ll}dp_{i -1,0}\times(1-p)  & j=0\\dp_{i - 1, j - 1}\times p+dp_{i-1,j}\times (1-p) & 1\le j<n \\dp_{i - 1, n}+dp_{i - 1, n - 1}\times p & j=n\end{array} \right.\ \ \\\</script><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p, dp[N][N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = (<span class="number">1.0</span> - p) * dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * p + (<span class="number">1.0</span> - p) * dp[i - <span class="number">1</span>][j];</span><br><span class="line">    dp[i][n] = dp[i - <span class="number">1</span>][n] + p * dp[i - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%lf%d"</span>, &amp;n, &amp;p, &amp;t);</span><br><span class="line">  DP();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    ans += (<span class="keyword">double</span>) (i * dp[t][i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HAOI2007」反素数</title>
      <link href="/2019/05/17/%5BHAOI2007%5D%20%E5%8F%8D%E7%B4%A0%E6%95%B0/"/>
      <url>/2019/05/17/%5BHAOI2007%5D%20%E5%8F%8D%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>对于一个数 $x$ ，只要它满足对于任意一个 $&lt; x$ 的数 $i$ ，均有 $g(i) &lt; g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1463" target="_blank" rel="noopener">题目连接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>设答案为 ans 。则有</p><script type="math/tex; mode=display">ans = 2^{\alpha_1} \cdot 3^{\alpha_2} \cdot 5^{\alpha_3} \cdot ... \cdot 31^{\alpha_{11}}</script><p>我们能够得出结论：若果 ans 为反素数，则 $\alpha_1 \geq \alpha_2 \geq \alpha_3 \geq … \geq \alpha_{11}$</p><p><del>口糊</del> 证明：</p><p>对于 ${p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$ ，假设 $p_1 &lt; p_2$ 且 $\alpha_1 &lt; \alpha_2$ ，则数 ${p_1}^{\alpha_2} \cdot {p_2}^{\alpha_1}$ 必定 $&lt;{p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$</p><p>但两数的约数个数相等，矛盾！</p><p>比如说 $2^3\cdot3^5$ ，则 $2^5\cdot3^3&lt;2^3\cdot3^5$ 但这两个数的约数和却相等。矛盾！</p><p>只需暴力递归即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], p[N] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans, mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 不必须的快速幂</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">    a *= a, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">// 更新答案</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>, tmp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++)</span><br><span class="line">  res *= (a[i] + <span class="number">1</span>);</span><br><span class="line">  tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++)</span><br><span class="line">    tmp *= qpow(p[i], a[i]);</span><br><span class="line">  <span class="keyword">if</span> (mx &lt; res) &#123;</span><br><span class="line">    mx = res;</span><br><span class="line">    ans = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mx == res &amp;&amp; ans &gt; tmp) <span class="comment">// 注意这种情况！</span></span><br><span class="line">    ans = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> last)</span> </span>&#123; <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i) last *= p[cur];</span><br><span class="line">    <span class="keyword">if</span> (last &gt; n) &#123;</span><br><span class="line">      upd(cur);</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    a[cur] = i;</span><br><span class="line">    <span class="keyword">if</span> (!i) upd(cur);</span><br><span class="line">    <span class="keyword">else</span> dfs(cur + <span class="number">1</span>, i, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">  dfs(<span class="number">1</span>, <span class="number">31</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「JZOJ4964」Rhyme</title>
      <link href="/2019/05/08/%5BJZOJ4964%5D%20Rhyme/"/>
      <url>/2019/05/08/%5BJZOJ4964%5D%20Rhyme/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>由于多次交换邮票没有满足所有人的需求，小$Z$被赶出了集邮部。无处可去的小$Z$决定加入音乐部，为了让音乐部的人注意到自己的才华，小$Z$想写一首曲子。为了让自己的曲子更好听，小$Z$找到了一些好听曲子作为模板。曲谱可以表示成只包含小写字母的字符串，小$Z$希望自己最终的曲谱中任意一个长度为$K$的子串都是一个模板的子串。现在小$Z$想知道自己的曲谱最长可以是多长，如果可以无限长的话请输出<code>INF</code>。</p><a id="more"></a><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><strong>Input</strong></h2><p>本题的每个测试点有多组数据，对于每组数据：</p><p>第一行两个整数$N$，$K$分别表示模板的个数与$K$值。</p><p>接下来$N$行，每行一个字符串表示一个模板。（只包含$’a’$~$’z’$）</p><p>每组数据字符串总长不超过$100000$，$1\leq K\leq100000$。每个测试点数据不超过$10$组。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每组数据输出一行表示曲子最长可以是多长，如果可以无限长的话输出$INF$。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br><span class="line">abcabc</span><br><span class="line">1 5</span><br><span class="line">abcabc</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INF</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p> 第一个样例的曲子可以是$”abc”$不断循环。 第二个样例的曲子最长是$”abcabc”$。</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于一个$K$值来说，任意一个长度小于$K$的字符串均可行。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>字符串哈希 + 拓扑排序。</p><p>题目中给了固定的$K$，因此很容易想到字符串哈希。</p><p>于是我们可以哈希一下所有长度为$(K-1)$的子串，前一个与后一个以哈希值连边。最后拓扑一下就行了。</p><p>特别地，如果图上有环，那就说明是$INF$。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2e6</span>;</span><br><span class="line"><span class="keyword">const</span> ull MOD = <span class="number">9223372036854775807</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> T, n, k, ans;</span><br><span class="line"><span class="keyword">int</span> ind[M], S[N], f[M];</span><br><span class="line">ull hs[M], K;</span><br><span class="line"><span class="keyword">bool</span> vis[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[M], *cnt = pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt; ind[v]++;</span><br><span class="line">    vis[u] = vis[v] = <span class="literal">true</span>;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">qpow</span><span class="params">(ull a, ull b)</span> </span>&#123;</span><br><span class="line">    ull res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) (res *= a) %= MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>, (a *= a) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">Hash</span><span class="params">(ull d)</span> </span>&#123;</span><br><span class="line">    ull p = d % M;</span><br><span class="line">    <span class="keyword">while</span>(hs[p] &amp;&amp; hs[p] != d) &#123;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">if</span>(p &gt;= M) p -= M;</span><br><span class="line">    &#125;</span><br><span class="line">    hs[p] = d;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tpsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        u = Q.front(); Q.pop();</span><br><span class="line">        ans = max(ans, f[u]);</span><br><span class="line">        <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(--ind[v = p-&gt;v]))</span><br><span class="line">                Q.push(v);</span><br><span class="line">            f[v] = max(f[v], f[u] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    K = qpow(<span class="number">26</span>, k - <span class="number">1</span>);</span><br><span class="line">    cnt = pool;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span>(ind));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) Q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;T, &amp;k) != EOF) &#123;</span><br><span class="line">        prework();</span><br><span class="line">        <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>);</span><br><span class="line">            n = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(n &lt; k) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                S[i] = num(str[i]);</span><br><span class="line">            ull tmp = <span class="number">0</span>, u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">                (tmp *= <span class="number">26</span>) += S[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++) &#123;</span><br><span class="line">                u = Hash(tmp);</span><br><span class="line">                (tmp *= <span class="number">26</span>) += (ull) (S[i] - S[i - k + <span class="number">1</span>] * K);</span><br><span class="line">                v = Hash(tmp);</span><br><span class="line">                addedge(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i] &amp;&amp; !ind[i])</span><br><span class="line">                Q.push(i), f[i] = k - <span class="number">1</span>;</span><br><span class="line">        tpsort();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">            <span class="keyword">if</span>(ind[i] &amp;&amp; vis[i]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">"INF"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 字符串哈希 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策单调性</title>
      <link href="/2019/05/04/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"/>
      <url>/2019/05/04/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在做动归题时，我们常会遇到复杂度过高的情况。</p><p>决策单调性可以帮你减轻复杂度带来的负担。</p><a id="more"></a><h1 id="Monge-Condition"><a href="#Monge-Condition" class="headerlink" title="Monge Condition"></a><strong>Monge Condition</strong></h1><p>即 <strong>四边形不等式</strong>；</p><p>对于 $w(i,j)$ 和依次递增的四个数 $a, b, c, d$</p><p>只要</p><script type="math/tex; mode=display">w(a, c) + w(b, d) \leq w(a, d) + w(b, c)</script><p>那么我们就说函数 $w(i, j)$ 满足四边形不等式。</p><p>就好比一个矩形，其左上角为 $(a, c)$，右下角为 $(b, d)$，左上角的值加右下角的值</p><p>其名称也是因此而来的。</p><h1 id="决策单调性"><a href="#决策单调性" class="headerlink" title="决策单调性"></a><strong>决策单调性</strong></h1><p>对于一个转移方程</p><script type="math/tex; mode=display">f_i = \min(f_j + w_{j, i})</script><p>其中 $1 \leq j &lt; i$；</p><p>设 $opt(i)$ 代表 $(f_j + w_{j, i})$ 最小时的 $j$，即</p><script type="math/tex; mode=display">f_i = f_{opt(i)} + w_{opt(i), i}</script><p>这里显然有 $opt(i) &lt; i$</p><p><strong>决策单调性</strong>就是指 $opt(i) \leq opt(i + 1)$</p><p>结论：若 $w_{i, j}$ 满足四边形不等式，则转移方程满足决策单调性，即</p><p><strong>四边形不等式推出决策单调性</strong>。</p><p>证明:</p><p>由定义，</p><script type="math/tex; mode=display">f_i = f_{opt(i)} + w_{opt(i), i}</script><script type="math/tex; mode=display">f_{i + 1} = f_{opt(i + 1)} + w_{opt(i + 1), i + 1}</script><p>$w$ 满足 $Monge\ Condition$；</p><p>若 $opt(i) &gt; opt(i + 1)$，即决策单调性不成立；</p><script type="math/tex; mode=display">opt(i + 1) < opt(i) \leq i < i + 1</script><p>令 $a = opt(i + 1),\ b = opt(i),\ c = i,\ d = i + 1$；</p><p>由 $Monge\ Condition$，</p><script type="math/tex; mode=display">w(a, c) + w(b, d) \leq w(a, d) + w(b, c)</script><p>因为 $f_i$ 和 $f_{i + 1}$ 都取到了最小值，所以 $(f_i + f_{i + 1})_{\min}$</p><p>而</p><p>$(f_i + f_{i + 1}) = f_a + f_b + w(a, d) + w(b, c)$</p><p>​                 $\geq f_a + f_b + w(a, c) + w(b, d)$</p><p>矛盾！</p><p>取法：</p><p>令 $f_i = f_{opt(i + 1)} + w_{opt(i + 1), i}$，$f_(i + 1) = f_{opt(i)} + w_{opt(i), i + 1}$，</p><p>即互换 $opt(i),\ opt(i + 1)$ 即可。</p><p>∴$opt(i) \leq opt(i + 1)$</p><p>证毕。</p><p>简单例题：</p><p><a href="https://www.luogu.org/problemnew/show/CF321E" target="_blank" rel="noopener">「CF321E」Ciel and Gondolas</a></p><p><a href="https://www.luogu.org/problemnew/show/P1912" target="_blank" rel="noopener">「NOI2009」诗人小G</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> DP </tag>
            
            <tag> 四边形不等式 </tag>
            
            <tag> 公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SPOJ1811」LCS - Longest Common Substring</title>
      <link href="/2019/04/27/%5BSPOJ1811%5D%20LCS%20-%20Longest%20Common%20Substring/"/>
      <url>/2019/04/27/%5BSPOJ1811%5D%20LCS%20-%20Longest%20Common%20Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出<code>0</code> 。</p><p>对于$100 \%$的数据，$|S| \leq 250000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/SP1811" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>这道题可以作为后缀数组的练手题。<del>调了5个小时。。。</del></p><p>后缀数组是对一个字符串的操作啊，那这道题不是2个嘛？</p><p>把它整到一个里面就行啦！</p><p>忽然想到$Manacher$算法，中间每两个字符不是用<code>$</code>隔开了吗？</p><p>对啊！</p><p>就在两个单词中间加个<code>$</code>就行啦~</p><p>举个栗子：</p><script type="math/tex; mode=display">S_1 = "firststring"</script><script type="math/tex; mode=display">S_2 = "secondstring"</script><p>（双引号不包括在字符串中）</p><p>则整合后的字符串</p><script type="math/tex; mode=display">S = "firststring$secondstring"</script><p>很简单吧、</p><p>于是这个问题就转化为了在一个字符串里找最长重复子串啦</p><p>——这不就是$height$数组嘛</p><p>但是注意有一个小条件</p><p><strong>两个最长子串必须在不同的单词之间哦！</strong></p><p>这个<del>随便</del>判断一下就行啦。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, len, x[N], y[N];</span><br><span class="line"><span class="keyword">int</span> rk[N], sa[N], h[N], c[N], a[N];</span><br><span class="line"><span class="comment">// 其中 h 数组就是 height 数组</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        c[x[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        x[i] = a[i], y[i] = i;</span><br><span class="line">    rsort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - k + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            y[++p] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(sa[i] &gt; k)</span><br><span class="line">                y[++p] = sa[i] - k;</span><br><span class="line"></span><br><span class="line">        rsort();</span><br><span class="line">        swap(x, y);</span><br><span class="line"></span><br><span class="line">        x[sa[<span class="number">1</span>]] = <span class="number">1</span>, p = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(y[sa[i]] == y[sa[i - <span class="number">1</span>]]</span><br><span class="line">            &amp;&amp; y[sa[i] + k] == y[sa[i - <span class="number">1</span>] + k])</span><br><span class="line">                x[sa[i]] = p - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x[sa[i]] = p++;</span><br><span class="line"></span><br><span class="line">        m = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        rk[sa[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        j = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(L) L--;</span><br><span class="line">        <span class="keyword">while</span>(a[i + L] == a[j + L])</span><br><span class="line">            L++;</span><br><span class="line">        h[rk[i]] = L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s[<span class="number">0</span>], s[<span class="number">1</span>]);</span><br><span class="line">    len = n = <span class="built_in">strlen</span>(s[<span class="number">0</span>]),</span><br><span class="line">    m = <span class="built_in">strlen</span>(s[<span class="number">1</span>]);</span><br><span class="line">    n += m + <span class="number">1</span>, m = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        a[i] = s[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    a[len + <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len + <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = s[<span class="number">1</span>][i - len - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    getSA();</span><br><span class="line">    getH();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &gt; len &amp;&amp; sa[i - <span class="number">1</span>] &lt; len)</span><br><span class="line">        || (sa[i] &lt; len &amp;&amp; sa[i - <span class="number">1</span>] &gt; len))</span><br><span class="line">            ans = max(ans, h[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ2561」最小生成树</title>
      <link href="/2019/03/27/%5BBZOJ2561%5D%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/03/27/%5BBZOJ2561%5D%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。</p><p>对于$100\%$的数据，$N,\ L \leq 20000$，$M \leq 200000$</p><a id="more"></a><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2561" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>思路妙啊！</p><p>如果$L$那条边可能出现在最小生成树上，那么就有边权$&lt;L$的边不能连通其两端点$(u, v)$，否则将$u$和$v$连起来再删除$L$那条边显然更小。这不就是最小割嘛！</p><p>最大生成树也同理，于是答案就是两次最小割之和。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200200</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T, L, lev[N], ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    edge *next, *rev;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool)),</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(h)),</span><br><span class="line">    cnt = pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt, *q = ++cnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;c = c, p-&gt;next = h[u], h[u] = p, p-&gt;rev = q;</span><br><span class="line">    q-&gt;v = u, q-&gt;c = c, q-&gt;next = h[v], h[v] = q, q-&gt;rev = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">makelev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">memset</span>(lev, <span class="number">-1</span>, <span class="keyword">sizeof</span>(lev));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(S), lev[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        u = Q.front(), Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(!(lev[v = p-&gt;v] + <span class="number">1</span>) &amp;&amp; p-&gt;c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lev[v] = lev[u] + <span class="number">1</span>;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">return</span> (lev[T] != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, res = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">if</span>(u == T) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(lev[v = p-&gt;v] == lev[u] + <span class="number">1</span> &amp;&amp; p-&gt;c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f = dfs(v, min(p-&gt;c, flow));</span><br><span class="line">            flow -= f, p-&gt;c -= f;</span><br><span class="line">            res += f, p-&gt;rev-&gt;c += f;</span><br><span class="line">            <span class="keyword">if</span>(!flow) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res) lev[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(makelev()) res += dfs(S, INF);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a[i].u, &amp;a[i].v, &amp;a[i].c);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;S, &amp;T, &amp;L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].c &gt; L)</span><br><span class="line">            addedge(a[i].u, a[i].v, <span class="number">1</span>); <span class="comment">// 注意这里的边权</span></span><br><span class="line">    ans += dinic();</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].c &lt; L)</span><br><span class="line">            addedge(a[i].u, a[i].v, <span class="number">1</span>); <span class="comment">// 这里也是</span></span><br><span class="line">    ans += dinic();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">3 2 1</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「HDU6203」ping ping ping</title>
      <link href="/2019/03/21/%5BHDU6203%5D%20ping%20ping%20ping/"/>
      <url>/2019/03/21/%5BHDU6203%5D%20ping%20ping%20ping/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 <code>U V</code> 无法连通。问无法通行的点最少有多少个。</p><p>对于$100 \%$的数据，$3 \leq n \leq 10^4$，$p \leq 5 \times 10^4$</p><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6203" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>考虑到我们要求的是$u$到$v$上不能通行，<del>很显然</del> 能想到可以通过树上前序与后序$DFS$序来维护。具体方法如下：</p><p>根据所给的树预处理出每个点的前序 $DFS$ 序和后序$DFS$ 序（需一起标号），和每个点的深度。</p><p>根据 $p$ 组 <code>U V</code> 处理<strong>每组两点之间的 $LCA$</strong> 。压入优先队列（$LCA$ 深度大的点优先，即往前走）。</p><p>对于出队的<code>U V</code>及其<strong>对应的 $LCA$</strong> ，判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。</p><p>判断点 $U$ 或点 $V$ 是否在<strong>之前已禁止的某点的子树中</strong>。</p><p><strong>处理方式</strong>：由于之前已经处理出每个点的前后序 $DFS$ 序 $in$ 和 $out$ 。</p><p>对于某点 $U$ 若在已禁止通行点 $P$ 的子树中，则 $In[P]≤In[U]≤Out[U]≤Out[P]In[P]≤In[U]≤Out[U]≤Out[P]$ 一定成立。</p><p>故利用树状数组区间更新单点查询。对每个禁止通行点 $P$ ，标记区间 $[In[P],Out[P]][In[P],Out[P]]$ 中所有点。查询时，若点 $In[U]$ 被标记，则说明 <code>U V</code> 已经被隔断。</p><p>同时，由于优先处理 $LCA$ 深度大的点，不会出现点 <code>U V</code> 同时在同一个被禁止通行点 $P$ 的子树内。</p><p>若 $U$ ，$V$ 均不在被禁止的点在子树内，则禁止 <code>U V</code> 的 $LCA$ 点，同时对答案贡献 $+1$ 。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">int</span> n, p, in[N], out[N], tot, dep[N];</span><br><span class="line"><span class="keyword">int</span> st[N][<span class="number">25</span>], fa[N], C[N &lt;&lt; <span class="number">1</span>], ans;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; pool[N &lt;&lt; <span class="number">1</span>], *h[N], *cnt = pool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, lca;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> P &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dep[lca] &lt; dep[x.lca];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; rec;</span><br><span class="line">priority_queue&lt;P&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123; <span class="comment">// 注意多组数据的清空</span></span><br><span class="line">    ans = tot = <span class="number">0</span>, cnt = pool, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) pq.pop();</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(h)),</span><br><span class="line">    <span class="built_in">memset</span>(pool, <span class="number">0</span>, <span class="keyword">sizeof</span>(pool)),</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in)),</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span>(out)),</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep)),</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st)),</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)),</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis)),</span><br><span class="line">    <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span>(C));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt, *q = ++cnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">    q-&gt;v = u, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; in[u] = ++tot;</span><br><span class="line">    dep[u] = depth, vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(!vis[v = p-&gt;v]) &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dfs(v, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    out[u] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[v] - dep[u] &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(st[u][i] != st[v][i])</span><br><span class="line">            u = st[u][i],</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">return</span> fa[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= lowbit(x))</span><br><span class="line">        res += C[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt; (N &lt;&lt; <span class="number">1</span>); x += lowbit(x))</span><br><span class="line">        C[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// 主要函数</span></span><br><span class="line">    <span class="keyword">int</span> u, v; prework();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addedge(++u, ++v);</span><br><span class="line">    &#125; ++n, dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        st[i][<span class="number">0</span>] = fa[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            st[j][i] = st[st[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        rec.u = ++u, rec.v = ++v,</span><br><span class="line">        rec.lca = LCA(u, v);</span><br><span class="line">        pq.push(rec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        rec = pq.top(), pq.pop();</span><br><span class="line">        <span class="keyword">if</span>(!(sum(in[rec.u]) + sum(in[rec.v])))</span><br><span class="line">            change(in[rec.lca], <span class="number">1</span>),</span><br><span class="line">            change(out[rec.lca] + <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">            ans++;</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)</span><br><span class="line">        work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 倍增 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> DFS序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SPOJ1043」GSS1</title>
      <link href="/2019/03/17/%5BSPOJ1043%5D%20GSS1/"/>
      <url>/2019/03/17/%5BSPOJ1043%5D%20GSS1/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给一段可能有负数的序列，查询最大子段和。</p><p>对于$100 \%$的数据，序列长度$N \leq 50000$，$a[i] \leq 15007$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/SP1043" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>线段树查询最大子段和。</p><p>这里需要维护四个信息：</p><ul><li>$s$ 区间和</li><li>$mx$ 区间最大子段和</li><li>$lmx$ 区间前缀和最大值</li><li>$rmx$ 区间后缀和最大值</li></ul><p>则维护的时候就像这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = ls-&gt;s + rs-&gt;s,</span><br><span class="line">mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), <span class="comment">// 注意有三种情况</span></span><br><span class="line">lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),</span><br><span class="line">rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx);</span><br></pre></td></tr></table></figure><p>其中$ls$，$rs$分别是左子，右子。</p><p>还有一个注意事项：$query$（查询）的时候返回值要是$node*$！只有这样才能够维护四个信息。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><p><del>码风在这种题里很重要</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1001000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, mx, lmx, rmx, s;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = ls-&gt;s + rs-&gt;s,</span><br><span class="line">        mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)),</span><br><span class="line">        lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),</span><br><span class="line">        rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">5</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;s = r-&gt;mx = r-&gt;lmx = r-&gt;rmx = a[left];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node *<span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        node *L, *R, *res;</span><br><span class="line">        L = query(r-&gt;ls, left, r-&gt;ls-&gt;right),</span><br><span class="line">        R = query(r-&gt;rs, r-&gt;rs-&gt;left, right),</span><br><span class="line">        res = ++cnt,</span><br><span class="line">        res-&gt;s = L-&gt;s + R-&gt;s,</span><br><span class="line">        res-&gt;left = L-&gt;left, res-&gt;right = R-&gt;right,</span><br><span class="line">        res-&gt;mx = max(L-&gt;rmx + R-&gt;lmx, max(L-&gt;mx, R-&gt;mx)),</span><br><span class="line">        res-&gt;lmx = max(L-&gt;s + R-&gt;lmx, L-&gt;lmx),</span><br><span class="line">        res-&gt;rmx = max(R-&gt;s + L-&gt;rmx, R-&gt;rmx);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    build(root = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;left, &amp;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(root, left, right)-&gt;mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ZJOI2009」时态同步</title>
      <link href="/2019/03/15/%5BZJOI2009%5D%20%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/03/15/%5BZJOI2009%5D%20%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。</p><p>对于$100\%$的数据，$N \leq 500000$，边权$t_e \leq 1000000$。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1131" target="_blank" rel="noopener">题目连接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>树形$DP$的板子题。</p><p>令$dp_x$为叶子结点到$x$结点的最大时间。</p><p>则有 $dp_x = \max (dp_{son[x]} + dis_{x,\ son[x]})$</p><p>因此 $ans = \sum (dp_x - dp_{son[x]} - dis_{x,\ son[x]})$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> n, root, dp[MAXN], ans, fa[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">1</span>], *h[MAXN], *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge *p = ++cnt, *q = ++cnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">    q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>(!vis[v = p-&gt;v]) &#123;</span><br><span class="line">            fa[v] = u, dfs(v);</span><br><span class="line">            dp[u] = max(dp[u], dp[v] + p-&gt;w);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>((v = p-&gt;v) != fa[u])</span><br><span class="line">            ans += (dp[u] - dp[v] - p-&gt;w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        addedge(u, v, w);</span><br><span class="line">    &#125; dfs(root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> DP </tag>
            
            <tag> 数位DP </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SCOI2009」windy 数</title>
      <link href="/2019/03/10/%5BSCOI2009%5D%20windy%E6%95%B0/"/>
      <url>/2019/03/10/%5BSCOI2009%5D%20windy%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>求$A$，$B$之间所有满足相邻两位之间差$\geq2$的整数。</p><a id="more"></a><p>对于$100$%的数据，</p><p>$1 \leq A \leq B \leq 2 \times 10^9$。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>数位$DP$模板题。</p><p>令$dp_{i,j}$表示第$i$位，上一位为$j$的总方案数（一直到结束）。</p><p>然后逐位$DP$即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">11</span>], d[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[x][p] + <span class="number">1</span>) <span class="keyword">return</span> dp[x][p];</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> dp[x][p] = <span class="number">1</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; <span class="number">10</span>; q++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(p - q) &gt;= <span class="number">2</span>)</span><br><span class="line">            res += calc(x - <span class="number">1</span>, q);</span><br><span class="line">    <span class="keyword">return</span> dp[x][p] = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, ans = <span class="number">0</span>, pre = <span class="number">-110</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) d[m++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            ans += calc(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = (i == m - <span class="number">1</span>); j &lt; d[i]; j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(pre - j) &gt;= <span class="number">2</span>)</span><br><span class="line">                ans += calc(i, j);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(pre - d[i]) &lt; <span class="number">2</span>) <span class="keyword">break</span> ;</span><br><span class="line">        pre = d[i];</span><br><span class="line">    &#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll l, r;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(r + <span class="number">1</span>) - solve(l));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非旋 Treap 详解</title>
      <link href="/2019/03/09/%E9%9D%9E%E6%97%8BTreap%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/03/09/%E9%9D%9E%E6%97%8BTreap%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><ul><li>“$Treap$的旋转好难啊！”</li><li>“你不知道非旋$treap$吗？”</li><li>（被一顿吊打。。</li></ul><p>这就是$FHQ-Treap$。</p><a id="more"></a><p>前置技能：小根堆 &amp; $Treap$（不必须）</p><p>提示：此博客图片较多，如无法加载请刷新重试~</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a><strong>Definition</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, rnd, size;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">1</span>], *root, *cnt = pool;</span><br></pre></td></tr></table></figure><p>$d$是真实权值，$rnd$是随机权值，$size$是子树大小；</p><p>$ls$是左儿子，$rs$是右儿子；</p><p>$upd$是从下往上更新信息（例如$size$）；</p><p>$push$是下发懒标记。</p><p>$root$是根。</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a><strong>Operations</strong></h1><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a><strong>Merge</strong></h2><blockquote><p>假设有两颗子树x，y，且 x 的所有节点的值都小于 y 的所有节点的值，随机权值 rnd 都以小根堆的形式存储。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/09/ApKfjU.md.png" alt="img"></p><blockquote><p>此时要合并 x , y 。我们先比较它们的根的随机权值，发现1&lt;3，因为要满足小根堆性质，于是 x 的左子树全部不变，让它的右子树继续和 y 合并。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/09/ApKIHJ.png" alt="img"></p><blockquote><p>这时我们发现，随机权值 rnd 5&gt;3，所以 y 接到 root(图中rot) 的下方，成为 root 的右儿子，y的右子树全部不变，让y的左子树继续和x合并（以满足平衡树的性质）。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/09/ApKq9x.png" alt="img"></p><blockquote><p>由于5&gt;4，所以y和y的右子树作为root的左儿子，y的左子树继续和x合并。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/09/ApKOgK.png" alt="img"></p><p>以此类推……</p><blockquote><p>最后，我们发现 x 为 0 ，所以直接返回 y ，合并结束。</p></blockquote><p><img src="https://s2.ax1x.com/2019/03/09/ApKzHH.png" alt="img"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> node *<span class="title">merge</span><span class="params">(node *l, node *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l || !r) <span class="keyword">return</span> l ? l : r; <span class="comment">// 如果有一边为空</span></span><br><span class="line">    <span class="keyword">if</span>(l-&gt;rnd &lt; r-&gt;rnd) &#123;</span><br><span class="line">        l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r);</span><br><span class="line">        l-&gt;upd(); <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls);</span><br><span class="line">        r-&gt;upd(); <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Split"><a href="#Split" class="headerlink" title="Split"></a><strong>Split</strong></h2><h3 id="1-按权值split"><a href="#1-按权值split" class="headerlink" title="1.按权值split"></a><strong>1.按权值split</strong></h3><p><strong>首先得有个基准值 a ，即权值小于等于 a 的节点全部进入左树（下图中会将此类节点染红），大于a的节点全部进入右树（下图中会将此类节点染蓝）。这里以a=25为例。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/03/10/AphjbV.png" alt="img"></strong></p><p><strong>首先，发现rot的权值=15&lt;25，由平衡树的性质可知，rot的左子树所有节点权值一定小于25，所以rot和它的的左子树全部进入左树，继续拆分rot的右子树。<img src="https://s2.ax1x.com/2019/03/10/Ap49C4.png" alt="img"></strong></p><p><strong>32&gt;25，所以 rot 和它的右子树全部进入右树，继续拆分 rot 的左子树。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/03/10/Ap4Eb6.png" alt="img"></strong></p><p><strong>29&gt;25，同上。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/03/10/Ap4ZVK.png" alt="img"></strong></p><p><strong>24&lt;25，所以拆分右子树。</strong></p><p><strong><img src="https://s2.ax1x.com/2019/03/10/Ap4uPe.png" alt="img"></strong></p><p><strong>27&gt;25，所以拆分左子树。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814152536646-1615235790.png" alt="img"></strong></p><p><strong>发现此时rot为0，所以拆分完毕，返回。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814152643050-795170931.png" alt="img"></strong></p><h3 id="2-按排名split"><a href="#2-按排名split" class="headerlink" title="2.按排名split"></a><strong>2.按排名split</strong></h3><p><strong>就是把前 k 个节点拆入左树，其它节点拆入右树。这里以k=5为例。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814153403477-1682598802.png" alt="img"></strong></p><p><strong>rot的左子树的siz+1=3&lt;5，所以rot和它的左子树进入左树，其他节点拆分5-3=2个节点进入左树。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814153632322-1787907212.png" alt="img"></strong></p><p><strong>4+1&gt;2，所以rot和右子树进入右树，其它节点继续拆分出2个节点进入左树。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814153933324-224764421.png" alt="img"></strong></p><p><strong>3+1&gt;2，同上。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814154037541-2021185885.png" alt="img"></strong></p><p><strong>1+1=2，所以rot和左子树进入左树，其它节点继续拆分2-2=0个节点进入左树。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814154301570-1914457813.png" alt="img"></strong></p><p><strong>1+0&gt;0，所以rot和右子树进入右树，其它节点继续拆分0个节点进入左树。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814154442044-1133591279.png" alt="img"></strong></p><p><strong>rot为0，拆分结束。</strong></p><p><strong><img src="https://images2018.cnblogs.com/blog/1370382/201808/1370382-20180814154513584-1167652573.png" alt="img"></strong></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a><strong>Code</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按排名分</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(node *p, node *&amp;l, node *&amp;r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123; l = r = <span class="literal">NULL</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    p-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k);</span><br><span class="line">    <span class="keyword">else</span> l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - <span class="number">1</span>);</span><br><span class="line">    p-&gt;upd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Other-Operations"><a href="#Other-Operations" class="headerlink" title="Other Operations"></a><strong>Other Operations</strong></h1><p><strong>FHQ treap 的核心操作只有 merge 和 split 两个，其他操作都是基于这两个操作实现的。</strong></p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h2><p><strong>插入权值为 x 的节点时，先新建一个节点，再以 x 为界按权值 split 整棵树为a,b，再按顺序 merge a，x，b。</strong></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h2><p><strong>要删除x，先将整棵树以 x-1 为界按权值split 成a和b，再将 b 以 1 为界 按排名split 成c和d，则 c 就是要删除的节点。最后按顺序merge a，b，d。</strong></p><p><strong>（当然，这是在要删除节点必定存在的情况下才能进行的操作，不存在的情况请自行脑补）</strong> </p><h2 id="查询-x-的排名"><a href="#查询-x-的排名" class="headerlink" title="查询 x 的排名"></a><strong>查询 x 的排名</strong></h2><p><strong>先将整棵树以x-1按权值split成a和b，则a的siz+1即为x的排名。</strong></p><h2 id="查询排名为-k-的值"><a href="#查询排名为-k-的值" class="headerlink" title="查询排名为 k 的值"></a><strong>查询排名为 k 的值</strong></h2><p><strong>先split出整棵树前k-1小节点，则右树最小节点即为所求节点，再次split 即可。</strong></p><h2 id="查x前驱"><a href="#查x前驱" class="headerlink" title="查x前驱"></a><strong>查x前驱</strong></h2><p><strong>将整棵树以x-1按权值split，左树中最大节点即为所求节点，转入第x小值问题。</strong></p><h2 id="查x后继"><a href="#查x后继" class="headerlink" title="查x后继"></a><strong>查x后继</strong></h2><p><strong>将整棵树以x按权值split，右树中最小节点即为所求节点，转入第x小值问题。</strong></p><h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a><strong>Problems</strong></h1><p><a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener">文艺平衡树</a></p><h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a><strong>Code</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size(a) ((a) ? a-&gt;size : 0)</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, rnd, size, tag;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sets</span><span class="params">()</span> </span>&#123; tag ^= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; size = size(ls) + size(rs) + <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag) &#123;</span><br><span class="line">            swap(ls, rs);</span><br><span class="line">            <span class="keyword">if</span>(ls) ls-&gt;sets();</span><br><span class="line">            <span class="keyword">if</span>(rs) rs-&gt;sets();</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">1</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node *<span class="title">newnode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">// 新建</span></span><br><span class="line">    node *p = ++cnt;</span><br><span class="line">    p-&gt;d = d, p-&gt;rnd = (rand() &lt;&lt; <span class="number">15</span>) + rand(),</span><br><span class="line">    p-&gt;size = <span class="number">1</span>, p-&gt;tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node *<span class="title">merge</span><span class="params">(node *l, node *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l || !r) <span class="keyword">return</span> l ? l : r;</span><br><span class="line">    <span class="keyword">if</span>(l-&gt;rnd &lt; r-&gt;rnd) &#123;</span><br><span class="line">        l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r);</span><br><span class="line">        l-&gt;upd(); <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls);</span><br><span class="line">        r-&gt;upd(); <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(node *p, node *&amp;l, node *&amp;r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123; l = r = <span class="literal">NULL</span>; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    p-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k);</span><br><span class="line">    <span class="keyword">else</span> l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - <span class="number">1</span>);</span><br><span class="line">    p-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rk</span><span class="params">(node *p, <span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 排名</span></span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;d &gt;= x) <span class="keyword">return</span> rk(p-&gt;ls, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> size(p-&gt;ls) + <span class="number">1</span> + rk(p-&gt;rs, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// 翻转</span></span><br><span class="line">    node *p, *q, *s;</span><br><span class="line">    split(root, p, q, l - <span class="number">1</span>),</span><br><span class="line">    split(q, q, s, r - l + <span class="number">1</span>);</span><br><span class="line">    q-&gt;tag ^= <span class="number">1</span>, root = merge(merge(p, q), s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(node *r)</span> </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">    r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls) print(r-&gt;ls);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, r-&gt;d);</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;rs) print(r-&gt;rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) <span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        node *tmp = newnode(i);</span><br><span class="line">        root = merge(root, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;left, &amp;right);</span><br><span class="line">        rev(left, right);</span><br><span class="line">    &#125; print(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="After-Words"><a href="#After-Words" class="headerlink" title="After Words"></a><strong>After Words</strong></h1><p>此文章参考了部分以下文章，出处：</p><p><a href="https://www.cnblogs.com/Judge/p/9506980.html" target="_blank" rel="noopener">https://www.cnblogs.com/Judge/p/9506980.html</a></p><p>（这篇文章很优质！）</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fhq-treap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「luogu1558」色板游戏</title>
      <link href="/2019/03/06/%5Bluogu1558%5D%20%E8%89%B2%E6%9D%BF%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/03/06/%5Bluogu1558%5D%20%E8%89%B2%E6%9D%BF%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作：</p><ul><li>将$a[l]$到$a[r]$赋值为$d$；</li><li>询问$a[l]$到$a[r]$有几种不同的数。</li></ul><p>操作$m$次，$d \in [1,\ t]$</p><p>对于$100$%的数据，</p><p>$1 \leq n \leq 100000$，$1 \leq t \leq 30$，$1 \leq m \leq 100000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1558" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>线段树的基础题 <del>然后我错了9遍</del></p><p>很有意思的一道题，有两种不同的解法</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a><strong>解法一</strong></h2><p>比较暴力，建$t$棵线段树即可。</p><p>第$i$棵线段树只存值为$i$的数组有哪些。</p><p><strong>常数比较大。</strong></p><p>$6$次提交，不开$O2$最高只能$80$分，就算开了$O2$也只能$90$。。</p><p>你们自己想卡常就卡去吧。。</p><p>我的$80$分代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, mx, tag;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; tag = x, mx = (x == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; mx = max(ls-&gt;mx, rs-&gt;mx);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ls) ls-&gt;seta(tag);</span><br><span class="line">            <span class="keyword">if</span>(rs) rs-&gt;seta(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">8</span>], *root[<span class="number">35</span>], *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build1</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;mx = <span class="number">1</span>; <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build1(ls, left, mid), build1(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">        r-&gt;seta(d); <span class="keyword">return</span> ;</span><br><span class="line">    &#125; r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right, d),</span><br><span class="line">         change(r-&gt;rs, r-&gt;rs-&gt;left, right, d);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r-&gt;mx;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> max(query(r-&gt;ls, left, r-&gt;ls-&gt;right),</span><br><span class="line">                    query(r-&gt;rs, r-&gt;rs-&gt;left, right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A, B, C, ans;</span><br><span class="line">    n = read(), t = read(), m = read();</span><br><span class="line">    build1(root[<span class="number">1</span>] = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= t; i++)</span><br><span class="line">        build(root[i] = ++cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch);</span><br><span class="line">        A = read(), B = read();</span><br><span class="line">        <span class="keyword">if</span>(A &gt; B) swap(A, B);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">            C = read();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">                <span class="keyword">if</span>(i != C) change(root[i], A, B, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> change(root[C], A, B, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">                ans += query(root[i], A, B);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a><strong>解法二</strong></h2><p>$100$%的正解。</p><p>用二进制来表示区间的取值情况。</p><p>比如$a_1 = 1,\ a_2 = 2,\ a_3 = 3,\ a_4 = 2$，</p><p>我们不妨设数值$i$是$2^{i - 1}$</p><p>则1,2合起来就是0011；</p><p>1,3合起来就是0101；</p><p>注意：<strong>2,3,4合起来是0110而不是0120！</strong></p><p>大体上和解法一比较类似</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, s, tag; <span class="comment">// s 就是存压位的那个。</span></span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; s = (<span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>)), tag = x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; s = (ls-&gt;s | rs-&gt;s);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ls) ls-&gt;seta(tag);</span><br><span class="line">            <span class="keyword">if</span>(rs) rs-&gt;seta(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">3</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;s = <span class="number">1</span>; <span class="keyword">return</span> ;</span><br><span class="line">    &#125; <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">        r-&gt;seta(d); <span class="keyword">return</span> ;</span><br><span class="line">    &#125; r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right, d),</span><br><span class="line">         change(r-&gt;rs, r-&gt;rs-&gt;left, right, d);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r-&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (query(r-&gt;ls, left, r-&gt;ls-&gt;right) |</span><br><span class="line">                query(r-&gt;rs, r-&gt;rs-&gt;left, right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x -= (<span class="number">1</span> &lt;&lt; i), res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, d;</span><br><span class="line">    n = read(), t = read(), m = read();</span><br><span class="line">    build(root = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ch),</span><br><span class="line">        left = read(), right = read();</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) swap(left, right);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">            d = read();</span><br><span class="line">            change(root, left, right, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count(query(root, left, right)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2 4</span></span><br><span class="line"><span class="comment">C 1 1 2</span></span><br><span class="line"><span class="comment">P 1 2</span></span><br><span class="line"><span class="comment">C 2 2 2</span></span><br><span class="line"><span class="comment">P 1 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面向量练习小结</title>
      <link href="/2019/03/02/%E5%B9%B3%E9%9D%A2%E5%90%91%E9%87%8F%E7%BB%83%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/02/%E5%B9%B3%E9%9D%A2%E5%90%91%E9%87%8F%E7%BB%83%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。</p><p><strong>这篇文章不适合向量零基础的同学看。</strong></p><a id="more"></a><h1 id="坐标表示法"><a href="#坐标表示法" class="headerlink" title="坐标表示法"></a><strong>坐标表示法</strong></h1><p>对于向量，我们能不能制定一种与坐标类似，与有序数对一一对应的方法呢？</p><p>这就是向量的“万能方法”——坐标表示法。</p><p>对于向量$\overrightarrow{AB}$，我们令$A$为坐标的原点，以两个夹角不为零的向量为坐标轴，不妨设$\overrightarrow{p}$为$x$轴，$\overrightarrow{q}$为$y$轴。我们可以将$\overrightarrow{AB}$定义为$(x,\ y)$，其中$x,y \in \mathbb{R}$。此时满足$\overrightarrow{AB} = x \overrightarrow{p} + y \overrightarrow{q}$。</p><p>通常，为了方便起见，我们就将$\overrightarrow{p}$和$\overrightarrow{q}$设为$x$轴和$y$轴正半轴方向上的的单位向量。</p><p>这样，题目中复杂的条件就可以通过下面的公式化繁而简了。</p><h1 id="一些有用的公式"><a href="#一些有用的公式" class="headerlink" title="一些有用的公式"></a><strong>一些有用的公式</strong></h1><blockquote><p>在以下公式中，默认$\overrightarrow{A} = (x_1,y_1),\ \overrightarrow{B} = (x_2,y_2)$</p></blockquote><p>$\overrightarrow{A} + \overrightarrow{B} = (x_1 + y_1, x_2 + y_2)$</p><p>$\overrightarrow{A} - \overrightarrow{B} = (x_1 - y_1, x_2 - y_2)$</p><p>$\overrightarrow{A} \cdot \overrightarrow{B} = x_1x_2+y_1y_2$</p><p>由此我们可以推出</p><p>$\cos&lt;\overrightarrow{A}, \overrightarrow{B}&gt; = \frac{x_1x_2 + y_1y_2}{\sqrt{x_1^2 + y_1^2} \cdot \sqrt{x_2^2 + y_2^2}}$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公式 </tag>
            
            <tag> 平面向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「NOIP2011」Car的旅行路线</title>
      <link href="/2019/03/02/%5BNOIP2011%5D%20Car%E7%9A%84%E6%97%85%E8%A1%8C%E8%B7%AF%E7%BA%BF/"/>
      <url>/2019/03/02/%5BNOIP2011%5D%20Car%E7%9A%84%E6%97%85%E8%A1%8C%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。</p><p>求$A$点到$B$点的最小费用。</p><p>对于$100$%的数据，数据组数$\leq10$，矩形个数$\leq100$。</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1027" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p><del>打死我也不告诉你我Floyd模板打错了</del></p><p>通过$floyd$处理出任意两点（注意不是矩形）之间的最小费用即可。</p><p>但这道题细节还是不少的——</p><ul><li><p>只给你矩形的三个顶点</p><p>  先通过勾股定理逆定理来求出哪个是直角，然后第四个点的坐标就出来了。</p></li><li><p>矩形可以是歪的，即它的边不一定平行于坐标轴。</p></li><li>多组数据注意初始化。</li><li>飞机和汽车费用不一样，需要分别计算。</li><li>最后只输出1位小数</li></ul><p>$Hint$：两点间距离公式 $dis\ =\ \sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2}$</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="keyword">int</span> _, S, t, A, B, tot;</span><br><span class="line"><span class="keyword">double</span> w[MAXN][MAXN], ans; <span class="comment">// w 是两点间的最小费用</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">sq</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">double</span>)x * x;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, t, x, y; <span class="comment">// id 城市编号，t 列车费用</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT</span><span class="params">(<span class="keyword">int</span> _id, <span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">int</span> _x, <span class="keyword">int</span> _y)</span> </span>&#123;</span><br><span class="line">        id = _id, t = <span class="keyword">_t</span>, x = _x, y = _y;</span><br><span class="line">    &#125; <span class="comment">// 赋值函数（更简单的忘了怎么写了 QwQ</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dis</span><span class="params">(point &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(sq(x - a.x) + sq(y - a.y));</span><br><span class="line">    &#125; <span class="comment">// 两点间距离</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rct</span><span class="params">(point &amp;a, point &amp;b, point &amp;c)</span> </span>&#123;</span><br><span class="line">        id = a.id, t = a.t;</span><br><span class="line">        <span class="keyword">int</span> P = sq(a.x - b.x) + sq(a.y - b.y),</span><br><span class="line">            Q = sq(b.x - c.x) + sq(b.y - c.y),</span><br><span class="line">            R = sq(c.x - a.x) + sq(c.y - a.y);</span><br><span class="line">        <span class="keyword">if</span>(P + Q == R)</span><br><span class="line">            x = a.x + c.x - b.x,</span><br><span class="line">            y = a.y + c.y - b.y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(P + R == Q)</span><br><span class="line">            x = b.x + c.x - a.x,</span><br><span class="line">            y = b.y + c.y - a.y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = a.x + b.x - c.x,</span><br><span class="line">            y = a.y + b.y - c.y;</span><br><span class="line">    &#125; <span class="comment">// 处理第四个点的坐标</span></span><br><span class="line">&#125; p[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> point P, Q;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> c, d;</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            P = p[i], Q = p[j],</span><br><span class="line">            d = P.dis(Q), c = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">if</span>(P.id == Q.id)</span><br><span class="line">                c = d * P.t;</span><br><span class="line">            <span class="keyword">else</span> c = d * (<span class="keyword">double</span>)t;</span><br><span class="line">            w[i][j] = w[j][i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="comment">// 处理距离，注意初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2, x3, y3, <span class="keyword">_t</span>;</span><br><span class="line">    point p1, p2, p3, p4;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123; <span class="comment">// 多组数据</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;S, &amp;t, &amp;A, &amp;B);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d%d"</span>,</span><br><span class="line">            &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;<span class="keyword">_t</span>);</span><br><span class="line">            p1.INIT(i, <span class="keyword">_t</span>, x1, y1), p2.INIT(i, <span class="keyword">_t</span>, x2, y2),</span><br><span class="line">            p3.INIT(i, <span class="keyword">_t</span>, x3, y3), p4.rct(p1, p2, p3);</span><br><span class="line">            p[++tot] = p1, p[++tot] = p2,</span><br><span class="line">            p[++tot] = p3, p[++tot] = p4;</span><br><span class="line">        &#125; prework();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; k++) <span class="comment">// 一开始把 k 套到最里面了。。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">                    w[i][j] = min(w[i][j], w[i][k] + w[k][j]);</span><br><span class="line">        ans = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">                <span class="keyword">if</span>(p[i].id == A &amp;&amp; p[j].id == B)</span><br><span class="line">                    ans = min(ans, w[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, ans); <span class="comment">// 只保留1位！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3 10 1 3</span></span><br><span class="line"><span class="comment">1 1 1 3 3 1 30</span></span><br><span class="line"><span class="comment">2 5 7 4 5 2 1</span></span><br><span class="line"><span class="comment">8 6 8 8 11 6 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO15DEC」最大流</title>
      <link href="/2019/02/23/%5BUSACO15DEC%5D%20%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/2019/02/23/%5BUSACO15DEC%5D%20%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给你一颗$n$个结点的树。</p><p>有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。</p><p>最后输出最大的点权值。</p><p>对于$100$%的的数据，满足$2 \leq n \leq 50000,\ 1 \leq k \leq 100000$</p><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P3128" target="_blank" rel="noopener">题目链接戳这里</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>树链剖分模板题！<del><a href="https://tle666.github.io/2019/02/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3/">没学过的戳这里</a></del></p><p>对于每次操作$u$，$v$，我们只需要执行一次树链剖分里最基本的修改操作：路径修改即可。</p><p>最后你再用基本操作$query$求一次区间点权最大值就A了啊！</p><p><del>详见代码</del></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n, k, tot, wson[MAXN], dep[MAXN], fa[MAXN], dfn[MAXN], pre[MAXN], size[MAXN], top[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="comment">// 存图</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; epool[MAXN &lt;&lt; <span class="number">1</span>], *h[MAXN], *ecnt = epool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="comment">// 存树</span></span><br><span class="line">    <span class="keyword">int</span> left, right, Max, tag;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; tag += x, Max += x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; Max = max(ls-&gt;Max, rs-&gt;Max);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ls) ls-&gt;seta(tag);</span><br><span class="line">            <span class="keyword">if</span>(rs) rs-&gt;seta(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">3</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 加边</span></span><br><span class="line">    edge *p = ++ecnt, *q = ++ecnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">    q-&gt;v = u, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>((v = p-&gt;v) != f) &#123;</span><br><span class="line">            fa[v] = u,</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">            size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span>(size[wson[u]] &lt; size[v]) wson[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; top[u] = tp;</span><br><span class="line">    dfn[u] = ++tot, pre[tot] = u;</span><br><span class="line">    <span class="keyword">if</span>(wson[u]) dfs2(wson[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>((v = p-&gt;v) != fa[u] &amp;&amp; v != wson[u])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">        r-&gt;seta(<span class="number">1</span>); <span class="keyword">return</span> ;</span><br><span class="line">    &#125; r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right),</span><br><span class="line">         change(r-&gt;rs, r-&gt;rs-&gt;left, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// 区间求 max</span></span><br><span class="line">    r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r-&gt;Max;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> max(query(r-&gt;ls, left, r-&gt;ls-&gt;right),</span><br><span class="line">                    query(r-&gt;rs, r-&gt;rs-&gt;left, right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qchange</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 路径点权加一</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) swap(u, v);</span><br><span class="line">        change(root, dfn[top[v]], dfn[v]);</span><br><span class="line">        v = fa[top[v]];</span><br><span class="line">    &#125; left = dfn[u], right = dfn[v];</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) swap(left, right);</span><br><span class="line">    change(root, left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addedge(u, v);</span><br><span class="line">    &#125; dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    build(root = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        Qchange(u, v);</span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(root, <span class="number">1</span>, n)); <span class="comment">// 最后输出最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学公式</title>
      <link href="/2019/02/19/%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/02/19/%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>这里有一些重要的初高中数学公式，可供参考。</p><a id="more"></a><h2 id="恒等变形"><a href="#恒等变形" class="headerlink" title="恒等变形"></a>恒等变形</h2><p>$a^3 + b^3 = (a + b)(a^2 - ab + b)$</p><p>$a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$</p><p>$2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \geqslant 0$</p><p>$(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$</p><p>$(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$</p><p>$(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$</p><p>$(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$</p><p>$(a_1^2 + a_2^2 + a_3^2 + \cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \cdots + b_n^2) \geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \cdots + a_nb_n)^2$ —— $Cauchy$不等式</p><p>$(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$</p><h2 id="几何定理"><a href="#几何定理" class="headerlink" title="几何定理"></a>几何定理</h2><h3 id="斯特瓦尔特定理"><a href="#斯特瓦尔特定理" class="headerlink" title="斯特瓦尔特定理"></a>斯特瓦尔特定理</h3><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=904237c40cfa513d45a7648c5c043e9e/9825bc315c6034a85f121a99cf13495409237631.jpg" alt="斯特瓦尔特"></p><p>$BD \cdot AC^2 + DC \cdot AB^2 = BC \cdot AD^2 + BD \cdot DC \cdot BC$</p><h4 id="推论：中线长公式"><a href="#推论：中线长公式" class="headerlink" title="推论：中线长公式"></a>推论：中线长公式</h4><p>$AD = \frac{1}{2} \sqrt{2(AB^2 + AC^2) - BC^2}$</p><h3 id="欧拉线"><a href="#欧拉线" class="headerlink" title="欧拉线"></a>欧拉线</h3><p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=03bba6fdda43ad4bb2234e92e36b31ca/6159252dd42a2834ee136d5350b5c9ea15cebf35.jpg" alt></p><p>$\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。</p><h3 id="九点圆"><a href="#九点圆" class="headerlink" title="九点圆"></a>九点圆</h3><p><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=897ee43bf9dcd100d991f07313e22c75/622762d0f703918f125573fc503d269759eec404.jpg" alt="九点圆"></p><p>在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。</p><h3 id="西姆松线"><a href="#西姆松线" class="headerlink" title="西姆松线"></a>西姆松线</h3><p><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=594aed747d3e6709aa0d4dad5aaef458/0b7b02087bf40ad19c15d6b0552c11dfa8eccef4.jpg" alt="西姆松线"></p><p>过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。</p><h3 id="史坦纳定理"><a href="#史坦纳定理" class="headerlink" title="史坦纳定理"></a>史坦纳定理</h3><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180208/0230f38f899b448b9369832637f73f95.png" alt="史坦纳定理"></p><p>$H$ 为$\triangle ABC$ 垂心，$D$为$\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\triangle ABC$的西姆松线通过线段$DH$的中点。</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>$\cot\alpha = \frac{1}{\tan\alpha} \qquad \sec\alpha = \frac{1}{\cos\alpha} \qquad \csc\alpha = \frac{1}{\sin\alpha}$</p><h3 id="诱导公式"><a href="#诱导公式" class="headerlink" title="诱导公式"></a>诱导公式</h3><p>$\sin ( \pi + \alpha) =- \sin \alpha \qquad \cos(\pi + \alpha) = -\cos \alpha \qquad \tan (\pi + \alpha) = \tan \alpha$</p><p>$\sin (-\alpha) = -\sin\alpha \qquad \cos (-\alpha) = \cos\alpha \qquad \tan(-\alpha) = -\tan\alpha$</p><p>$\sin (\pi - \alpha) = \sin \alpha \qquad \cos (\pi - \alpha) = -\cos\alpha \qquad \tan(\pi - \alpha) = -\tan\alpha$</p><p>$\sin(2\pi - \alpha) = -\sin\alpha \qquad \cos(2\pi - \alpha) = \cos\alpha \qquad \tan(2\pi - \alpha) = -\tan\alpha$</p><p>$\sin (\frac{\pi}{2} + \alpha) = \cos\alpha \qquad \sin(\frac{\pi}{2} - \alpha) = \cos\alpha$</p><p>$\cos(\frac{\pi}{2} + \alpha) = -\sin\alpha \qquad \cos(\frac{\pi}{2} - \alpha) = \sin\alpha$</p><p>$\tan(\frac{\pi}{2} + \alpha) = -\cot\alpha \qquad \tan(\frac{\pi}{2} - \alpha) = \cot\alpha$</p><p>$\tan(\frac{\pi}{4} + \alpha) = \frac{1 + \tan\alpha}{1 - \tan\alpha}$</p><p><strong>推论</strong></p><p>$(\sin\frac{\alpha}{2} \pm \cos\frac{\alpha}{2})^2 = 1 \pm \sin\alpha$</p><h3 id="两角和（差）公式"><a href="#两角和（差）公式" class="headerlink" title="两角和（差）公式"></a>两角和（差）公式</h3><p>$\sin(\alpha \pm \beta) = \sin\alpha\cos\beta \pm \cos\alpha\sin\beta$</p><p>$\cos(\alpha \pm \beta) = \cos\alpha\cos\beta \mp \sin\alpha\sin\beta$</p><p>$\tan(\alpha \pm \beta) = \frac{\tan\alpha \pm \tan\beta}{1 \mp \tan\alpha\tan\beta}$</p><h3 id="二倍角公式"><a href="#二倍角公式" class="headerlink" title="二倍角公式"></a>二倍角公式</h3><p>$\sin 2\alpha = 2\sin\alpha\cos\alpha$</p><p>$\cos2\alpha = 2\cos^2\alpha - 1 = 1 - 2\sin^2\alpha = \frac{1-\tan^2\alpha}{1+\tan^2\alpha}$</p><p>$\tan2\alpha = \frac{2\tan\alpha}{1-\tan^2\alpha}$</p><h3 id="三倍角公式"><a href="#三倍角公式" class="headerlink" title="三倍角公式"></a>三倍角公式</h3><p>$\sin(3\alpha) = 3\sin\alpha - 4\sin^3\alpha \qquad \cos(3\alpha) = 4\cos ^ 3\alpha - 3\cos\alpha$</p><h3 id="降幂公式"><a href="#降幂公式" class="headerlink" title="降幂公式"></a>降幂公式</h3><p>$\sin^2\alpha = \frac{1 - \cos2\alpha}{2} \qquad \cos^2\alpha = \frac{1 + \cos2\alpha}{2} \qquad \tan^2\alpha = \frac{1 - \cos2\alpha}{1 + \cos2\alpha}$</p><h3 id="辅助角公式"><a href="#辅助角公式" class="headerlink" title="辅助角公式"></a>辅助角公式</h3><p>$a\sin x + b\cos x = \sqrt{a^2 + b^2}(\frac{a\sin x}{\sqrt{a^2 + b^2}} + \frac{b\cos x}{\sqrt{a^2 + b^2}})$ 或</p><p>$a\sin x + b\cos x = \sqrt{a^2 + b^2}\sin(x + \varphi)$，其中 $\sin\varphi = \frac{b}{\sqrt{a ^ 2 + b ^ 2}},\ \cos\varphi = \frac{a}{\sqrt{a^2 + b^2}}$</p><h3 id="万能公式"><a href="#万能公式" class="headerlink" title="万能公式"></a>万能公式</h3><p>$\sin\alpha = \frac{2\tan\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$</p><p>$\cos\alpha = \frac{1 - \tan^2\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$</p><p>$\tan\alpha = \frac{2\tan\frac{\alpha}{2}}{1 - \tan^2\frac{\alpha}{2}}$</p><h3 id="和差化积"><a href="#和差化积" class="headerlink" title="和差化积"></a>和差化积</h3><p>$\sin\alpha \pm \sin\beta = 2\sin\frac{\alpha \pm \beta}{2}\cos\frac{\alpha \mp \beta}{2}$</p><p>$\cos\alpha + \cos\beta = 2\cos\frac{\alpha + \beta}{2}\cos\frac{\alpha - \beta}{2}$</p><p>$\cos\alpha - \cos\beta = -2\sin\frac{\alpha + \beta}{2}\sin\frac{\alpha - \beta}{2}$</p><p>$\tan\alpha \pm \tan\beta = \frac{\sin(\alpha \pm \beta)}{\cos\alpha\cos\beta}$</p><h3 id="积化和差"><a href="#积化和差" class="headerlink" title="积化和差"></a>积化和差</h3><p>$\sin\alpha\cos\beta = \frac{1}{2}(\sin(\alpha + \beta) + \sin(\alpha - \beta))$</p><p>$\cos\alpha\sin\beta = \frac{1}{2}(\sin(\alpha + \beta) - \sin(\alpha - \beta))$</p><p>$\cos\alpha\cos\beta = \frac{1}{2}(\cos(\alpha +\beta) + \cos(\alpha - \beta))$</p><p>$\sin\alpha\sin\beta = -\frac{1}{2}(\cos(\alpha + \beta) - \cos(\alpha - \beta))$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公式 </tag>
            
            <tag> 三角函数 </tag>
            
            <tag> 代数 </tag>
            
            <tag> 几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分详解</title>
      <link href="/2019/02/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>当我们想要同时完成</p><ul><li>求树上$u$到$v$的权值和</li><li>将树上$u$到$v$的权值都加$d$</li></ul><p>这两种操作时，会怎么做呢？</p><p>相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。</p><p>树链剖分便由此而来了。</p><a id="more"></a><p>前置技能：<a href="https://oi-wiki.org/ds/segment/" target="_blank" rel="noopener">线段树</a>（重要） &amp; 倍增求 $LCA$（不必须）</p><h1 id="Definition-amp-Steps"><a href="#Definition-amp-Steps" class="headerlink" title="Definition &amp; Steps"></a><strong>Definition &amp; Steps</strong></h1><blockquote><p> 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。</p></blockquote><p>首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念：</p><ul><li>$size_i$：以$i$为根的子树中结点个数</li><li>$dfn_i$：$i$结点的$dfs$序，即其新编号</li><li>$pre_i$：$dfn$的反函数，若$dfn_i\ =\ j$，则$pre_j\ =\ i$，即$dfn_{pre_i}\ =\ 1$。</li><li>$fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号）</li><li>$dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\ =\ 1$</li><li>$w_i$：$i$结点的权值</li><li>重儿子：一个结点所有子结点中$size$最大的子节点，用$wson[i]$表示</li><li>轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点</li><li>重边：一个结点和它的重儿子的连边</li><li>轻边：一个节点和它的轻儿子的连边</li><li>重链：由多条重边首尾顺次连接而成的链（路径）</li><li>轻链：有多条轻边首尾顺次连接而成的链（路径）</li><li>$top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上）</li></ul><p>上一张百度百科的图：</p><p><img src="https://s2.ax1x.com/2019/02/02/k8LSfK.jpg" alt="图片没了吗？可以到百度百科上看"></p><p>如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可；</p><p>同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$</p><p>递归伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> <span class="comment">// u 当前结点，f 是 u 的父亲结点</span></span></span><br><span class="line">    size[u] = 1</span><br><span class="line">    <span class="keyword">for</span> each v that connects to u : <span class="comment">// u 的子结点</span></span><br><span class="line">    <span class="keyword">if</span>(v != f) <span class="comment">// v 不是 u 的父亲</span></span><br><span class="line">            fa[v] = u <span class="comment">// 说明 v 是 u 的子结点</span></span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span> <span class="comment">// 深度维护</span></span><br><span class="line">            dfs(v, u) <span class="comment">// 继续递归</span></span><br><span class="line">            size[u] += size[v] <span class="comment">// 将子树的 size 加到这棵树的 size 上</span></span><br><span class="line">            <span class="keyword">if</span>(size[wson[u]] &lt; size[v]) wson[u] = v <span class="comment">// 更新重儿子</span></span><br></pre></td></tr></table></figure><p>可以手动模拟一下</p><p>这样，我们就求出了每个结点的重儿子 $wson$ ；</p><p>特别地，每个叶子结点的重儿子都为 $0$</p><p>每个标红点的结点都是一条重链的链首（$top$），</p><p>而加粗的边则是重链。</p><p>比如，$1 \rightarrow 4 \rightarrow 9 \rightarrow 13 \rightarrow 14$ 就是一条重链，而 $2 \rightarrow 6 \rightarrow 11$ 也是另一条重链；</p><p>另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子，</p><p>例如 $top[3]\ =\ 3$；</p><p>回顾一下，还有哪些信息没有维护呢？</p><p>$dfn,\ pre,\ top$ </p><p>其实，这三个只需要另一个递归函数就足够啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> <span class="comment">// u 是当前结点，tp 是 u 所在重链的链首</span></span></span><br><span class="line">    top[u] = tp</span><br><span class="line">    dfn[u] = ++tot <span class="comment">// tot 是时间戳</span></span><br><span class="line">    pre[tot] = u <span class="comment">// pre 是 dfn 的反函数</span></span><br><span class="line">    <span class="keyword">if</span>(wson[u]) dfs2(wson[u], tp); <span class="comment">// 只要 u 有重儿子，那就可以继续下去</span></span><br><span class="line">    <span class="keyword">for</span> each v that connects to u : </span><br><span class="line"><span class="keyword">if</span>(v != fa[u] &amp;&amp; v != wson[u]) <span class="comment">// v 是 u 的轻儿子</span></span><br><span class="line">            dfs2(v, v); <span class="comment">// 轻儿子是重链的链首</span></span><br></pre></td></tr></table></figure><p>图中边上的数字就是 $dfs2$ 递归地顺序，不明白的可以参考一下。</p><p>检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？</p><p>$Answer:\ 10,\ 8$。</p><p><strong>好了，树链剖分阶段到此结束。</strong></p><p>将这棵树剖分成了许多链，现在就可以用线段树维护了~</p><blockquote><p>写上了一段带修改查询的线段树模板。。。</p></blockquote><p>现在轮到处理问题的阶段了。</p><p>为了便于理解，我们就先实现两个最基础的操作吧：</p><p>路径点权求和、路径点权修改</p><p>大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。</p><p>举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。）</p><p><img src="https://s2.ax1x.com/2019/02/02/k8LSfK.jpg" alt="图片没了吗？可以到百度百科上看"></p><p>为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。</p><p>这个和倍增求 $LCA$ 有点像。</p><p>先找到 $dep$ 更深的结点，$11$（$dep[11]\ &gt;\ dep[9]$）</p><p>将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和</p><p>我们可以用事先维护好的 $dfn$ 来帮助</p><p>由于 $top[11]\ =\ 2$，所以我们在求 $2=&gt;11$ 的和</p><p>我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！</p><p>线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$</p><p><code>res += query(root, dfn[top[11]], dfn[11])</code></p><p>这是，操作变成了求 $res\ +\ 9 \Rightarrow11$ 的路径点权和。 </p><p>所以我们将 $11$ 变为 $fa[top[11]]\ =\ 1$</p><p>这是，我们发现 $1$ 和 $9$ 共链了。</p><p>所以像刚才一样，</p><p><code>res += query(root, dfn[1], dfn[9])</code></p><p>即可！</p><p>将上面的步骤转化成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qsum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123; <span class="comment">// 只要不共链</span></span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) swap(u, v); <span class="comment">// 每次都要让 top 深一些的往上跳</span></span><br><span class="line">        res += query(root, dfn[top[v]], dfn[v]);</span><br><span class="line">        v = fa[top[v]];</span><br><span class="line">    &#125; left = dfn[u], right = dfn[v];</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) swap(left, right); <span class="comment">// 注意大小关系！</span></span><br><span class="line">    res += query(root, left, right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧！</p><p>修改操作类似，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vois <span class="title">Qchange</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">// u 到 v 的路径上点权加 d</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) swap(u, v);</span><br><span class="line">        change(root, dfn[top[v]], dfn[v], d);</span><br><span class="line">        v = fa[top[v]];</span><br><span class="line">    &#125; left = dfn[u], right = dfn[v];</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) swap(left, right);</span><br><span class="line">    change(root, left, right, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="comment">// 存图</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    edge *next;</span><br><span class="line">&#125; epool[MAXN &lt;&lt; <span class="number">1</span>], *h[MAXN], *ecnt = epool;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span> <span class="comment">// 存线段树</span></span><br><span class="line">    <span class="keyword">int</span> left, right, s, tag;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">seta</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; tag += x, s += (right - left + <span class="number">1</span>) * x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123; s = ls-&gt;s + rs-&gt;s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tag) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ls) ls-&gt;seta(tag);</span><br><span class="line">            <span class="keyword">if</span>(rs) rs-&gt;seta(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; pool[MAXN &lt;&lt; <span class="number">3</span>], *root, *cnt = pool;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 加边</span></span><br><span class="line">    edge *p = ++ecnt, *q = ++ecnt;</span><br><span class="line">    p-&gt;v = v, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">    q-&gt;v = u, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>((v = p-&gt;v) != f) &#123;</span><br><span class="line">            fa[v] = u,</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            dfs1(v, u);</span><br><span class="line">            size[u] += size[v];</span><br><span class="line">            <span class="keyword">if</span>(size[v] &gt; size[wson[u]]) wson[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v; top[u] = tp;</span><br><span class="line">    dfn[u] = ++tot, pre[tot] = u;</span><br><span class="line">    <span class="keyword">if</span>(wson[u]) dfs2(wson[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line">        <span class="keyword">if</span>((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u])</span><br><span class="line">            dfs2(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// 线段树模板</span></span><br><span class="line">    r-&gt;left = left, r-&gt;right = right;</span><br><span class="line">    <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">        r-&gt;s = w[pre[left]];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    node *ls = ++cnt, *rs = ++cnt;</span><br><span class="line">    r-&gt;ls = ls, r-&gt;rs = rs;</span><br><span class="line">    build(ls, left, mid), build(rs, mid + <span class="number">1</span>, right);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">// 线段树模板</span></span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123;</span><br><span class="line">        r-&gt;seta(d); <span class="keyword">return</span> ;</span><br><span class="line">    &#125; r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d);</span><br><span class="line">    <span class="keyword">else</span> change(r-&gt;ls, left, r-&gt;ls-&gt;right, d),</span><br><span class="line">         change(r-&gt;rs, r-&gt;rs-&gt;left, right, d);</span><br><span class="line">    r-&gt;upd();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(node *r, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123; <span class="comment">// 线段树模板</span></span><br><span class="line">    r-&gt;push();</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;left == left &amp;&amp; r-&gt;right == right) <span class="keyword">return</span> r-&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;ls-&gt;right &gt;= right) <span class="keyword">return</span> query(r-&gt;ls, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r-&gt;rs-&gt;left &lt;= left) <span class="keyword">return</span> query(r-&gt;rs, left, right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(r-&gt;ls, left, r-&gt;ls-&gt;right) +</span><br><span class="line">                query(r-&gt;rs, r-&gt;rs-&gt;left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qsum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) swap(u, v);</span><br><span class="line">        res += query(root, dfn[top[v]], dfn[v]);</span><br><span class="line">        v = fa[top[v]];</span><br><span class="line">    &#125; left = dfn[u], right = dfn[v];</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) swap(left, right);</span><br><span class="line">    res += query(root, left, right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Qchange</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) swap(u, v);</span><br><span class="line">        change(root, dfn[top[v]], dfn[v], d);</span><br><span class="line">        v = fa[top[v]];</span><br><span class="line">    &#125; left = dfn[u], right = dfn[v];</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) swap(left, right);</span><br><span class="line">    change(root, left, right, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, u, v, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]); <span class="comment">// 读入点权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 读图</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        addedge(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 这步不能忘，否则 dfs1 没用！</span></span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    build(root = cnt, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123; <span class="comment">// 操作</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;u, &amp;v);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Qsum(u, v));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">            Qchange(u, v, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a><strong>Examples</strong></h1><p><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">【模板】 树链剖分</a></p><p><a href="https://www.luogu.org/problemnew/show/P2486" target="_blank" rel="noopener">「SDOI2011」 染色</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「BZOJ5165」树上倍增</title>
      <link href="/2019/02/02/%5BBZOJ5165%5D%20%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
      <url>/2019/02/02/%5BBZOJ5165%5D%20%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>维护一棵支持插入节点与求$k$个节点的$LCA$的树。</p><p>总节点数 $n\leq 3 \times 10^6$  ，操作次数 $m \leq 10^3$，$k \leq 10^3$</p><a id="more"></a><p>题目链接： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5165" target="_blank" rel="noopener">BZOJ P5165</a></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>思路题目名称已经给了好嘛。。。</p><p>就是倍增啊。。</p><p>其实这题的难点不是在于思路想法，而是在于<strong>卡空间</strong>！</p><h2 id="操作1"><a href="#操作1" class="headerlink" title="操作1"></a>操作1</h2><blockquote><p>$A \ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1$。</p></blockquote><p>维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$</p><p>具体的维护方法见下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = <span class="number">1</span></span><br><span class="line">st[i][j] = k 代表 编号为i的节点向上跳<span class="number">2</span> ^ j个点到编号为k的节点</span><br><span class="line">因此st[i][<span class="number">0</span>]即为节点i的父亲</span><br><span class="line"></span><br><span class="line">dep[++n] = dep[x] + <span class="number">1</span>; <span class="comment">// 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 2 ^ 21 &gt; 3e6，因此只需维护到20即可</span></span><br><span class="line">    st[n][i] = st[st[n][i - <span class="number">1</span>]][i - <span class="number">1</span>]; <span class="comment">// 倍增数组标准维护语句</span></span><br></pre></td></tr></table></figure><h2 id="操作2"><a href="#操作2" class="headerlink" title="操作2"></a>操作2</h2><blockquote><p>$Q \ k\  p1\  p2\ p3\ …$ 查询$p1,\ p2,\ p3\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。</p></blockquote><p>这个我想没什么好讲的吧。</p><p>就是依次求$LCA$就行啦。<del>如果不懂详见代码</del></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3000003</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>, m, dep[MAXN], st[MAXN][<span class="number">21</span>], P;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">2</span>]; <span class="comment">// 读入操作用，char可能会咕掉</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 新建节点操作，上文讲过</span></span><br><span class="line">    dep[++n] = dep[x] + <span class="number">1</span>, st[n][<span class="number">0</span>] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        st[n][i] = st[st[n][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// 基本的LCA操作，不解释</span></span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(dep[v] - dep[u] &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(st[u][i] != st[v][i])</span><br><span class="line">            u = st[u][i],</span><br><span class="line">            v = st[v][i];</span><br><span class="line">    <span class="keyword">return</span> st[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, lca; dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 将root的深度设为1</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, ch, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">0</span>] == <span class="string">'A'</span>) insert(k);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;lca); <span class="comment">//依次求LCA</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;P), lca = LCA(lca, P);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> LCA </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速读入详解</title>
      <link href="/2019/01/27/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/01/27/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板</p><a id="more"></a><p>当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！</p><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><blockquote><p>程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。</p><p>常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。</p></blockquote><h2 id="快速读入"><a href="#快速读入" class="headerlink" title="快速读入"></a>快速读入</h2><blockquote><p>简称快读，是信息学竞赛中卡常数最为常见的方法。</p></blockquote><p>一般来讲，大多数题目的出题人都不会到这种<del>丧心病狂的</del>地步。</p><p>不过，以防万一肯定没坏处啊~ <del>反正代码很简单啦</del></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>先上代码！讲解在后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125; <span class="comment">// 这是能判负数的C++快读模板</span></span><br></pre></td></tr></table></figure><p>在代码中，只需将<code>cin &gt;&gt; n</code>或<code>scanf(&quot;%d&quot;, &amp;n)</code>改成<code>n  = read()</code>即可！</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>为什么$cin$慢？因为它需要和$stdio$保持同步，也就是<code>sync_with_stdio</code>。</p><p>为什么$scanf$慢？原因有点复杂。</p><ol><li>它可以接受多种形式的输入（数字、字符串等等），因此需要判断。</li><li>它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。</li></ol><p>其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。</p><p>在实际的文件中，会有许多不必要的隐藏字符，比如换行符<code>\n</code>等。</p><p>因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。</p><p>于是，我们要特判！<code>if(ch == ‘-’) w = -1;</code>这就是判负号的语句。</p><p>下一个循环中，就是<a href="https://wenku.baidu.com/view/7fdcf9727dd184254b35eefdc8d376eeafaa1716.html" target="_blank" rel="noopener">位值原理</a>。数$\overline{abcd} = 10 \times (10 \times (10 \times a + b) + c) + d$，读者自证不难。</p><p>最后返回$n = sgn(n) \times |n|$，其中$sgn(x)$为$x$的符号。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分</title>
      <link href="/2019/01/27/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/"/>
      <url>/2019/01/27/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p> 二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。</p><a id="more"></a><ul><li>大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。</li></ul><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li>首先，令$L = -1$，$R = 1$。</li><li>然后进行如下操作，直到$f(mid) = 0$为止。</li></ul><ol><li>算出$L$和$R$的代数平均数$mid$，且$mid \in \mathbb{Z}$，即整数$mid = \lfloor \dfrac{a + b}{2} \rfloor$。</li><li><ul><li>若$f(mid) = 0$，找到答案<ul><li>若$f(mid) &gt; 0$，让$b = mid$，缩小区间</li><li>若$f(mid) &lt; 0$，让$a = mid$，缩小区间</li></ul></li></ul></li><li>回到步骤$1$。<br> 如果你没有明白的话，那就看图吧。。。</li></ol><p><img src="https://s1.ax1x.com/2018/12/20/FDTt1S.png" alt="函数求零点"></p><ol><li>$L = 0, R = 4, mid = \lfloor \dfrac{0 + 4}{2} \rfloor = 2$</li><li>$f(mid) = f(2) = 3 &gt; 0$</li><li>因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。</li><li>缩小范围至$[0,2]$，$R = 2$。</li><li>此时$mid = \lfloor \dfrac{0 + 2}{2} \rfloor= 1$</li><li>$f(mid) = f(1) = 0$！</li><li>找到答案$0$。</li></ol><h3 id="例题回顾（条件）"><a href="#例题回顾（条件）" class="headerlink" title="例题回顾（条件）"></a>例题回顾（条件）</h3><ul><li>在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢?</li><li>显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。</li></ul><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ul><li>对于区间$[a, b]$上连续不断且$f(a) \times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。</li></ul><p>在信息学中，二分法最常见的体现就是<strong>二分答案</strong>。</p><p>在这篇随笔中，我主要讲解的就是二分答案。</p><h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><ul><li>二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>猜数字</strong></p><ul><li><p>事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。</p></li><li><p>朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。</p></li><li>二分答案：<br>  $L = 1, R = 100, mid = \lfloor \dfrac{L + R}{2} \rfloor = 50$，设答案为$ans$。<br>  只要$L \leqslant R$，尝试$mid$，<script type="math/tex; mode=display">\left\{  \begin{aligned}  & 若mid > ans，则R = mid； \\  & 若mid < ans，则L = mid + 1； \\  & 若mid = ans，猜对了。  \end{aligned}  \right.</script>  时间复杂度为$O(log n)$。</li></ul><h3 id="为什么二分"><a href="#为什么二分" class="headerlink" title="为什么二分"></a>为什么二分</h3><ul><li>更充分地利用已知条件，大幅度减少遍历范围</li><li>二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销</li></ul><h3 id="在什么情况下可以二分"><a href="#在什么情况下可以二分" class="headerlink" title="在什么情况下可以二分"></a>在什么情况下可以二分</h3><ul><li>答案存在单调性<br>  <img src="https://s2.ax1x.com/2019/01/27/kucZo8.png" alt></li></ul><p>什么意思呢？</p><p>我们不妨假设答案满足条件为$1$，不满足为$0$；</p><p>那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以；</p><p>而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。</p><h3 id="能够解决的问题"><a href="#能够解决的问题" class="headerlink" title="能够解决的问题"></a>能够解决的问题</h3><p>二分答案能够解决哪些问题呢？如下：</p><ul><li>最大的最小值</li><li>最小的最大值</li><li>在满足条件的情况下的最小（大）值</li><li>最接近一个值的值</li><li>…… 在一个单调序列中特殊的点基本上都能二分。</li></ul><h3 id="模板（-C-）"><a href="#模板（-C-）" class="headerlink" title="模板（$C++$）"></a>模板（$C++$）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个求满足条件的最小值的二分模板</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = MAX, mid, ans; <span class="comment">// left为左边界，right为右边界</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">// 只要存在区间</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// 等价于(left + right) / 2，只不过这样写运行速度会稍快一些</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) ans = mid, right = mid - <span class="number">1</span>; <span class="comment">// 如果mid满足条件，那ans（答案）肯定不大于mid</span></span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 如果不能满足条件，ans区间最小值肯定大于mid</span></span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure><p>为什么第五行要加上<code>ans = mid</code>呢？</p><p>原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么）</p><p>这就出现了另一种写法——</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个求满足条件的最小值的二分模板</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = MAX, mid; <span class="comment">// left为左边界，right为右边界</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">// #注意这里改变#</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// 等价于(left + right) / 2，只不过这样写运行速度会稍快一些</span></span><br><span class="line">    <span class="keyword">if</span>(check(mid)) right = mid; <span class="comment">// #注意这里也改变#</span></span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>; <span class="comment">// 如果不能满足条件，ans区间最小值肯定大于mid</span></span><br><span class="line">&#125; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, right); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure><p>不过我个人建议还是写第一种好（更好理解，不容易错）。</p><p>那这两段代码中的$check$函数是干什么的呢？</p><p>其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li><a href="https://www.luogu.org/problemnew/show/P1843" target="_blank" rel="noopener">奶牛晒衣服</a></li><li><a href="https://www.luogu.org/problemnew/show/P1396" target="_blank" rel="noopener">营救</a> （如果不会最小生成树请自动跳过~）</li><li><a href="https://www.luogu.org/problemnew/show/P2678" target="_blank" rel="noopener">$NOIP2015$ 跳石头</a></li><li><p><a href="https://www.luogu.org/problemnew/show/P1439" target="_blank" rel="noopener">【模板】最长公共子序列</a></p></li><li><p>……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「luogu1462」通往奥格瑞玛的道路</title>
      <link href="/2019/01/27/%5Bluogu1462%5D%20%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF/"/>
      <url>/2019/01/27/%5Bluogu1462%5D%20%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>$n$个点$m$条边的带权无向图</p><p>每个点还有一个点权</p><p>求$1-n$的一条最短路径，使得路径长度比$b$短，并且经过的点权之和最大。</p><p>输出这个最大值</p><a id="more"></a><p>看完题面感觉语文要挂科。。。o(╥﹏╥)o</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><p>这题正解 <strong>$SPFA\ +$ 二分</strong></p><p>二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a><strong>Code</strong></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (int)1e9</span></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; <span class="comment">//pre[u]代表u到1的最短路的上一个节点</span></span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span> <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> v, w;</span><br><span class="line">edge *next;</span><br><span class="line">&#125;pool[MAXN &lt;&lt; <span class="number">1</span>], *h[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//建边函数</span></span><br><span class="line">edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt];</span><br><span class="line">p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p;</span><br><span class="line">q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123; <span class="comment">//money代表这次至少收取多少钱，所能够走道的最短路</span></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) dis[i] = INF;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>, Q.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">u = Q.front(), Q.pop(), flag[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(edge *p = h[u]; p; p = p-&gt;next)</span><br><span class="line"><span class="keyword">if</span>(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; <span class="comment">//注意这里要判一下点权（钱）是否满足要求（money）</span></span><br><span class="line">dis[v] = dis[u] + p-&gt;w, pre[v] = u;</span><br><span class="line"><span class="keyword">if</span>(!flag[v])</span><br><span class="line">Q.push(v), flag[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">//最短路回溯函数（递归调用）</span></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">1</span>) <span class="keyword">return</span> f[<span class="number">1</span>]; <span class="comment">//到头</span></span><br><span class="line"><span class="keyword">if</span>(u != <span class="number">1</span> &amp;&amp; !pre[u]) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//走不通了（不连通）</span></span><br><span class="line"><span class="keyword">return</span> max(f[u], path(pre[u])); <span class="comment">//最多一次的钱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//二分函数</span></span><br><span class="line">spfa(x);</span><br><span class="line"><span class="keyword">int</span> tmp = path(n);</span><br><span class="line"><span class="keyword">if</span>(tmp &lt;= x &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; dis[n] &lt;= blood) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w, left = INF, right = <span class="number">0</span>, mid, Max = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;blood);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[i]);</span><br><span class="line">left = min(left, f[i]), Max = right = max(right, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">addedge(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid)) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left &gt; Max) <span class="built_in">puts</span>(<span class="string">"AFK"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, left);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CQOI2009」中位数</title>
      <link href="/2019/01/27/%5BCQOI2009%5D%20%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/01/27/%5BCQOI2009%5D%20%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a><strong>Description</strong></h1><p>给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。</p><p>对于100%的数据，满足$n \leq 100000,\ 1 \leq b \leq n$。</p><a id="more"></a><h5 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.luogu.org/problem/show?pid=1627" target="_blank" rel="noopener">题目传送门</a></h5><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a><strong>Solution</strong></h1><h3 id="标记一遍相对大小，大的标1，小的标-1。只要连续-n-项和为0，就能满足题目条件。"><a href="#标记一遍相对大小，大的标1，小的标-1。只要连续-n-项和为0，就能满足题目条件。" class="headerlink" title="标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。"></a>标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。</h3><h3 id="首先一遍找到中位数位置-pos，放个数组-flag-标记查找中的数与目标中位数的相对大小："><a href="#首先一遍找到中位数位置-pos，放个数组-flag-标记查找中的数与目标中位数的相对大小：" class="headerlink" title="首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小："></a>首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：</h3><p>1 -&gt; 比中位数大</p><p>-1 -&gt; 比中位数小</p><p>0 -&gt; 找到中位数！标记pos</p><p>还是举个实例吧……</p><p>数组：1 1 -1 -1 -1 pos 1 -1 1</p><h3 id="然后从-pos-1-走一遍到1，也就是反过来。再拿一个变量-sum-标记每往左走一个时数组-flag-这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组-f-）那万一-sum-值为负怎么办？数组的下标可没有负的！凉拌-把所有-sum-值统统加上一个足够大的值-“KEY”-。这样下标的值就不会为负啦。"><a href="#然后从-pos-1-走一遍到1，也就是反过来。再拿一个变量-sum-标记每往左走一个时数组-flag-这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组-f-）那万一-sum-值为负怎么办？数组的下标可没有负的！凉拌-把所有-sum-值统统加上一个足够大的值-“KEY”-。这样下标的值就不会为负啦。" class="headerlink" title="然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。"></a>然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。</h3><p>这时的 sum 数组：-1 -2 -3 -2 -1</p><p>这时的 f 数组：f [ -1 + KEY ] = 2 ;  f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ;</p><h3 id="做完这些以后，最后从-pos-1-走一遍到-n-正着走。和上边一样，记录-sum-值。不过这次得多一个步骤——每次要找-pos-左边的对应值。"><a href="#做完这些以后，最后从-pos-1-走一遍到-n-正着走。和上边一样，记录-sum-值。不过这次得多一个步骤——每次要找-pos-左边的对应值。" class="headerlink" title="做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。"></a>做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。</h3><p>从 pos 向右</p><ol><li><p>sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2;</p></li><li><p>sum=0 -&gt; 左边 sum=0 -&gt; 无</p></li><li><p>sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2;</p></li></ol><h3 id="最后输出-ans-即可。"><a href="#最后输出-ans-即可。" class="headerlink" title="最后输出 ans 即可。"></a>最后输出 ans 即可。</h3><p>C++ 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;//头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;//头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//命名空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY 100001<span class="comment">//定义一个足够大的数</span></span></span><br><span class="line"><span class="keyword">int</span> n,b,pos,a[<span class="number">100010</span>],flag[<span class="number">100010</span>],f[<span class="number">200010</span>],s,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;b);<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第一次循环</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b) pos=i;<span class="comment">//就是中位数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;b) flag[i]=<span class="number">1</span>;<span class="comment">//大的标1</span></span><br><span class="line">        <span class="keyword">else</span> flag[i]=<span class="number">-1</span>;<span class="comment">//小的标-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;<span class="comment">//第二次循环</span></span><br><span class="line">        s+=flag[i];<span class="comment">//计算此次sum值</span></span><br><span class="line">        f[s+KEY]++;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) ans++;<span class="comment">//找到满足题意只在 pos 左侧的连续子序列！</span></span><br><span class="line">    &#125;</span><br><span class="line">    s=<span class="number">0</span>;<span class="comment">//为第三次循环的累加做准备</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第三次循环</span></span><br><span class="line">        s+=flag[i];<span class="comment">//计算此次sum值</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) ans++;<span class="comment">//找到满足题意只在 pos 右侧的连续子序列！</span></span><br><span class="line">        ans+=f[-s+KEY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,++ans);<span class="comment">//还少一次只由 pos 自己组成的连续子序列（也满足条件！）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集入门</title>
      <link href="/2018/10/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2018/10/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><strong>并查集</strong>是维护集合相关问题的利器！</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>并查集是个好东西！</strong></p><blockquote><h2 id="它能搞和集合相关的东西……"><a href="#它能搞和集合相关的东西……" class="headerlink" title="它能搞和集合相关的东西……"></a>它能搞和集合相关的东西……</h2><p>常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_</p></blockquote><hr><p>二话不说，先上代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">int</span> n,m,fa[MAXN];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; fa[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v; init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        <span class="keyword">if</span>(Find(u)!=Find(v)) Union(Find(u),Find(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$Find()$函数是路径压缩，<del>不用理解，以后自然会懂</del></p><p>$Union()$是将两个队列合到一起。</p><p>E.G. 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><ul><li><ol><li>将1, 2所在的集合合并</li><li>$Find(1)=2, Find(2)=2, Find(3)=3$</li></ol></li><li><ol><li>将2, 3所在的集合合并</li><li>$Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩</li></ol></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="修复公路"><a href="#修复公路" class="headerlink" title="修复公路"></a><a href="https://www.luogu.org/problemnew/show/P1111" target="_blank" rel="noopener">修复公路</a></h3><p>最小生成树模板题！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="keyword">int</span> n,m,ans,fa[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="comment">//所有的边（图）</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> edge &amp;x)&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;x.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[MAXN*MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> !fa[i]?i:fa[i]=Find(fa[i]);&#125;<span class="comment">//并查集部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; fa[x]=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);</span><br><span class="line">    sort(e+<span class="number">1</span>,e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">if</span>(Find(e[i].u)!=Find(e[i].v))&#123;<span class="comment">//最小生成树 Kruskal</span></span><br><span class="line">            ans=e[i].w;</span><br><span class="line">            Union(Find(e[i].u),Find(e[i].v));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(Find(i)!=Find(j))&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
          <category> 算法讲解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/baidu_verify_U51fhF2DWG.html"/>
      <url>/baidu_verify_U51fhF2DWG.html</url>
      
        <content type="html"><![CDATA[U51fhF2DWG]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>404 Not Found</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[<h1 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="**404 Not Found**"></a><center>**404 Not Found**</center></h1><p><br></p><center>**很抱歉，您访问的页面不存在**</center><center>可能是输入地址有误或该地址已被删除</center><p><br><br><br></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/baidu_verify_o1tQMBIJO5.html"/>
      <url>/baidu_verify_o1tQMBIJO5.html</url>
      
        <content type="html"><![CDATA[o1tQMBIJO5]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>这是一个<strong>弱鸡</strong> <a href="https://www.luogu.org/space/show?uid=54628" target="_blank" rel="noopener">OIer</a> 瞎搞出来的一个博客~</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>我的朋友们</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[<p>欢迎互换友链！</p><p>如需友链请说明备注名、链接地址与背景颜色和字体颜色的十六进制表示。</p><h2 id="常用网站网址"><a href="#常用网站网址" class="headerlink" title="常用网站网址"></a>常用网站网址</h2><p><a href="https://www.luogu.org" target="_blank" rel="noopener">洛谷</a> | <a href="https://www.lydsy.com/JudgeOnline/" target="_blank" rel="noopener">BZOJ</a> | <a href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">Graph Editor</a> | <a href="https://sm.ms/" target="_blank" rel="noopener">图床</a>  | <a href="http://bytew.net/OIer/" target="_blank" rel="noopener">OIerDb</a> | <a href="http://ruanx.pw/bzojch/" target="_blank" rel="noopener">BZOJ离线题库</a> | <a href="https://darkbzoj.tk" target="_blank" rel="noopener">DarkBzoj</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="/search/index.html"/>
      <url>/search/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>所有分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>所有标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
