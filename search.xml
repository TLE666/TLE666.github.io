<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数学公式]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这里有一些重要的初高中数学公式，可供参考。 恒等变形$a^3 + b^3 = (a + b)(a^2 - ab + b)$ $a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$ $2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \geqslant 0$ $(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$ $(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$ $(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$ $(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$ $(a_1^2 + a_2^2 + a_3^2 + \cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \cdots + b_n^2) \geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \cdots + a_nb_n)^2$ —— $Cauchy$不等式 $(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$ 几何定理斯特瓦尔特定理 $BD \cdot AC^2 + DC \cdot AB^2 = BC \cdot AD^2 + BD \cdot DC \cdot BC$ 推论：中线长公式$AD = \frac{1}{2} \sqrt{2(AB^2 + AC^2) - BC^2}$ 欧拉线 $\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。 九点圆 在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。 西姆松线 过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。 史坦纳定理 $H$ 为$\triangle ABC$ 垂心，$D$为$\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\triangle ABC$的西姆松线通过线段$DH$的中点。 三角函数定义$\cot\alpha = \frac{1}{\tan\alpha} \qquad \sec\alpha = \frac{1}{\cos\alpha} \qquad \csc\alpha = \frac{1}{\sin\alpha}$ 诱导公式$\sin ( \pi + \alpha) =- \sin \alpha \qquad \cos(\pi + \alpha) = -\cos \alpha \qquad \tan (\pi + \alpha) = \tan \alpha$ $\sin (-\alpha) = -\sin\alpha \qquad \cos (-\alpha) = \cos\alpha \qquad \tan(-\alpha) = -\tan\alpha$ $\sin (\pi - \alpha) = \sin \alpha \qquad \cos (\pi - \alpha) = -\cos\alpha \qquad \tan(\pi - \alpha) = -\tan\alpha$ $\sin(2\pi - \alpha) = -\sin\alpha \qquad \cos(2\pi - \alpha) = \cos\alpha \qquad \tan(2\pi - \alpha) = -\tan\alpha$ $\sin (\frac{\pi}{2} + \alpha) = \cos\alpha \qquad \sin(\frac{\pi}{2} - \alpha) = \cos\alpha$ $\cos(\frac{\pi}{2} + \alpha) = -\sin\alpha \qquad \cos(\frac{\pi}{2} - \alpha) = \sin\alpha$ $\tan(\frac{\pi}{2} + \alpha) = -\cot\alpha \qquad \tan(\frac{\pi}{2} - \alpha) = \cot\alpha$ 两角和（差）公式$\sin(\alpha \pm \beta) = \sin\alpha\cos\beta \pm \cos\alpha\sin\beta$ $\cos(\alpha \pm \beta) = \cos\alpha\cos\beta \mp \sin\alpha\sin\beta$ $\tan(\alpha \pm \beta) = \frac{\tan\alpha \pm \tan\beta}{1 \mp \tan\alpha\tan\beta}$ 二倍角公式$\sin 2\alpha = 2\sin\alpha\cos\alpha$ $\cos2\alpha = 2\cos^2\alpha - 1 = 1 - 2\sin^2\alpha = \frac{1-\tan^2\alpha}{1+\tan^2\alpha}$ $\tan2\alpha = \frac{2\tan\alpha}{1-\tan^2\alpha}$ 三倍角公式$\sin(3\alpha) = 3\sin\alpha - 4\sin^3\alpha \qquad \cos(3\alpha) = 4\cos ^ 3\alpha - 3\cos\alpha$ 降幂公式$\sin^2\alpha = \frac{1 - \cos2\alpha}{2} \qquad \cos^2\alpha = \frac{1 + \cos2\alpha}{2} \qquad \tan^2\alpha = \frac{1 - \cos2\alpha}{1 + \cos2\alpha}$ 辅助角公式$a\sin x + b\cos x = \sqrt{a^2 + b^2}(\frac{a\sin x}{\sqrt{a^2 + b^2}} + \frac{b\cos x}{\sqrt{a^2 + b^2}})$ 或 $a\sin x + b\cos x = \sqrt{a^2 + b^2}\sin(x + \varphi)$，其中 $\sin\varphi = \frac{b}{\sqrt{a ^ 2 + b ^ 2}},\ \cos\varphi = \frac{a}{\sqrt{a^2 + b^2}}$ 万能公式$\sin\alpha = \frac{2\tan\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$ $\cos\alpha = \frac{1 - \tan^2\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$ $\tan\alpha = \frac{2\tan\frac{\alpha}{2}}{1 - \tan^2\frac{\alpha}{2}}$ 和差化积$\sin\alpha \pm \sin\beta = 2\sin\frac{\alpha \pm \beta}{2}\cos\frac{\alpha \mp \beta}{2}$ $\cos\alpha + \cos\beta = 2\cos\frac{\alpha + \beta}{2}\cos\frac{\alpha - \beta}{2}$ $\cos\alpha - \cos\beta = -2\sin\frac{\alpha + \beta}{2}\sin\frac{\alpha - \beta}{2}$ $\tan\alpha \pm \tan\beta = \frac{\sin(\alpha \pm \beta)}{\cos\alpha\cos\beta}$ 积化和差$\sin\alpha\cos\beta = \frac{1}{2}(\sin(\alpha + \beta) + \sin(\alpha - \beta))$ $\cos\alpha\sin\beta = \frac{1}{2}(\sin(\alpha + \beta) - \sin(\alpha - \beta))$ $\cos\alpha\cos\beta = \frac{1}{2}(\cos(\alpha +\beta) + \cos(\alpha - \beta))$ $\sin\alpha\sin\beta = -\frac{1}{2}(\cos(\alpha + \beta) - \cos(\alpha - \beta))$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>三角函数</tag>
        <tag>代数</tag>
        <tag>几何</tag>
        <tag>公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分详解]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u​$到$v​$的权值都加$d​$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。 前置技能：线段树（重要） &amp; 倍增求 $LCA​$（不必须） Definition &amp; Steps 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。 首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念： $size_i$：以$i​$为根的子树中结点个数 $dfn_i$：$i$结点的$dfs$序，即其新编号 $pre_i$：$dfn$的反函数，若$dfn_i\ =\ j$，则$pre_j\ =\ i$，即$dfn_{pre_i}\ =\ 1$。 $fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号） $dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\ =\ 1$ $w_i$：$i$结点的权值 重儿子：一个结点所有子结点中$size​$最大的子节点，用$wson[i]​$表示 轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点 重边：一个结点和它的重儿子的连边 轻边：一个节点和它的轻儿子的连边 重链：由多条重边首尾顺次连接而成的链（路径） 轻链：有多条轻边首尾顺次连接而成的链（路径） $top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上） 上一张百度百科的图： 如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可； 同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$ 递归伪代码如下： 123456789void dfs1(int u, int f) // u 当前结点，f 是 u 的父亲结点 size[u] = 1 for each v that connects to u : // u 的子结点 if(v != f) // v 不是 u 的父亲 fa[v] = u // 说明 v 是 u 的子结点 dep[v] = dep[u] + 1 // 深度维护 dfs(v, u) // 继续递归 size[u] += size[v] // 将子树的 size 加到这棵树的 size 上 if(size[wson[u]] &lt; size[v]) wson[u] = v // 更新重儿子 可以手动模拟一下 这样，我们就求出了每个结点的重儿子 $wson$ ； 特别地，每个叶子结点的重儿子都为 $0$ 每个标红点的结点都是一条重链的链首（$top$）， 而加粗的边则是重链。 比如，$1=&gt;4=&gt;9=&gt;13=&gt;14$ 就是一条重链，而 $2=&gt;6=&gt;11$ 也是另一条重链； 另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子， 例如 $top[3]\ =\ 3​$； 回顾一下，还有哪些信息没有维护呢？ $dfn,\ pre,\ top$ 其实，这三个只需要另一个递归函数就足够啦！ 12345678void dfs2(int u, int tp) // u 是当前结点，tp 是 u 所在重链的链首 top[u] = tp dfn[u] = ++tot // tot 是时间戳 pre[tot] = u // pre 是 dfn 的反函数 if(wson[u]) dfs2(wson[u], tp); // 只要 u 有重儿子，那就可以继续下去 for each v that connects to u : if(v != fa[u] &amp;&amp; v != wson[u]) // v 是 u 的轻儿子 dfs2(v, v); // 轻儿子是重链的链首 图中边上的数字就是 $dfs2$ 递归地顺序，不明白的可以参考一下。 检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？ $Answer:\ 10,\ 8$。 好了，树链剖分阶段到此结束。 将这棵树剖分成了许多链，现在就可以用线段树维护了~ 写上了一段带修改查询的线段树模板。。。 现在轮到处理问题的阶段了。 为了便于理解，我们就先实现两个最基础的操作吧： 路径点权求和、路径点权修改 大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。 举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。） 为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。 这个和倍增求 $LCA$ 有点像。 先找到 $dep$ 更深的结点，$11$（$dep[11]\ &gt;\ dep[9]$） 将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和 我们可以用事先维护好的 $dfn​$ 来帮助 由于 $top[11]\ =\ 2$，所以我们在求 $2=&gt;11$ 的和 我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！ 线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$ res += query(root, dfn[top[11]], dfn[11]) 这是，操作变成了求 $res\ +\ 9=&gt;11$ 的路径点权和。 所以我们将 $11$ 变为 $fa[top[11]]\ =\ 1$ 这是，我们发现 $1$ 和 $9$ 共链了。 所以像刚才一样， res += query(root, dfn[1], dfn[9]) 即可！ 将上面的步骤转化成代码： 1234567891011void Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; // 只要不共链 if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); // 每次都要让 top 深一些的往上跳 res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); // 注意大小关系！ res += query(root, left, right); return res;&#125; 很简单吧！ 修改操作类似， 12345678910vois Qchange(int u, int v, int d) &#123; // u 到 v 的路径上点权加 d int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];int dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存线段树 int left, right, s, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[wson[u]]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; // 线段树模板 r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = w[pre[left]]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; // 线段树模板 if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 线段树模板 r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return query(r-&gt;ls, left, r-&gt;ls-&gt;right) + query(r-&gt;rs, r-&gt;rs-&gt;left, right);&#125;inline int Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); res += query(root, left, right); return res;&#125;inline void Qchange(int u, int v, int d) &#123; int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125;int main() &#123; int op, u, v, d; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); // 读入点权 for(int i = 1; i &lt; n; i++) &#123; // 读图 scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; // 这步不能忘，否则 dfs1 没用！ dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(m--) &#123; // 操作 scanf("%d%d%d", &amp;op, &amp;u, &amp;v); if(op == 1) printf("%d\n", Qsum(u, v)); else &#123; scanf("%d", &amp;d); Qchange(u, v, d); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法讲解</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ5165] 树上倍增]]></title>
    <url>%2F2019%2F02%2F02%2F%5BBZOJ5165%5D%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\leq 3 \times 10^6$ ，操作次数 $m \leq 10^3$，$k \leq 10^3$ 题目链接： BZOJ P5165 Solution思路题目名称已经给了好嘛。。。 就是倍增啊。。 其实这题的难点不是在于思路想法，而是在于卡空间！ 操作1 $A \ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1​$。 维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$ 具体的维护方法见下面的代码 1234567dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = 1st[i][j] = k 代表 编号为i的节点向上跳2 ^ j个点到编号为k的节点因此st[i][0]即为节点i的父亲dep[++n] = dep[x] + 1; // 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号for(int i = 20; i &gt;= 0; i--) // 2 ^ 21 &gt; 3e6，因此只需维护到20即可 st[n][i] = st[st[n][i - 1]][i - 1]; // 倍增数组标准维护语句 操作2 $Q \ k\ p1\ p2\ p3\ …$ 查询$p1,\ p2,\ p3\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。 这个我想没什么好讲的吧。 就是依次求$LCA$就行啦。如果不懂详见代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 3000003int n = 1, m, dep[MAXN], st[MAXN][21], P;char ch[2]; // 读入操作用，char可能会咕掉inline void insert(int x) &#123; // 新建节点操作，上文讲过 dep[++n] = dep[x] + 1, st[n][0] = x; for(register int i = 1; i &lt;= 20; i++) st[n][i] = st[st[n][i - 1]][i - 1];&#125;inline int LCA(int u, int v) &#123; // 基本的LCA操作，不解释 if(dep[u] &gt; dep[v]) swap(u, v); for(register int i = 20; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(register int i = 20; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return st[u][0];&#125;int main() &#123; int k, lca; dep[1] = 1; // 将root的深度设为1 scanf("%d", &amp;m); while(m--) &#123; scanf("%s%d", ch, &amp;k); if(ch[0] == 'A') insert(k); else &#123; scanf("%d", &amp;lca); //依次求LCA for(register int i = 1; i &lt; k; i++) scanf("%d", &amp;P), lca = LCA(lca, P); printf("%d\n", lca); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速读入详解]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 卡常！ 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 ——来自~~某度~~百科…… 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read()&#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\overline{abcd} = 10 \times (10 \times (10 \times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \times |n|$，其中$sgn(x)$为$x$的符号。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法讲解</tag>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈二分]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \in \mathbb{Z}$，即整数$mid = \lfloor \dfrac{a + b}{2} \rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 $L = 0, R = 4, mid = \lfloor \dfrac{0 + 4}{2} \rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \lfloor \dfrac{0 + 2}{2} \rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \lfloor \dfrac{L + R}{2} \rfloor = 50$，设答案为$ans$。 只要$L \leqslant R$，尝试$mid$，\left\{ \begin{aligned} & 若mid > ans，则R = mid； \\ & 若mid < ans，则L = mid + 1； \\ & 若mid = ans，猜对了。 \end{aligned} \right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf("%d\n", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf("%d\n", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法讲解</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1462通往奥格瑞玛的道路]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B7P1462%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Description$n$个点$m$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b$断，并且经过的点权之和最大。 输出这个最大值 看完题面感觉语文要挂科。。。o(╥﹏╥)o Solution这题正解 $SPFA\ +$ 二分 二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了$QAQ​$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts("AFK"); else printf("%d\n", left); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1627中位数]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B4%9B%E8%B0%B7P1627%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目传送门 思路标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。妈妈再也不用担心下标的值为负啦！这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf("%d%d",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf("%d",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf("%d\n",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集入门]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts("-1"); return 0; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>算法讲解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_o1tQMBIJO5.html</url>
    <content type="text"><![CDATA[o1tQMBIJO5]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[本人乃无实力瑟瑟发抖萌新OIer 欢迎加QQ随时吊打我哦~ QQ：3271252272]]></content>
  </entry>
  <entry>
    <title><![CDATA[友链]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[$AcF$]]></content>
  </entry>
  <entry>
    <title><![CDATA[搜索]]></title>
    <url>%2Fsearch%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
