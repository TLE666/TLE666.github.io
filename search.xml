<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Coding Style]]></title>
    <url>%2F2019%2F06%2F13%2FCoding%20Style%2F</url>
    <content type="text"><![CDATA[这是本人的代码风格。 在下列规则中，部分来自于文末的谷歌代码规范。 整体 两空格缩进 使用 $Fira\ Mono$ 字体，大小为 14 号 $Sublime$ 编辑器最佳 一行的长度通常不要超过 60 列，一定不能超过 90 大括号不换行，但要在大括号前加空格 运算符间通常有空格， ++ 除外 头文件 通常在程序第一行 （ #pragma 时除外 ） include 和 &lt;头文件&gt; 之间有一个空格 通常只用一个万能头 #include &lt;bits/stdc++.h&gt; 命名空间 在头文件之后，与头文件之间空一行 在它后面也空一行 12345#include &lt;bits/stdc++.h&gt;using namespace std;... 定义 在命名空间之后 通常只需一个定义数组大小的函数 const int N = 100100; 如果有 typedef ... ... ，则将其置于 const int 之前 如果有 #define int long long 这种，则放到 const int 之后 如果有多个恒量（ const int ），则将他们分开 123456typedef long long ll;const int N = 100100;const int MOD = 1e9 + 7;const double eps = 1e-9;#define int long long#define rg register 变量 在定义之后，与定义间有空行 单行长度尽量不超过 60 两行之间不空行 1234bool vis[N];int a[N], b[N &lt;&lt; 1];ll x1, x2, x3, x4, AVeryLongVariableName, a, b, c, d, e, f, g;ll LengthOver60NeedToChangeLine; 结构体 在变量之后，与变量间有空行 在结构体名称与后方大括号间有空格 末尾右括号右侧加空格 1234struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool; 函数 在结构体之后，不同函数间有空行，函数内部没有空行 不管是什么函数都要加上 inline （尽管可能没啥用。。 关于程序中语句的一些要点也就揉到这里面了 for 、 if 和 while 后括号左侧要加空格 循环变量一般不加 register 如果循环内语句不小于两句，就加大括号，通常两句间用分号连接 循环和判断能不加大括号就不加 不加大括号时如果把循环（判断）内的语句放到循环（判断）的同一行内的长度不超过 60 就放到同一行 永远不要把任何语句放到大括号右边 123456789101112131415inline void dfs(int u) &#123; int u; bool x; for (edge *p = h[u]; p; p = p-&gt;next) for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) continue ; else if (i &amp; 1) &#123; a[1] = a[2] = a[3] = a[4] = a[5] = x; &#125; while (i) do &#123; // do while 要加大括号，就算只有一句 i++; &#125; while(i &lt; 5); &#125; puts("This is wrong!"); // 不能这样 return ;&#125; 主函数 通常把初始化写在一个函数内，在主函数内调用 通常使用 int main() ，除非 #define int long long 时才用 signed main() 最后要 return 0 散碎的变量统一放在主函数的开头，如果太多分两行 123456int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100100;int n, m, a[N];struct node &#123; int left, right, s, tag; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if (tag) &#123; if (ls) ls-&gt;seta(tag); if (rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[N &lt;&lt; 3], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if (left == right) &#123; r-&gt;s = a[left]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right);&#125;inline void change(node *r, int left, int right, int d) &#123; if (r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if (r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if (r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;int main() &#123; int l, r, d; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); build(root = ++cnt, 1, n); while (m--) &#123; sacnf("%d%d%d", &amp;l, &amp;r, &amp;d); change(root, l, r, d); &#125; return 0;&#125; 谷歌代码风格 ( 建议在新标签页中查看大图 ) 更详细的中文文字版在这里 最后的最后如果您有什么修改意见，也请在评论区留言，谢谢！]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CF518D」Ilya and Escalator]]></title>
    <url>%2F2019%2F06%2F05%2F%5BCF518D%5D%20Ilya%20and%20Escalator%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 个人排成一列，每秒中队伍最前面的人 $p$ 的概率走上电梯（一旦走上就不会下电梯）或者有 $(1-p)$ 的概率不动。问 $t$ 秒过后，在电梯上的人的数量的期望。 对于 $100 \%$ 的数据，满足 $n,t\leq2000$ 题目链接戳这里 Solution期望 $DP$ 。 设 $dp_{i,j}$ 表示第 $i$ 秒已经走上 $j$ 个人的概率。 则有 ans = \sum_{i = 1}^n dp_{t, i}转移方程如下（一定注意边界！）： dp_{i, j}=\left\{ \begin{array}{ll}dp_{i -1,0}\times(1-p) & j=0\\dp_{i - 1, j - 1}\times p+dp_{i-1,j}\times (1-p) & 1\le j]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HAOI2007」反素数]]></title>
    <url>%2F2019%2F05%2F17%2F%5BHAOI2007%5D%20%E5%8F%8D%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description对于一个数 $x$ ，只要它满足对于任意一个 $&lt; x$ 的数 $i$ ，均有 $g(i) &lt; g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。 题目连接戳这里 Solution设答案为 ans 。则有 ans = 2^{\alpha_1} \cdot 3^{\alpha_2} \cdot 5^{\alpha_3} \cdot ... \cdot 31^{\alpha_{11}}我们能够得出结论：若果 ans 为反素数，则 $\alpha_1 \geq \alpha_2 \geq \alpha_3 \geq … \geq \alpha_{11}$ 口糊 证明： 对于 ${p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$ ，假设 $p_1 &lt; p_2$ 且 $\alpha_1 &lt; \alpha_2$ ，则数 ${p_1}^{\alpha_2} \cdot {p_2}^{\alpha_1}$ 必定 $&lt;{p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$ 但两数的约数个数相等，矛盾！ 比如说 $2^3\cdot3^5$ ，则 $2^5\cdot3^3&lt;2^3\cdot3^5$ 但这两个数的约数和却相等。矛盾！ 只需暴力递归即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 30;int n, a[N], p[N] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31&#125;;int ans, mx;inline int qpow(int a, int b) &#123; // 不必须的快速幂 int res = 1; while (b) &#123; if (b &amp; 1) res *= a; a *= a, b &gt;&gt;= 1; &#125; return res;&#125;inline void upd(int cur) &#123; // 更新答案 int res = 1, tmp; for (int i = 1; i &lt;= cur; i++) res *= (a[i] + 1); tmp = 1; for (int i = 1; i &lt;= cur; i++) tmp *= qpow(p[i], a[i]); if (mx &lt; res) &#123; mx = res; ans = tmp; &#125; if(mx == res &amp;&amp; ans &gt; tmp) // 注意这种情况！ ans = tmp;&#125;inline void dfs(int cur, int cnt, int last) &#123; // 递归 for (int i = 0; i &lt;= cnt; i++) &#123; if (i) last *= p[cur]; if (last &gt; n) &#123; upd(cur); return ; &#125; a[cur] = i; if (!i) upd(cur); else dfs(cur + 1, i, last); &#125;&#125;signed main() &#123; scanf("%lld", &amp;n); dfs(1, 31, 1); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JZOJ4964」Rhyme]]></title>
    <url>%2F2019%2F05%2F08%2F%5BJZOJ4964%5D%20Rhyme%2F</url>
    <content type="text"><![CDATA[Description由于多次交换邮票没有满足所有人的需求，小$Z$被赶出了集邮部。无处可去的小$Z$决定加入音乐部，为了让音乐部的人注意到自己的才华，小$Z$想写一首曲子。为了让自己的曲子更好听，小$Z$找到了一些好听曲子作为模板。曲谱可以表示成只包含小写字母的字符串，小$Z$希望自己最终的曲谱中任意一个长度为$K$的子串都是一个模板的子串。现在小$Z$想知道自己的曲谱最长可以是多长，如果可以无限长的话请输出INF。 Input本题的每个测试点有多组数据，对于每组数据： 第一行两个整数$N$，$K$分别表示模板的个数与$K$值。 接下来$N$行，每行一个字符串表示一个模板。（只包含$’a’$~$’z’$） 每组数据字符串总长不超过$100000$，$1\leq K\leq100000$。每个测试点数据不超过$10$组。 Output对于每组数据输出一行表示曲子最长可以是多长，如果可以无限长的话输出$INF$。 Sample Input12341 4abcabc1 5abcabc Sample Output12INF6 样例解释 第一个样例的曲子可以是$”abc”$不断循环。 第二个样例的曲子最长是$”abcabc”$。 Hint对于一个$K$值来说，任意一个长度小于$K$的字符串均可行。 Solution字符串哈希 + 拓扑排序。 题目中给了固定的$K$，因此很容易想到字符串哈希。 于是我们可以哈希一下所有长度为$(K-1)$的子串，前一个与后一个以哈希值连边。最后拓扑一下就行了。 特别地，如果图上有环，那就说明是$INF$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N = 100100;const int M = 2e6;const ull MOD = 9223372036854775807;queue&lt;int&gt; Q;char str[N];int T, n, k, ans;int ind[M], S[N], f[M];ull hs[M], K;bool vis[M];struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[M], *cnt = pool;inline int num(const char &amp;x) &#123; return x - 'a' + 1;&#125;inline void addedge(int u, int v) &#123; edge *p = ++cnt; ind[v]++; vis[u] = vis[v] = true; p-&gt;v = v, p-&gt;next = h[u], h[u] = p;&#125;inline ull qpow(ull a, ull b) &#123; ull res = 1; while(b) &#123; if(b &amp; 1) (res *= a) %= MOD; b &gt;&gt;= 1, (a *= a) %= MOD; &#125; return res;&#125;inline ull Hash(ull d) &#123; ull p = d % M; while(hs[p] &amp;&amp; hs[p] != d) &#123; p++; if(p &gt;= M) p -= M; &#125; hs[p] = d; return p;&#125;inline void tpsort() &#123; int u, v; while(!Q.empty()) &#123; u = Q.front(); Q.pop(); ans = max(ans, f[u]); for(edge *p = h[u]; p; p = p-&gt;next) &#123; if(!(--ind[v = p-&gt;v])) Q.push(v); f[v] = max(f[v], f[u] + 1); &#125; &#125;&#125;inline void prework() &#123; K = qpow(26, k - 1); cnt = pool; memset(h, 0, sizeof(h)); memset(f, 0, sizeof(f)); memset(ind, 0, sizeof(ind)); memset(vis, false, sizeof(vis)); while(!Q.empty()) Q.pop();&#125;int main() &#123; while(scanf("%d%d", &amp;T, &amp;k) != EOF) &#123; prework(); while(T--) &#123; scanf("%s", str + 1); n = strlen(str + 1); if(n &lt; k) continue ; for(int i = 1; i &lt;= n; i++) S[i] = num(str[i]); ull tmp = 0, u = 0, v = 0; for(int i = 1; i &lt; k; i++) (tmp *= 26) += S[i]; for(int i = k; i &lt;= n; i++) &#123; u = Hash(tmp); (tmp *= 26) += (ull) (S[i] - S[i - k + 1] * K); v = Hash(tmp); addedge(u, v); &#125; &#125; ans = k - 1; for(int i = 0; i &lt; M; i++) if(vis[i] &amp;&amp; !ind[i]) Q.push(i), f[i] = k - 1; tpsort(); bool flag = false; for(int i = 0; i &lt; M; i++) if(ind[i] &amp;&amp; vis[i]) &#123; flag = true; break ; &#125; if(flag) puts("INF"); else printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>字符串哈希</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策单调性]]></title>
    <url>%2F2019%2F05%2F04%2F%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%2F</url>
    <content type="text"><![CDATA[在做动归题时，我们常会遇到复杂度过高的情况。 决策单调性可以帮你减轻复杂度带来的负担。 Monge Condition即 四边形不等式； 对于 $w(i,j)$ 和依次递增的四个数 $a, b, c, d$ 只要 w(a, c) + w(b, d) \leq w(a, d) + w(b, c)那么我们就说函数 $w(i, j)$ 满足四边形不等式。 就好比一个矩形，其左上角为 $(a, c)$，右下角为 $(b, d)$，左上角的值加右下角的值 其名称也是因此而来的。 决策单调性对于一个转移方程 f_i = \min(f_j + w_{j, i})其中 $1 \leq j &lt; i$； 设 $opt(i)$ 代表 $(f_j + w_{j, i})$ 最小时的 $j$，即 f_i = f_{opt(i)} + w_{opt(i), i}这里显然有 $opt(i) &lt; i$ 决策单调性就是指 $opt(i) \leq opt(i + 1)$ 结论：若 $w_{i, j}$ 满足四边形不等式，则转移方程满足决策单调性，即 四边形不等式推出决策单调性。 证明: 由定义， f_i = f_{opt(i)} + w_{opt(i), i}f_{i + 1} = f_{opt(i + 1)} + w_{opt(i + 1), i + 1}$w$ 满足 $Monge\ Condition$； 若 $opt(i) &gt; opt(i + 1)$，即决策单调性不成立； opt(i + 1) < opt(i) \leq i < i + 1令 $a = opt(i + 1),\ b = opt(i),\ c = i,\ d = i + 1$； 由 $Monge\ Condition$， w(a, c) + w(b, d) \leq w(a, d) + w(b, c)因为 $f_i$ 和 $f_{i + 1}$ 都取到了最小值，所以 $(f_i + f_{i + 1})_{\min}$ 而 $(f_i + f_{i + 1}) = f_a + f_b + w(a, d) + w(b, c)$ ​ $\geq f_a + f_b + w(a, c) + w(b, d)$ 矛盾！ 取法： 令 $f_i = f_{opt(i + 1)} + w_{opt(i + 1), i}$，$f_(i + 1) = f_{opt(i)} + w_{opt(i), i + 1}$， 即互换 $opt(i),\ opt(i + 1)$ 即可。 ∴$opt(i) \leq opt(i + 1)$ 证毕。 简单例题： 「CF321E」Ciel and Gondolas 「NOI2009」诗人小G]]></content>
      <categories>
        <category>OI</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>DP</tag>
        <tag>公式</tag>
        <tag>四边形不等式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1811」LCS - Longest Common Substring]]></title>
    <url>%2F2019%2F04%2F27%2F%5BSPOJ1811%5D%20LCS%20-%20Longest%20Common%20Substring%2F</url>
    <content type="text"><![CDATA[Description输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出0 。 对于$100 \%$的数据，$|S| \leq 250000$ 题目链接戳这里 Solution这道题可以作为后缀数组的练手题。调了5个小时。。。 后缀数组是对一个字符串的操作啊，那这道题不是2个嘛？ 把它整到一个里面就行啦！ 忽然想到$Manacher$算法，中间每两个字符不是用$隔开了吗？ 对啊！ 就在两个单词中间加个$就行啦~ 举个栗子： S_1 = "firststring"S_2 = "secondstring"（双引号不包括在字符串中） 则整合后的字符串 S = "firststring$secondstring"很简单吧、 于是这个问题就转化为了在一个字符串里找最长重复子串啦 ——这不就是$height$数组嘛 但是注意有一个小条件 两个最长子串必须在不同的单词之间哦！ 这个随便判断一下就行啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000100;char s[2][N];int n, m, ans, len, x[N], y[N];int rk[N], sa[N], h[N], c[N], a[N];// 其中 h 数组就是 height 数组inline void rsort() &#123; for(int i = 1; i &lt;= m; i++) c[i] = 0; for(int i = 1; i &lt;= n; i++) c[x[i]]++; for(int i = 2; i &lt;= m; i++) c[i] += c[i - 1]; for(int i = n; i &gt;= 1; i--) sa[c[x[y[i]]]--] = y[i];&#125;inline void getSA() &#123; int p = 0; for(int i = 1; i &lt;= n; i++) x[i] = a[i], y[i] = i; rsort(); for(int k = 1; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= 1) &#123; p = 0; for(int i = n - k + 1; i &lt;= n; i++) y[++p] = i; for(int i = 1; i &lt;= n; i++) if(sa[i] &gt; k) y[++p] = sa[i] - k; rsort(); swap(x, y); x[sa[1]] = 1, p = 2; for(int i = 2; i &lt;= n; i++) if(y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = p - 1; else x[sa[i]] = p++; m = p; &#125;&#125;inline void getH() &#123; for(int i = 1; i &lt;= n; i++) rk[sa[i]] = i; int L = 0, j; for(int i = 1; i &lt;= n; i++) &#123; j = sa[rk[i] - 1]; if(L) L--; while(a[i + L] == a[j + L]) L++; h[rk[i]] = L; &#125;&#125;int main() &#123; scanf("%s%s", s[0], s[1]); len = n = strlen(s[0]), m = strlen(s[1]); n += m + 1, m = 128; for(int i = 1; i &lt;= len; i++) a[i] = s[0][i - 1]; a[len + 1] = '$'; for(int i = len + 2; i &lt;= n; i++) a[i] = s[1][i - len - 2]; getSA(); getH(); for(int i = 2; i &lt;= n; i++) if((sa[i] &gt; len &amp;&amp; sa[i - 1] &lt; len) || (sa[i] &lt; len &amp;&amp; sa[i - 1] &gt; len)) ans = max(ans, h[i]); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ2561」最小生成树]]></title>
    <url>%2F2019%2F03%2F27%2F%5BBZOJ2561%5D%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Description一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。 对于$100\%$的数据，$N,\ L \leq 20000$，$M \leq 200000$ 题目链接戳这里 Solution思路妙啊！ 如果$L$那条边可能出现在最小生成树上，那么就有边权$&lt;L$的边不能连通其两端点$(u, v)$，否则将$u$和$v$连起来再删除$L$那条边显然更小。这不就是最小割嘛！ 最大生成树也同理，于是答案就是两次最小割之和。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200200;const int INF = 0x7f7f7f7f;int n, m, S, T, L, lev[N], ans;struct edge &#123; int v, c; edge *next, *rev;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct node &#123; int u, v, c;&#125; a[N];inline void clear() &#123; memset(pool, 0, sizeof(pool)), memset(h, NULL, sizeof(h)), cnt = pool;&#125;inline void addedge(int u, int v, int c) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;c = c, p-&gt;next = h[u], h[u] = p, p-&gt;rev = q; q-&gt;v = u, q-&gt;c = c, q-&gt;next = h[v], h[v] = q, q-&gt;rev = p;&#125;inline bool makelev() &#123; int u, v; memset(lev, -1, sizeof(lev)); queue&lt;int&gt; Q; Q.push(S), lev[S] = 0; while(!Q.empty()) &#123; u = Q.front(), Q.pop(); for(edge *p = h[u]; p; p = p-&gt;next) if(!(lev[v = p-&gt;v] + 1) &amp;&amp; p-&gt;c &gt; 0) &#123; lev[v] = lev[u] + 1; Q.push(v); &#125; &#125; return (lev[T] != -1);&#125;inline int dfs(int u, int flow) &#123; int v, res = 0, f; if(u == T) return flow; for(edge *p = h[u]; p; p = p-&gt;next) if(lev[v = p-&gt;v] == lev[u] + 1 &amp;&amp; p-&gt;c &gt; 0) &#123; f = dfs(v, min(p-&gt;c, flow)); flow -= f, p-&gt;c -= f; res += f, p-&gt;rev-&gt;c += f; if(!flow) break ; &#125; if(!res) lev[u] = -1; return res;&#125;inline int dinic() &#123; int res = 0; while(makelev()) res += dfs(S, INF); return res;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;a[i].u, &amp;a[i].v, &amp;a[i].c); scanf("%d%d%d", &amp;S, &amp;T, &amp;L); for(int i = 1; i &lt;= m; i++) if(a[i].c &gt; L) addedge(a[i].u, a[i].v, 1); // 注意这里的边权 ans += dinic(); clear(); for(int i = 1; i &lt;= m; i++) if(a[i].c &lt; L) addedge(a[i].u, a[i].v, 1); // 这里也是 ans += dinic(); printf("%d\n", ans); return 0;&#125;/*3 23 2 11 2 31 2 2*/]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU6203」ping ping ping]]></title>
    <url>%2F2019%2F03%2F21%2F%5BHDU6203%5D%20ping%20ping%20ping%2F</url>
    <content type="text"><![CDATA[Description$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 U V 无法连通。问无法通行的点最少有多少个。 对于$100 \%$的数据，$3 \leq n \leq 10^4$，$p \leq 5 \times 10^4$ 题目链接戳这里 Solution考虑到我们要求的是$u$到$v$上不能通行，很显然 能想到可以通过树上前序与后序$DFS$序来维护。具体方法如下： 根据所给的树预处理出每个点的前序 $DFS$ 序和后序$DFS$ 序（需一起标号），和每个点的深度。 根据 $p$ 组 U V 处理每组两点之间的 $LCA$ 。压入优先队列（$LCA$ 深度大的点优先，即往前走）。 对于出队的U V及其对应的 $LCA$ ，判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。 判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。 处理方式：由于之前已经处理出每个点的前后序 $DFS$ 序 $in$ 和 $out$ 。 对于某点 $U$ 若在已禁止通行点 $P$ 的子树中，则 $In[P]≤In[U]≤Out[U]≤Out[P]In[P]≤In[U]≤Out[U]≤Out[P]$ 一定成立。 故利用树状数组区间更新单点查询。对每个禁止通行点 $P$ ，标记区间 $[In[P],Out[P]][In[P],Out[P]]$ 中所有点。查询时，若点 $In[U]$ 被标记，则说明 U V 已经被隔断。 同时，由于优先处理 $LCA$ 深度大的点，不会出现点 U V 同时在同一个被禁止通行点 $P$ 的子树内。 若 $U$ ，$V$ 均不在被禁止的点在子树内，则禁止 U V 的 $LCA$ 点，同时对答案贡献 $+1$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100100;int n, p, in[N], out[N], tot, dep[N];int st[N][25], fa[N], C[N &lt;&lt; 1], ans;bool vis[N];struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct P &#123; int u, v, lca; inline bool operator &lt; (const P &amp;x) const &#123; return dep[lca] &lt; dep[x.lca]; &#125;&#125; rec;priority_queue&lt;P&gt; pq;inline void prework() &#123; // 注意多组数据的清空 ans = tot = 0, cnt = pool, tot = 0; while(!pq.empty()) pq.pop(); memset(h, NULL, sizeof(h)), memset(pool, 0, sizeof(pool)), memset(in, 0, sizeof(in)), memset(out, 0, sizeof(out)), memset(dep, 0, sizeof(dep)), memset(st, 0, sizeof(st)), memset(fa, 0, sizeof(fa)), memset(vis, false, sizeof(vis)), memset(C, 0, sizeof(C));&#125;inline void addedge(int u, int v) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u, int depth) &#123; int v; in[u] = ++tot; dep[u] = depth, vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u; dfs(v, depth + 1); &#125; out[u] = ++tot;&#125;inline int LCA(int u, int v) &#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(int i = 19; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return fa[u];&#125;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; for(; x; x -= lowbit(x)) res += C[x]; return res;&#125;inline void change(int x, int d) &#123; for(; x &lt; (N &lt;&lt; 1); x += lowbit(x)) C[x] += d;&#125;inline void work() &#123; // 主要函数 int u, v; prework(); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(++u, ++v); &#125; ++n, dfs(1, 1); for(int i = 1; i &lt;= n; i++) st[i][0] = fa[i]; for(int i = 1; i &lt;= 20; i++) for(int j = 1; j &lt;= n; j++) st[j][i] = st[st[j][i - 1]][i - 1]; scanf("%d", &amp;p); for(int i = 1; i &lt;= p; i++) &#123; scanf("%d%d", &amp;u, &amp;v); rec.u = ++u, rec.v = ++v, rec.lca = LCA(u, v); pq.push(rec); &#125; while(!pq.empty()) &#123; rec = pq.top(), pq.pop(); if(!(sum(in[rec.u]) + sum(in[rec.v]))) change(in[rec.lca], 1), change(out[rec.lca] + 1, -1), ans++; &#125; printf("%d\n", ans);&#125;int main() &#123; while(scanf("%d", &amp;n) != EOF) work(); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>树状数组</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ1043」GSS1]]></title>
    <url>%2F2019%2F03%2F17%2F%5BSPOJ1043%5D%20GSS1%2F</url>
    <content type="text"><![CDATA[Description给一段可能有负数的序列，查询最大子段和。 对于$100 \%$的数据，序列长度$N \leq 50000$，$a[i] \leq 15007$ 题目链接戳这里 Solution线段树查询最大子段和。 这里需要维护四个信息： $s$ 区间和 $mx$ 区间最大子段和 $lmx$ 区间前缀和最大值 $rmx$ 区间后缀和最大值 则维护的时候就像这样 1234s = ls-&gt;s + rs-&gt;s,mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), // 注意有三种情况lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); 其中$ls$，$rs$分别是左子，右子。 还有一个注意事项：$query$（查询）的时候返回值要是$node*$！只有这样才能够维护四个信息。 Code码风在这种题里很重要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 1001000;int n, m, a[MAXN];struct node &#123; int left, right, mx, lmx, rmx, s; node *ls, *rs; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s, mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx), rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); &#125;&#125; pool[MAXN &lt;&lt; 5], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = r-&gt;mx = r-&gt;lmx = r-&gt;rmx = a[left]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline node *query(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else &#123; node *L, *R, *res; L = query(r-&gt;ls, left, r-&gt;ls-&gt;right), R = query(r-&gt;rs, r-&gt;rs-&gt;left, right), res = ++cnt, res-&gt;s = L-&gt;s + R-&gt;s, res-&gt;left = L-&gt;left, res-&gt;right = R-&gt;right, res-&gt;mx = max(L-&gt;rmx + R-&gt;lmx, max(L-&gt;mx, R-&gt;mx)), res-&gt;lmx = max(L-&gt;s + R-&gt;lmx, L-&gt;lmx), res-&gt;rmx = max(R-&gt;s + L-&gt;rmx, R-&gt;rmx); return res; &#125;&#125;int main() &#123; int left, right; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); build(root = cnt, 1, n); scanf("%d", &amp;m); while(m--) &#123; scanf("%d%d", &amp;left, &amp;right); printf("%d\n", query(root, left, right)-&gt;mx); &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ZJOI2009」时态同步]]></title>
    <url>%2F2019%2F03%2F15%2F%5BZJOI2009%5D%20%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Description一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。 对于$100\%$的数据，$N \leq 500000$，边权$t_e \leq 1000000$。 题目连接戳这里 Solution树形$DP$的板子题。 令$dp_x$为叶子结点到$x$结点的最大时间。 则有 $dp_x = \max (dp_{son[x]} + dis_{x,\ son[x]})$ 因此 $ans = \sum (dp_x - dp_{son[x]} - dis_{x,\ son[x]})$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 500500#define int long longint n, root, dp[MAXN], ans, fa[MAXN];bool vis[MAXN];struct edge &#123; int v, w; edge *next;&#125; pool[MAXN &lt;&lt; 1], *h[MAXN], *cnt = pool;inline void addedge(int u, int v, int w) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u) &#123; int v; vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u, dfs(v); dp[u] = max(dp[u], dp[v] + p-&gt;w); &#125; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u]) ans += (dp[u] - dp[v] - p-&gt;w);&#125;signed main() &#123; int u, v, w; scanf("%lld%lld", &amp;n, &amp;root); for(int i = 1; i &lt; n; i++) &#123; scanf("%lld%lld%lld", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; dfs(root); printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SCOI2009」windy 数]]></title>
    <url>%2F2019%2F03%2F10%2F%5BSCOI2009%5D%20windy%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description求$A$，$B$之间所有满足相邻两位之间差$\geq2$的整数。 对于$100$%的数据， $1 \leq A \leq B \leq 2 \times 10^9$。 Solution数位$DP$模板题。 令$dp_{i,j}$表示第$i$位，上一位为$j$的总方案数（一直到结束）。 然后逐位$DP$即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;ll dp[110][11], d[110];inline ll calc(int x, int p) &#123; if(dp[x][p] + 1) return dp[x][p]; if(!x) return dp[x][p] = 1; ll res = 0; for(int q = 0; q &lt; 10; q++) if(abs(p - q) &gt;= 2) res += calc(x - 1, q); return dp[x][p] = res;&#125;inline ll solve(ll x) &#123; int m = 0, ans = 0, pre = -110; while(x) d[m++] = x % 10, x /= 10; for(int i = 1; i &lt; m; i++) for(int j = 1; j &lt;= 9; j++) ans += calc(i - 1, j); for(int i = m - 1; i &gt;= 0; i--) &#123; for(int j = (i == m - 1); j &lt; d[i]; j++) if(abs(pre - j) &gt;= 2) ans += calc(i, j); if(abs(pre - d[i]) &lt; 2) break ; pre = d[i]; &#125; return ans;&#125;int main() &#123; ll l, r; memset(dp, -1, sizeof(dp)); scanf("%lld%lld", &amp;l, &amp;r); printf("%lld\n", solve(r + 1) - solve(l)); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非旋 Treap 详解]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%9D%9E%E6%97%8BTreap%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction “$Treap$的旋转好难啊！” “你不知道非旋$treap$吗？” （被一顿吊打。。 这就是$FHQ-Treap$。 前置技能：小根堆 &amp; $Treap$（不必须） 提示：此博客图片较多，如无法加载请刷新重试~ Definition12345678struct node &#123; int d, rnd, size; node *ls, *rs; inline void upd() &#123; &#125; inline void push() &#123; &#125;&#125; pool[MAXN &lt;&lt; 1], *root, *cnt = pool; $d$是真实权值，$rnd$是随机权值，$size$是子树大小； $ls$是左儿子，$rs$是右儿子； $upd$是从下往上更新信息（例如$size$）； $push$是下发懒标记。 $root$是根。 OperationsMerge 假设有两颗子树x，y，且 x 的所有节点的值都小于 y 的所有节点的值，随机权值 rnd 都以小根堆的形式存储。 此时要合并 x , y 。我们先比较它们的根的随机权值，发现1&lt;3，因为要满足小根堆性质，于是 x 的左子树全部不变，让它的右子树继续和 y 合并。 这时我们发现，随机权值 rnd 5&gt;3，所以 y 接到 root(图中rot) 的下方，成为 root 的右儿子，y的右子树全部不变，让y的左子树继续和x合并（以满足平衡树的性质）。 由于5&gt;4，所以y和y的右子树作为root的左儿子，y的左子树继续和x合并。 以此类推…… 最后，我们发现 x 为 0 ，所以直接返回 y ，合并结束。 Code1234567891011inline node *merge(node *l, node *r) &#123; if(!l || !r) return l ? l : r; // 如果有一边为空 if(l-&gt;rnd &lt; r-&gt;rnd) &#123; l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r); l-&gt;upd(); return l; &#125; else &#123; r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls); r-&gt;upd(); return r; &#125;&#125; Split1.按权值split首先得有个基准值 a ，即权值小于等于 a 的节点全部进入左树（下图中会将此类节点染红），大于a的节点全部进入右树（下图中会将此类节点染蓝）。这里以a=25为例。 首先，发现rot的权值=15&lt;25，由平衡树的性质可知，rot的左子树所有节点权值一定小于25，所以rot和它的的左子树全部进入左树，继续拆分rot的右子树。 32&gt;25，所以 rot 和它的右子树全部进入右树，继续拆分 rot 的左子树。 29&gt;25，同上。 24&lt;25，所以拆分右子树。 27&gt;25，所以拆分左子树。 发现此时rot为0，所以拆分完毕，返回。 2.按排名split就是把前 k 个节点拆入左树，其它节点拆入右树。这里以k=5为例。 rot的左子树的siz+1=3&lt;5，所以rot和它的左子树进入左树，其他节点拆分5-3=2个节点进入左树。 4+1&gt;2，所以rot和右子树进入右树，其它节点继续拆分出2个节点进入左树。 3+1&gt;2，同上。 1+1=2，所以rot和左子树进入左树，其它节点继续拆分2-2=0个节点进入左树。 1+0&gt;0，所以rot和右子树进入右树，其它节点继续拆分0个节点进入左树。 rot为0，拆分结束。 Code12345678// 按排名分inline void split(node *p, node *&amp;l, node *&amp;r, int k) &#123; if(!p) &#123; l = r = NULL; return ;&#125; p-&gt;push(); if(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k); else l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - 1); p-&gt;upd();&#125; Other OperationsFHQ treap 的核心操作只有 merge 和 split 两个，其他操作都是基于这两个操作实现的。 插入插入权值为 x 的节点时，先新建一个节点，再以 x 为界按权值 split 整棵树为a,b，再按顺序 merge a，x，b。 删除要删除x，先将整棵树以 x-1 为界按权值split 成a和b，再将 b 以 1 为界 按排名split 成c和d，则 c 就是要删除的节点。最后按顺序merge a，b，d。 （当然，这是在要删除节点必定存在的情况下才能进行的操作，不存在的情况请自行脑补） 查询 x 的排名先将整棵树以x-1按权值split成a和b，则a的siz+1即为x的排名。 查询排名为 k 的值先split出整棵树前k-1小节点，则右树最小节点即为所求节点，再次split 即可。 查x前驱将整棵树以x-1按权值split，左树中最大节点即为所求节点，转入第x小值问题。 查x后继将整棵树以x按权值split，右树中最小节点即为所求节点，转入第x小值问题。 Problems文艺平衡树 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100#define size(a) ((a) ? a-&gt;size : 0)int n, m;struct node &#123; int d, rnd, size, tag; node *ls, *rs; inline void sets() &#123; tag ^= 1;&#125; inline void upd() &#123; size = size(ls) + size(rs) + 1;&#125; inline void push() &#123; if(tag) &#123; swap(ls, rs); if(ls) ls-&gt;sets(); if(rs) rs-&gt;sets(); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 1], *root, *cnt = pool;inline node *newnode(int d) &#123; // 新建 node *p = ++cnt; p-&gt;d = d, p-&gt;rnd = (rand() &lt;&lt; 15) + rand(), p-&gt;size = 1, p-&gt;tag = 0; return p;&#125;inline node *merge(node *l, node *r) &#123; if(!l || !r) return l ? l : r; if(l-&gt;rnd &lt; r-&gt;rnd) &#123; l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r); l-&gt;upd(); return l; &#125; else &#123; r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls); r-&gt;upd(); return r; &#125;&#125;inline void split(node *p, node *&amp;l, node *&amp;r, int k) &#123; if(!p) &#123; l = r = NULL; return ;&#125; p-&gt;push(); if(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k); else l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - 1); p-&gt;upd();&#125;inline int rk(node *p, int x) &#123; // 排名 if(!p) return 0; p-&gt;push(); if(p-&gt;d &gt;= x) return rk(p-&gt;ls, x); else return size(p-&gt;ls) + 1 + rk(p-&gt;rs, x);&#125;inline void rev(int l, int r) &#123; // 翻转 node *p, *q, *s; split(root, p, q, l - 1), split(q, q, s, r - l + 1); q-&gt;tag ^= 1, root = merge(merge(p, q), s);&#125;inline void print(node *r) &#123; // 输出 r-&gt;push(); if(r-&gt;ls) print(r-&gt;ls); printf("%d ", r-&gt;d); if(r-&gt;rs) print(r-&gt;rs);&#125;int main() &#123; srand((unsigned long long) new char); int left, right; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; node *tmp = newnode(i); root = merge(root, tmp); &#125; while(m--) &#123; scanf("%d%d", &amp;left, &amp;right); rev(left, right); &#125; print(root); return 0;&#125; After Words此文章参考了部分以下文章，出处： https://www.cnblogs.com/Judge/p/9506980.html （这篇文章很优质！）]]></content>
      <categories>
        <category>OI</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>fhq-treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「luogu1558」色板游戏]]></title>
    <url>%2F2019%2F03%2F06%2F%5Bluogu1558%5D%20%E8%89%B2%E6%9D%BF%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作： 将$a[l]$到$a[r]$赋值为$d$； 询问$a[l]$到$a[r]$有几种不同的数。 操作$m$次，$d \in [1,\ t]$ 对于$100$%的数据， $1 \leq n \leq 100000$，$1 \leq t \leq 30$，$1 \leq m \leq 100000$ 题目链接戳这里 Solution线段树的基础题 然后我错了9遍 很有意思的一道题，有两种不同的解法 解法一比较暴力，建$t$棵线段树即可。 第$i$棵线段树只存值为$i$的数组有哪些。 常数比较大。 $6$次提交，不开$O2$最高只能$80$分，就算开了$O2$也只能$90$。。 你们自己想卡常就卡去吧。。 我的$80$分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, mx, tag; node *ls, *rs; inline void seta(int x) &#123; tag = x, mx = (x == 1 ? 1 : 0);&#125; inline void upd() &#123; mx = max(ls-&gt;mx, rs-&gt;mx);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 8], *root[35], *cnt = pool;inline void build1(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;mx = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build1(ls, left, mid), build1(rs, mid + 1, right); r-&gt;upd();&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) return ; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right);&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;mx; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;int main() &#123; int A, B, C, ans; n = read(), t = read(), m = read(); build1(root[1] = cnt, 1, n); for(int i = 2; i &lt;= t; i++) build(root[i] = ++cnt, 1, n); while(m--) &#123; scanf("%s", ch); A = read(), B = read(); if(A &gt; B) swap(A, B); if(ch[0] == 'C') &#123; C = read(); for(int i = 1; i &lt;= t; i++) if(i != C) change(root[i], A, B, -1); else change(root[C], A, B, 1); &#125; else &#123; ans = 0; for(int i = 1; i &lt;= t; i++) ans += query(root[i], A, B); printf("%d\n", ans); &#125; &#125; return 0;&#125; 解法二$100$%的正解。 用二进制来表示区间的取值情况。 比如$a_1 = 1,\ a_2 = 2,\ a_3 = 3,\ a_4 = 2$， 我们不妨设数值$i$是$2^{i - 1}$ 则1,2合起来就是0011； 1,3合起来就是0101； 注意：2,3,4合起来是0110而不是0120！ 大体上和解法一比较类似 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, s, tag; // s 就是存压位的那个。 node *ls, *rs; inline void seta(int x) &#123; s = (1 &lt;&lt; (x - 1)), tag = x;&#125; inline void upd() &#123; s = (ls-&gt;s | rs-&gt;s);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return (query(r-&gt;ls, left, r-&gt;ls-&gt;right) | query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline int count(int x) &#123; int res = 0; for(int i = 30; i &gt;= 0; i--) if(x &gt;= (1 &lt;&lt; i)) x -= (1 &lt;&lt; i), res++; return res;&#125;int main() &#123; int left, right, d; n = read(), t = read(), m = read(); build(root = cnt, 1, n); while(m--) &#123; scanf("%s", ch), left = read(), right = read(); if(left &gt; right) swap(left, right); if(ch[0] == 'C') &#123; d = read(); change(root, left, right, d); &#125; else printf("%d\n", count(query(root, left, right))); &#125; return 0;&#125;/*2 2 4C 1 1 2P 1 2C 2 2 2P 1 2*/]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平面向量练习小结]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%B9%B3%E9%9D%A2%E5%90%91%E9%87%8F%E7%BB%83%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。 坐标表示法对于向量，我们能不能制定一种与坐标类似，与有序数对一一对应的方法呢？ 这就是向量的“万能方法”——坐标表示法。 对于向量$\overrightarrow{AB}$，我们令$A$为坐标的原点，以两个夹角不为零的向量为坐标轴，不妨设$\overrightarrow{p}$为$x$轴，$\overrightarrow{q}$为$y$轴。我们可以将$\overrightarrow{AB}$定义为$(x,\ y)$，其中$x,y \in \mathbb{R}$。此时满足$\overrightarrow{AB} = x \overrightarrow{p} + y \overrightarrow{q}$。 通常，为了方便起见，我们就将$\overrightarrow{p}$和$\overrightarrow{q}$设为$x$轴和$y$轴正半轴方向上的的单位向量。 这样，题目中复杂的条件就可以通过下面的公式化繁而简了。 一些有用的公式 在以下公式中，默认$\overrightarrow{A} = (x_1,y_1),\ \overrightarrow{B} = (x_2,y_2)$ $\overrightarrow{A} + \overrightarrow{B} = (x_1 + y_1, x_2 + y_2)$ $\overrightarrow{A} - \overrightarrow{B} = (x_1 - y_1, x_2 - y_2)$ $\overrightarrow{A} \cdot \overrightarrow{B} = x_1x_2+y_1y_2$ 由此我们可以推出 $\cos&lt;\overrightarrow{A}, \overrightarrow{B}&gt; = \frac{x_1x_2 + y_1y_2}{\sqrt{x_1^2 + y_1^2} \cdot \sqrt{x_2^2 + y_2^2}}$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>平面向量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2011」Car的旅行路线]]></title>
    <url>%2F2019%2F03%2F02%2F%5BNOIP2011%5D%20Car%E7%9A%84%E6%97%85%E8%A1%8C%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\leq10$，矩形个数$\leq100$。 题目链接戳这里 Solution打死我也不告诉你我Floyd模板打错了 通过$floyd$处理出任意两点（注意不是矩形）之间的最小费用即可。 但这道题细节还是不少的—— 只给你矩形的三个顶点 先通过勾股定理逆定理来求出哪个是直角，然后第四个点的坐标就出来了。 矩形可以是歪的，即它的边不一定平行于坐标轴。 多组数据注意初始化。 飞机和汽车费用不一样，需要分别计算。 最后只输出1位小数 $Hint$：两点间距离公式 $dis\ =\ \sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2}$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 110int _, S, t, A, B, tot;double w[MAXN][MAXN], ans; // w 是两点间的最小费用inline double sq(int x) &#123; return (double)x * x;&#125;struct point &#123; int id, t, x, y; // id 城市编号，t 列车费用 inline void INIT(int _id, int _t, int _x, int _y) &#123; id = _id, t = _t, x = _x, y = _y; &#125; // 赋值函数（更简单的忘了怎么写了 QwQ inline double dis(point &amp;a) &#123; return sqrt(sq(x - a.x) + sq(y - a.y)); &#125; // 两点间距离 inline void rct(point &amp;a, point &amp;b, point &amp;c) &#123; id = a.id, t = a.t; int P = sq(a.x - b.x) + sq(a.y - b.y), Q = sq(b.x - c.x) + sq(b.y - c.y), R = sq(c.x - a.x) + sq(c.y - a.y); if(P + Q == R) x = a.x + c.x - b.x, y = a.y + c.y - b.y; else if(P + R == Q) x = b.x + c.x - a.x, y = b.y + c.y - a.y; else x = a.x + b.x - c.x, y = a.y + b.y - c.y; &#125; // 处理第四个点的坐标&#125; p[MAXN];inline void prework() &#123; static point P, Q; static double c, d; memset(w, 0x3f, sizeof(w)); for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) &#123; if(i == j) continue ; P = p[i], Q = p[j], d = P.dis(Q), c = 0.0; if(P.id == Q.id) c = d * P.t; else c = d * (double)t; w[i][j] = w[j][i] = c; &#125;&#125; // 处理距离，注意初始化int main() &#123; int x1, y1, x2, y2, x3, y3, _t; point p1, p2, p3, p4; scanf("%d", &amp;_); while(_--) &#123; // 多组数据 scanf("%d%d%d%d", &amp;S, &amp;t, &amp;A, &amp;B); tot = 0; for(int i = 1; i &lt;= S; i++) &#123; scanf("%d%d%d%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;_t); p1.INIT(i, _t, x1, y1), p2.INIT(i, _t, x2, y2), p3.INIT(i, _t, x3, y3), p4.rct(p1, p2, p3); p[++tot] = p1, p[++tot] = p2, p[++tot] = p3, p[++tot] = p4; &#125; prework(); for(int k = 1; k &lt;= tot; k++) // 一开始把 k 套到最里面了。。 for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); ans = 0x7f7f7f7f; for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) if(p[i].id == A &amp;&amp; p[j].id == B) ans = min(ans, w[i][j]); printf("%.1lf\n", ans); // 只保留1位！ &#125; return 0;&#125;/*13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3*/]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「USACO15DEC」最大流]]></title>
    <url>%2F2019%2F02%2F23%2F%5BUSACO15DEC%5D%20%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \leq n \leq 50000,\ 1 \leq k \leq 100000$ 题目链接戳这里 Solution树链剖分模板题！没学过的戳这里 对于每次操作$u$，$v$，我们只需要执行一次树链剖分里最基本的修改操作：路径修改即可。 最后你再用基本操作$query$求一次区间点权最大值就A了啊！ 详见代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, k, tot, wson[MAXN], dep[MAXN], fa[MAXN], dfn[MAXN], pre[MAXN], size[MAXN], top[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存树 int left, right, Max, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, Max += x;&#125; inline void upd() &#123; Max = max(ls-&gt;Max, rs-&gt;Max);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[wson[u]] &lt; size[v]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u] &amp;&amp; v != wson[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;Max = 0; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(1); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right); else change(r-&gt;ls, left, r-&gt;ls-&gt;right), change(r-&gt;rs, r-&gt;rs-&gt;left, right); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 区间求 max r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;Max; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline void Qchange(int u, int v) &#123; // 路径点权加一 int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right);&#125;int main() &#123; int u, v; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(k--) &#123; scanf("%d%d", &amp;u, &amp;v); Qchange(u, v); &#125; printf("%d\n", query(root, 1, n)); // 最后输出最大值 return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学公式]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[这里有一些重要的初高中数学公式，可供参考。 恒等变形$a^3 + b^3 = (a + b)(a^2 - ab + b)$ $a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$ $2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \geqslant 0$ $(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$ $(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$ $(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$ $(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$ $(a_1^2 + a_2^2 + a_3^2 + \cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \cdots + b_n^2) \geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \cdots + a_nb_n)^2$ —— $Cauchy$不等式 $(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$ 几何定理斯特瓦尔特定理 $BD \cdot AC^2 + DC \cdot AB^2 = BC \cdot AD^2 + BD \cdot DC \cdot BC$ 推论：中线长公式$AD = \frac{1}{2} \sqrt{2(AB^2 + AC^2) - BC^2}$ 欧拉线 $\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。 九点圆 在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。 西姆松线 过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。 史坦纳定理 $H$ 为$\triangle ABC$ 垂心，$D$为$\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\triangle ABC$的西姆松线通过线段$DH$的中点。 三角函数定义$\cot\alpha = \frac{1}{\tan\alpha} \qquad \sec\alpha = \frac{1}{\cos\alpha} \qquad \csc\alpha = \frac{1}{\sin\alpha}$ 诱导公式$\sin ( \pi + \alpha) =- \sin \alpha \qquad \cos(\pi + \alpha) = -\cos \alpha \qquad \tan (\pi + \alpha) = \tan \alpha$ $\sin (-\alpha) = -\sin\alpha \qquad \cos (-\alpha) = \cos\alpha \qquad \tan(-\alpha) = -\tan\alpha$ $\sin (\pi - \alpha) = \sin \alpha \qquad \cos (\pi - \alpha) = -\cos\alpha \qquad \tan(\pi - \alpha) = -\tan\alpha$ $\sin(2\pi - \alpha) = -\sin\alpha \qquad \cos(2\pi - \alpha) = \cos\alpha \qquad \tan(2\pi - \alpha) = -\tan\alpha$ $\sin (\frac{\pi}{2} + \alpha) = \cos\alpha \qquad \sin(\frac{\pi}{2} - \alpha) = \cos\alpha$ $\cos(\frac{\pi}{2} + \alpha) = -\sin\alpha \qquad \cos(\frac{\pi}{2} - \alpha) = \sin\alpha$ $\tan(\frac{\pi}{2} + \alpha) = -\cot\alpha \qquad \tan(\frac{\pi}{2} - \alpha) = \cot\alpha$ $\tan(\frac{\pi}{4} + \alpha) = \frac{1 + \tan\alpha}{1 - \tan\alpha}$ 推论 $(\sin\frac{\alpha}{2} \pm \cos\frac{\alpha}{2})^2 = 1 \pm \sin\alpha$ 两角和（差）公式$\sin(\alpha \pm \beta) = \sin\alpha\cos\beta \pm \cos\alpha\sin\beta$ $\cos(\alpha \pm \beta) = \cos\alpha\cos\beta \mp \sin\alpha\sin\beta$ $\tan(\alpha \pm \beta) = \frac{\tan\alpha \pm \tan\beta}{1 \mp \tan\alpha\tan\beta}$ 二倍角公式$\sin 2\alpha = 2\sin\alpha\cos\alpha$ $\cos2\alpha = 2\cos^2\alpha - 1 = 1 - 2\sin^2\alpha = \frac{1-\tan^2\alpha}{1+\tan^2\alpha}$ $\tan2\alpha = \frac{2\tan\alpha}{1-\tan^2\alpha}$ 三倍角公式$\sin(3\alpha) = 3\sin\alpha - 4\sin^3\alpha \qquad \cos(3\alpha) = 4\cos ^ 3\alpha - 3\cos\alpha$ 降幂公式$\sin^2\alpha = \frac{1 - \cos2\alpha}{2} \qquad \cos^2\alpha = \frac{1 + \cos2\alpha}{2} \qquad \tan^2\alpha = \frac{1 - \cos2\alpha}{1 + \cos2\alpha}$ 辅助角公式$a\sin x + b\cos x = \sqrt{a^2 + b^2}(\frac{a\sin x}{\sqrt{a^2 + b^2}} + \frac{b\cos x}{\sqrt{a^2 + b^2}})$ 或 $a\sin x + b\cos x = \sqrt{a^2 + b^2}\sin(x + \varphi)$，其中 $\sin\varphi = \frac{b}{\sqrt{a ^ 2 + b ^ 2}},\ \cos\varphi = \frac{a}{\sqrt{a^2 + b^2}}$ 万能公式$\sin\alpha = \frac{2\tan\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$ $\cos\alpha = \frac{1 - \tan^2\frac{\alpha}{2}}{1 + \tan^2\frac{\alpha}{2}}$ $\tan\alpha = \frac{2\tan\frac{\alpha}{2}}{1 - \tan^2\frac{\alpha}{2}}$ 和差化积$\sin\alpha \pm \sin\beta = 2\sin\frac{\alpha \pm \beta}{2}\cos\frac{\alpha \mp \beta}{2}$ $\cos\alpha + \cos\beta = 2\cos\frac{\alpha + \beta}{2}\cos\frac{\alpha - \beta}{2}$ $\cos\alpha - \cos\beta = -2\sin\frac{\alpha + \beta}{2}\sin\frac{\alpha - \beta}{2}$ $\tan\alpha \pm \tan\beta = \frac{\sin(\alpha \pm \beta)}{\cos\alpha\cos\beta}$ 积化和差$\sin\alpha\cos\beta = \frac{1}{2}(\sin(\alpha + \beta) + \sin(\alpha - \beta))$ $\cos\alpha\sin\beta = \frac{1}{2}(\sin(\alpha + \beta) - \sin(\alpha - \beta))$ $\cos\alpha\cos\beta = \frac{1}{2}(\cos(\alpha +\beta) + \cos(\alpha - \beta))$ $\sin\alpha\sin\beta = -\frac{1}{2}(\cos(\alpha + \beta) - \cos(\alpha - \beta))$]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>公式</tag>
        <tag>三角函数</tag>
        <tag>代数</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分详解]]></title>
    <url>%2F2019%2F02%2F02%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u$到$v$的权值都加$d$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。 前置技能：线段树（重要） &amp; 倍增求 $LCA$（不必须） Definition &amp; Steps 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。 首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念： $size_i$：以$i$为根的子树中结点个数 $dfn_i$：$i$结点的$dfs$序，即其新编号 $pre_i$：$dfn$的反函数，若$dfn_i\ =\ j$，则$pre_j\ =\ i$，即$dfn_{pre_i}\ =\ 1$。 $fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号） $dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\ =\ 1$ $w_i$：$i$结点的权值 重儿子：一个结点所有子结点中$size$最大的子节点，用$wson[i]$表示 轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点 重边：一个结点和它的重儿子的连边 轻边：一个节点和它的轻儿子的连边 重链：由多条重边首尾顺次连接而成的链（路径） 轻链：有多条轻边首尾顺次连接而成的链（路径） $top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上） 上一张百度百科的图： 如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可； 同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$ 递归伪代码如下： 123456789void dfs1(int u, int f) // u 当前结点，f 是 u 的父亲结点 size[u] = 1 for each v that connects to u : // u 的子结点 if(v != f) // v 不是 u 的父亲 fa[v] = u // 说明 v 是 u 的子结点 dep[v] = dep[u] + 1 // 深度维护 dfs(v, u) // 继续递归 size[u] += size[v] // 将子树的 size 加到这棵树的 size 上 if(size[wson[u]] &lt; size[v]) wson[u] = v // 更新重儿子 可以手动模拟一下 这样，我们就求出了每个结点的重儿子 $wson$ ； 特别地，每个叶子结点的重儿子都为 $0$ 每个标红点的结点都是一条重链的链首（$top$）， 而加粗的边则是重链。 比如，$1=&gt;4=&gt;9=&gt;13=&gt;14$ 就是一条重链，而 $2=&gt;6=&gt;11$ 也是另一条重链； 另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子， 例如 $top[3]\ =\ 3$； 回顾一下，还有哪些信息没有维护呢？ $dfn,\ pre,\ top$ 其实，这三个只需要另一个递归函数就足够啦！ 12345678void dfs2(int u, int tp) // u 是当前结点，tp 是 u 所在重链的链首 top[u] = tp dfn[u] = ++tot // tot 是时间戳 pre[tot] = u // pre 是 dfn 的反函数 if(wson[u]) dfs2(wson[u], tp); // 只要 u 有重儿子，那就可以继续下去 for each v that connects to u : if(v != fa[u] &amp;&amp; v != wson[u]) // v 是 u 的轻儿子 dfs2(v, v); // 轻儿子是重链的链首 图中边上的数字就是 $dfs2$ 递归地顺序，不明白的可以参考一下。 检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？ $Answer:\ 10,\ 8$。 好了，树链剖分阶段到此结束。 将这棵树剖分成了许多链，现在就可以用线段树维护了~ 写上了一段带修改查询的线段树模板。。。 现在轮到处理问题的阶段了。 为了便于理解，我们就先实现两个最基础的操作吧： 路径点权求和、路径点权修改 大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。 举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。） 为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。 这个和倍增求 $LCA$ 有点像。 先找到 $dep$ 更深的结点，$11$（$dep[11]\ &gt;\ dep[9]$） 将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和 我们可以用事先维护好的 $dfn$ 来帮助 由于 $top[11]\ =\ 2$，所以我们在求 $2=&gt;11$ 的和 我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！ 线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$ res += query(root, dfn[top[11]], dfn[11]) 这是，操作变成了求 $res\ +\ 9=&gt;11$ 的路径点权和。 所以我们将 $11$ 变为 $fa[top[11]]\ =\ 1$ 这是，我们发现 $1$ 和 $9$ 共链了。 所以像刚才一样， res += query(root, dfn[1], dfn[9]) 即可！ 将上面的步骤转化成代码： 1234567891011void Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; // 只要不共链 if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); // 每次都要让 top 深一些的往上跳 res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); // 注意大小关系！ res += query(root, left, right); return res;&#125; 很简单吧！ 修改操作类似， 12345678910vois Qchange(int u, int v, int d) &#123; // u 到 v 的路径上点权加 d int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];int dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存线段树 int left, right, s, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[wson[u]]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; // 线段树模板 r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = w[pre[left]]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; // 线段树模板 if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 线段树模板 r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return query(r-&gt;ls, left, r-&gt;ls-&gt;right) + query(r-&gt;rs, r-&gt;rs-&gt;left, right);&#125;inline int Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); res += query(root, left, right); return res;&#125;inline void Qchange(int u, int v, int d) &#123; int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125;int main() &#123; int op, u, v, d; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); // 读入点权 for(int i = 1; i &lt; n; i++) &#123; // 读图 scanf("%d%d", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; // 这步不能忘，否则 dfs1 没用！ dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(m--) &#123; // 操作 scanf("%d%d%d", &amp;op, &amp;u, &amp;v); if(op == 1) printf("%d\n", Qsum(u, v)); else &#123; scanf("%d", &amp;d); Qchange(u, v, d); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ5165」树上倍增]]></title>
    <url>%2F2019%2F02%2F02%2F%5BBZOJ5165%5D%20%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\leq 3 \times 10^6$ ，操作次数 $m \leq 10^3$，$k \leq 10^3$ 题目链接： BZOJ P5165 Solution思路题目名称已经给了好嘛。。。 就是倍增啊。。 其实这题的难点不是在于思路想法，而是在于卡空间！ 操作1 $A \ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1$。 维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$ 具体的维护方法见下面的代码 1234567dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = 1st[i][j] = k 代表 编号为i的节点向上跳2 ^ j个点到编号为k的节点因此st[i][0]即为节点i的父亲dep[++n] = dep[x] + 1; // 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号for(int i = 20; i &gt;= 0; i--) // 2 ^ 21 &gt; 3e6，因此只需维护到20即可 st[n][i] = st[st[n][i - 1]][i - 1]; // 倍增数组标准维护语句 操作2 $Q \ k\ p1\ p2\ p3\ …$ 查询$p1,\ p2,\ p3\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。 这个我想没什么好讲的吧。 就是依次求$LCA$就行啦。如果不懂详见代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 3000003int n = 1, m, dep[MAXN], st[MAXN][21], P;char ch[2]; // 读入操作用，char可能会咕掉inline void insert(int x) &#123; // 新建节点操作，上文讲过 dep[++n] = dep[x] + 1, st[n][0] = x; for(register int i = 1; i &lt;= 20; i++) st[n][i] = st[st[n][i - 1]][i - 1];&#125;inline int LCA(int u, int v) &#123; // 基本的LCA操作，不解释 if(dep[u] &gt; dep[v]) swap(u, v); for(register int i = 20; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(register int i = 20; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return st[u][0];&#125;int main() &#123; int k, lca; dep[1] = 1; // 将root的深度设为1 scanf("%d", &amp;m); while(m--) &#123; scanf("%s%d", ch, &amp;k); if(ch[0] == 'A') insert(k); else &#123; scanf("%d", &amp;lca); //依次求LCA for(register int i = 1; i &lt; k; i++) scanf("%d", &amp;P), lca = LCA(lca, P); printf("%d\n", lca); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速读入详解]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 常数 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\overline{abcd} = 10 \times (10 \times (10 \times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \times |n|$，其中$sgn(x)$为$x$的符号。]]></content>
      <categories>
        <category>OI</category>
        <category>其它</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈二分]]></title>
    <url>%2F2019%2F01%2F27%2F%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \in \mathbb{Z}$，即整数$mid = \lfloor \dfrac{a + b}{2} \rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 $L = 0, R = 4, mid = \lfloor \dfrac{0 + 4}{2} \rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \lfloor \dfrac{0 + 2}{2} \rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \lfloor \dfrac{L + R}{2} \rfloor = 50$，设答案为$ans$。 只要$L \leqslant R$，尝试$mid$，\left\{ \begin{aligned} & 若mid > ans，则R = mid； \\ & 若mid < ans，则L = mid + 1； \\ & 若mid = ans，猜对了。 \end{aligned} \right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf("%d\n", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf("%d\n", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……]]></content>
      <categories>
        <category>OI</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「luogu1462」通往奥格瑞玛的道路]]></title>
    <url>%2F2019%2F01%2F27%2F%5Bluogu1462%5D%20%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Description$n$个点$m$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b$短，并且经过的点权之和最大。 输出这个最大值 看完题面感觉语文要挂科。。。o(╥﹏╥)o Solution这题正解 $SPFA\ +$ 二分 二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts("AFK"); else printf("%d\n", left); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>SPFA</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CQOI2009」中位数]]></title>
    <url>%2F2019%2F01%2F27%2F%5BCQOI2009%5D%20%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \leq 100000,\ 1 \leq b \leq n$。 题目传送门Solution标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf("%d%d",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf("%d",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf("%d\n",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集入门]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts("-1"); return 0; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>OI</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_U51fhF2DWG.html</url>
    <content type="text"><![CDATA[U51fhF2DWG]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_o1tQMBIJO5.html</url>
    <content type="text"><![CDATA[o1tQMBIJO5]]></content>
  </entry>
  <entry>
    <title><![CDATA[404 Not Found]]></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[**404 Not Found** **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[这是一个弱鸡 OIer 瞎搞出来的一个博客~]]></content>
  </entry>
  <entry>
    <title><![CDATA[所有分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[我的朋友们]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[欢迎互换友链！ 如需友链请说明备注名、链接地址与背景颜色和字体颜色的十六进制表示。 常用网站网址洛谷 | BZOJ | Graph Editor | 图床 | OIerDb | BZOJ离线题库 | DarkBzoj]]></content>
  </entry>
  <entry>
    <title><![CDATA[搜索]]></title>
    <url>%2Fsearch%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[所有标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
