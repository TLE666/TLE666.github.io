[{"title":"「USACO07MAR」Gold Balanced Lineup","date":"2019-11-13T13:54:18.000Z","path":"2019/11/13/[USACO07MAR] Gold Balanced Lineup/","text":"Description有 $n$ 天， $m$ 种能力。每天都对应着一个给定的二进制数，第 $i$ 位是 $1$ 代表第 $i$ 种能力提升 $1$ 次。否则不提升。如果在连续的一段时间内，每项能力都提升了相同的次数，就称这段时间为一个均衡时期。求均衡时期的最大长度。 对于 $100 \\%$ 的数据，有 $n \\leq 10^5,m \\leq 30$ 题目链接戳这里 Solution我们发现 $m$ 不大，于是考虑一次对每个能力算出前缀和。设第 $i$ 天所有 $m$ 个能力所构成的序列为 $S_i$ ，则一个从第 $l$ 天到第 $r$ 天的均衡时期肯定满足 $S_{l - 1}$ 和 $S_r$ 对应每项的差相同。比如 $\\texttt{[1, 3, 2, 4]}$ 和 $\\texttt{[3, 5, 4, 6]}$ 由此，我们能够想到哈希。 我们希望给出一种对应法则使所有 对应每项的差相同 的序列都对应成一个哈希值。因为满足这个条件的序列之间一定是一个均衡时期。例如 $\\texttt{[2, 1, 4, 0]}$ ， $\\texttt{[4, 3, 6, 2]}$ ， 和 $\\texttt{[5, 4, 7, 3]}$ 这三个序列应该对应同一种。 由于 $m$ 很小，可以直接把整个序列加上或减去一个数 $d$ ，使得序列的第一个数为 $0$ ，也就是把整个序列同时减去第一个数。比如把 $\\texttt{[2, 1, 4, 0]}$ 全部减二，变为 $\\texttt{[0, -1, 2, -2]}$ 。（负数也无妨，毕竟哈希跟正负无关） 现在，只需求出依次累积的能力即可。 对于每一次哈希的值： 若没有出现过，则把当前时间（天数）记录到一个数组中。 若出现过，即当前哈希值对应的数组已经有值，则说明 当前 与 数组中记录的时间 这两者间是一个均衡时期。更新答案即可。 特别提醒：如果经过操作（即全序列减去第一个数）后得到全 0 序列，则第 1 天到它也是一个均衡时期，因为第 0 天的序列也是全 0 序列。 （感谢 $\\text{wzj dalao}$ 的帮助） 例如第 $5$ 天时序列为 $\\texttt{[3, 3, 3, 3]}$ ，则对应着 $\\texttt{[0, 0, 0, 0]}$ 序列，说明和第 $0$ 天之后一天（第 $1$ 天）构成了一个均衡时期。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)typedef long long ll;const int N = 1e5 + 100;const int bas = 29;const int mod = 998244353;const int bs2 = 19;const int md2 = 19260817;const int bs3 = 101;const int md3 = 9291433;const int bs4 = 67;const int md4 = 1e9 + 7;int n, m, a[N], b[N], ans;unordered_map &lt;ll, int&gt; mp; // 哈希和时间的对应ll Hash() &#123; // 多重哈希，以防被卡 ll num = 1, res = 0; rep(i, 1, m) &#123; res += b[i] * num; res %= mod; num *= bas; &#125; ll rs2 = 0; num = 1; rep(i, 1, m) &#123; rs2 += b[i] * num; res %= md2; num *= bs2; &#125; ll rs3 = 0; num = 1; rep(i, 1, m) &#123; rs3 += b[i] * num; res %= md3; num *= bs3; &#125; return (res * bs4 * bs4 + rs2 * bs4 + rs3) % md4; // “哈希 套 哈希”&#125;void chg(int x) &#123; // 对应序列。把 b 数组对应成上述序列（即第一个数为 0 ） per(i, m - 1, 0) &#123; if (x &gt;= (1 &lt;&lt; i)) &#123; x -= (1 &lt;&lt; i); a[i + 1]++; &#125; &#125; b[1] = 0; rep(i, 2, m) b[i] = a[i] - a[1];&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); mp[0] = 0; rep(i, 1, n) &#123; int d; scanf(\"%d\", &amp;d); chg(d); ll tmp = Hash(); if (!mp.count(tmp)) mp[tmp] = i; // 记录第一次时间 else ans = max(ans, i - mp[tmp]); // 计算答案，更新答案 &#125; printf(\"%d\\n\", ans); return 0;&#125;","tags":[{"name":"哈希","slug":"哈希","permalink":"http://tle666.github.io/tags/哈希/"},{"name":"前缀和","slug":"前缀和","permalink":"http://tle666.github.io/tags/前缀和/"}]},{"title":"「POJ3971」Scales","date":"2019-08-12T06:25:02.000Z","path":"2019/08/12/[POJ3971] Scales/","text":"Description有一个物品重量为 $w$ ，现在你有 $1,2,4,\\cdots,2^{N - 1}$ 重量的砝码，问有多少种方法可以使天平平衡。 对于 $100 \\%$ 的数据，有 $N \\leq 10^6$ 题目链接戳这里 Solution要使天平平衡，我们设左边的砝码总重为 $x$ ，右边砝码总重为 $y$ 。则我们有 w + x = y其中 $x\\ \\text{AND}\\ y = 0$ （ $x\\ \\text{AND}\\ y$ 即 $x$ 与 $y$ ）。有这个限制的原因是因为一个重量的砝码只有一个，若 $x\\ \\text{AND}\\ y \\neq 0$ 则说明天平左右两边至少有一组相同砝码，与题意不符。 令 dp[i][0 / 1] 表示第 $i$ 位是否进位到第 $i - 1$ 位时的方案数。 显然当前位是否需要进位需要考虑到低位的进位情况，所以要从低位向高位 DP 。 现在讨论一下转移方程，假设当前算到了第 $i$ 位。 不明白的地方可以列竖式模拟一下，注意 $x\\ \\text{AND}\\ y = 0$ 这个条件。 若 $w_i = 0,\\ x_i = 0$ 则 dp[i][0] += dp[i + 1][0] + dp[i + 1][1] dp[i][1] += 0 若 $w_i = 0,\\ x_i = 1$ 则 dp[i][0] += 0 （如果不仅位 $x$ 和 $y$ 的这一位都是 1 了，与起来不为 0 ） dp[i][1] += dp[i + 1][1] 若 $w_i = 1,\\ x_i = 0$ 则 dp[i][0] += dp[i + 1][0] dp[i][1] += dp[i + 1][1] 若 $w_i = 1,\\ x_i = 1$ 则 dp[i][0] = 0 dp[i][1] = dp[i + 1][0] （注意与的条件，同上） 最后把 $w_i$ 相等的情况合并一下就行啦（见代码）。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define trv(p, u) for (edg *p = h[u]; p; p = p-&gt;nxt)typedef long long ll;typedef double db;const int N = 1e6 + 100;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;inline int rd() &#123; int s = 0, w = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') &#123; if (c == '-') w = -1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') s = s * 10 + c - '0', c = getchar(); return s * w;&#125;int T, n, l, d, dp[N][2];bool w[N];char s[N];int main() &#123; T = rd(); while (T--) &#123; n = rd(), l = rd(), d = rd(); rep(i, 0, n) dp[i][0] = dp[i][1] = 0; // 清空 scanf(\"%s\", s); rep(i, 0, n - l - 1) w[i] = 0; // 补全 重量 和 最大砝码 二进制表示下的长度差 // 比如样例的 case 1: 将 1000 补成 001000 与 n 相等 rep(i, n - l, n - 1) w[i] = s[i - (n - l)] - '0'; dp[n][0] = 1, dp[n][1] = 0; per(i, n - 1, 0) &#123; // n - 1 是最低位 “个位” if (w[i] == 0) &#123; // 合并情况 dp[i][0] = (dp[i + 1][0] + dp[i + 1][1]) % d; // 注意取模 dp[i][1] = dp[i + 1][1] % d; &#125; if (w[i] == 1) &#123; // 合并情况 dp[i][0] = dp[i + 1][0] % d; dp[i][1] = (dp[i + 1][0] + dp[i + 1][1]) % d; &#125; &#125; printf(\"%d\\n\", dp[0][0]); // 注意答案不能进位 &#125; return 0;&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"数位DP","slug":"数位DP","permalink":"http://tle666.github.io/tags/数位DP/"}]},{"title":"莫比乌斯反演","date":"2019-08-09T12:30:32.000Z","path":"2019/08/09/莫比乌斯反演/","text":"已知一个函数 $F(n) = \\sum_{d | n} f(d)$ ，我们怎么用 $F$ 去表示 $f$ 呢？ 积性函数定义$\\forall a,b \\in \\mathbb{Z}$ 且 $\\gcd(a,b) = 1$ ，若数论函数 $f(x)$ 满足 $f(ab) = f(a) \\cdot f(b)$ ，则 $f(x)$ 为积性函数。 特别地， $\\forall a,b \\in \\mathbb{Z}$ ，若数论函数 $f(x)$ 满足 $f(ab) = f(a) \\cdot f(b)$ ，则 $f(x)$ 为完全积性函数。 例子$\\varphi(x) = x \\prod _{i = 1}^{n} (1- \\frac{1}{p_i})$ $d(x) = \\sum_{a|x} 1$ $\\sigma(x) = \\sum_{a | x} a$ $id(x) = x$ $e(x) = [x = 1]$ （即 $e(x) = 1 \\Leftrightarrow x = 1$ 否则 $e(x) = 0$） $1(x) = 1$ $\\mu(x)$ （莫比乌斯函数） 狄利克雷卷积定义两个数论函数的卷积 $h$ ：$h = f * g$ 则 $h(x) = \\sum_{d | x}f(d) \\cdot g(\\frac{x}{d})$ 性质f * g = g * fa * b * c = a * (b * c)若 $f,g$ 为积性函数，则 $h = f * g$ 也是积性函数。 $f * e = f$ （ $e$ 前面提到的数论函数） 莫比乌斯函数定义$\\mu(n) = (-1)^k \\Leftrightarrow n = \\prod _{i = 1}^{k} p_i$ （即没有平方因子） 特别地，$\\mu(1) = (-1)^0 = 1$ $\\mu(n) = 0$ 若 $n$ 有平方因子 性质$\\mu * 1 = e$ 证明： \\mu * 1 = \\sum_{d | n} \\mu(d) * 1(\\frac{n}{d}) = \\sum_{d | n} \\mu(d)当 $n = 1$ 时显然 $(\\mu * 1)(1) = e(1) = 1$ 当 $n \\neq 1$ 时， 设 $n = p_1^{\\alpha_1} \\cdot p_2^{\\alpha_2} \\cdots p_m^{\\alpha_m}$ ， $d = p_1^{x_1} \\cdot p_2 ^ {x _ 2} \\cdots p_m^{x_m}$ 根据 $\\mu$ 的定义，我们只需要考虑 $x_i \\leq 1$ 的情况。 我们设 $d$ 中存在 $k$ 个 $x_i$ 为 1，那么有 \\sum_{d\\mid n}\\mu(d) = \\sum_{r = 0}^m\\binom m r(-1)^r(n \\neq 1)根据二项式定理，$(x+y)^{n}=\\sum _{k=0}^{n}\\binom n kx^{n-k}y^{k}$ 令 $x = 1,\\ y = -1$ 则 \\sum_{r = 0}^m\\binom m r(-1)^r = (1 - 1)^m = 0(n \\neq 1)所以 $\\mu * 1 = \\sum_{d | n} \\mu(d) = e$ 证毕。 莫比乌斯反演若 $F(n) = \\sum_{d | n} f(d)$ ，则 $f(n) = \\sum_{d | n} \\mu(d) * F(\\frac{n}{d})$ 证明： F = f * 1\\Leftrightarrow F * \\mu = (f * 1) * \\mu = f * (1 * \\mu)\\Leftrightarrow F * \\mu = f * e\\Leftrightarrow F * \\mu = f证毕。 小例题「国家集训队」Crash 的数字表格 / JZPTAB 「HAOI2011」Problem b 「SDOI2014」数表","tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://tle666.github.io/tags/莫比乌斯反演/"}]},{"title":"「国家集训队」种树","date":"2019-07-23T14:45:02.000Z","path":"2019/07/23/[国家集训队] 种树/","text":"Description一个圆环上有 $n$ 个点，每个点都有美观度，要取 $m$ 个点使它们不相邻且总美观度最大。 对于 $100 \\%$ 的数据，有 $n \\leq 200000,m \\leq n$ 题目链接戳这里 Solution十分神奇的贪心。。 首先先种上美观度最大的一棵，然后将其左右两棵合并到中间，且其美观度为 $val_l + val_r - val_i$ 。 其中 $val_x$ 是 $x$ 的美观度，$i$ 是美观度最大的那棵， $l,r$ 分别是其左边和右边的两棵。 这中操作其实就是一种反悔机制：如果后来发现一开始选 $i$ 左边和右边的收益更大，那其实加上 $val_l + val_r - val_i$ 后就能把一开始的 $val_i$ 抵消掉，也就是 $val_i + (val_l + val_r - val_i) = val_l + val_r$ 。这时就相当于把一开始不好的 $i$ 替换成更好的 $l,r$ 。 但如果 $i$ 更好，那么后来也就选不上 $l$ 和 $r$ 了，因为每步都会有个排序。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200200;int n, m, ans; bool vis[N];struct pos &#123; int val, l, r; &#125; p[N];struct node &#123; int val, id; inline bool operator &lt; (const node &amp;rhs) const &#123; return val &lt; rhs.val; &#125;&#125; ;priority_queue &lt;node&gt; Q;inline void del(int x) &#123; p[x].l = p[p[x].l].l, p[x].r = p[p[x].r].r; p[p[x].l].r = x, p[p[x].r].l = x;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); if ((m &lt;&lt; 1) &gt; n) &#123; puts(\"Error!\"); return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;p[i].val); p[i].l = i - 1, p[i].r = i + 1; Q.push((node) &#123;p[i].val, i&#125;); &#125; p[1].l = n, p[n].r = 1; while (m--) &#123; while (vis[Q.top().id]) Q.pop(); node cur = Q.top(); Q.pop(); ans += cur.val, vis[p[cur.id].l] = vis[p[cur.id].r] = true; p[cur.id].val = p[p[cur.id].l].val + p[p[cur.id].r].val - p[cur.id].val; Q.push((node) &#123;p[cur.id].val, cur.id&#125;); del(cur.id); &#125; printf(\"%d\\n\", ans); return 0;&#125;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tle666.github.io/tags/贪心/"}]},{"title":"「BZOJ3850」ZCC Loves Codefires","date":"2019-07-23T13:36:07.000Z","path":"2019/07/23/[BZOJ3850] ZCC Loves Codefires/","text":"Description有 $n$ 道题，每道题有两个参数 $E,\\ K$ ；需要 $E$ 时间来做完这道题，而在 $T$ 时间完成这道题时，会损失 $K \\times T$ 分。要给这 $n$ 道题排个做题顺序，使得最后总损失的分数最少。 对于 $100 \\%$ 的数据，有 $n \\leq 10^5;\\ E,K \\leq 10^4$ 。 题目链接戳这里 Solution其实这纯是一道推式子的题…… 我们考虑如果交换 $i,j$ 两题的顺序会发生什么。 令 $S_i$ 表示在 $i$ 前面做（不包括 $i$ ）的所有题所需的总时间。 若 $i$ 在 $j$ 前面做时两题总损失分数： (S_i + E_i) \\times K_i + (S_i + E_i + E_{j}) \\times K_j\\Leftrightarrow S_i \\times (K_i + K_j) + E_i \\times K_i + E_j \\times K_j + E_i \\times K_j若 $j$ 在 $i$ 前面做时两题总损失分数： (S_j + E_j) \\times K_j + (S_j + E_j + E_i) \\times K_i而由于 $i$ 和 $j$ 只是交换了位置，所以 $S_j = S_i$ ； \\Leftrightarrow S_i \\times (K_i + K_j) + E_i \\times K_i + E_j \\times K_j + E_j \\times K_i对比两式可发现，我们只需判断 $E_i \\times K_j$ 与 $E_j \\times K_i$ 的大小关系即可。 所以只需将题目按照上述排序。 最后答案就用定义 $O(n)$ 算一遍就行了。 注意开 long long Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100100;#define int long longint n, ans;struct node &#123; int e, k; inline bool operator &lt; (const node &amp;rhs) const &#123; return e * rhs.k &lt; rhs.e * k; &#125;&#125; a[N];signed main() &#123; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i].e); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i].k); sort(a + 1, a + n + 1); int s = 0; for (int i = 1; i &lt;= n; i++) ans += (s += a[i].e) * a[i].k; printf(\"%lld\\n\", ans); return 0;&#125; Submission由于这是一道权限题，在这里提供一下数据（好像只有一组但超大） 一组数据","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tle666.github.io/tags/贪心/"}]},{"title":"「HEOI2014」南园满地堆轻絮","date":"2019-07-23T11:29:30.000Z","path":"2019/07/23/[HEOI2014] 南园满地堆轻絮/","text":"Description对于一个正整数数列 $A_1 \\cdots A_n$ ，求另一个正整数数列 $B_1 \\cdots B_n$ ，使得对于任意的 $1 \\leq i &lt; n$ 有 $B_i \\leq B_{i + 1}$ ，而且使得 $ans = \\max\\{|A_j - B_j|,\\ 1 \\leq j \\leq n\\}$ 尽量小。 定义生成函数 $F(x) = S_a \\times x^3 + S_b \\times x^2 + S_c \\times x + S_d$ ，则数列 $A$ 的递推公式为 $A_i = (F(A_{i - 1}) + F(A_{i - 2})) \\% mod$ 对于 $100\\%$ 的数据，有 $n \\leq 5000000,\\ S_a,S_b,S_c,S_d,A_1 \\leq 10000,\\ mod \\leq 1000000007$ 题目链接戳这里 Solution由于时让 $ans$ 中的最大值最小，所以很容易能想到二分答案。假设现在的答案为 $k$ ，则对于所有的 $i$ 满足 $1 \\leq i \\leq n$ ，都有 $|A_i - B_i| \\leq k$ 。也就是说， A_i - k \\leq B_i \\leq A_i + k因此我们只需每次都贪心使 $B_i$ 尽可能小即可。而如果 $B_i$ 再怎么大也大不到 $B_{i - 1}$ 时，那就说明 $k$ 不行啦！ 注意对 F 函数频繁取模！！！ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5000500;#define int long longint n, s[5], a[N], mod, ans, b[N];inline int F(const int &amp;x) &#123; int res = 0; (res += s[1] * x % mod * x % mod * x % mod) %= mod, (res += s[2] * x % mod * x % mod) %= mod, (res += s[3] * x % mod) %= mod, (res += s[4] % mod) %= mod; return (res + mod) % mod;&#125;inline bool chk(int k) &#123; b[1] = a[1] - k; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] &gt;= b[i - 1]) b[i] = max(a[i] - k, b[i - 1]); else &#123; if (b[i - 1] - a[i] &gt; k) return false; b[i] = b[i - 1]; &#125; &#125; return true;&#125;signed main() &#123; scanf(\"%lld%lld%lld%lld%lld%lld%lld\", &amp;n, &amp;s[1], &amp;s[2], &amp;s[3], &amp;s[4], &amp;a[1], &amp;mod); for (int i = 2; i &lt;= n; i++) a[i] = (F(a[i - 1]) + F(a[i - 2])) % mod; int l = 0, r = mod; // 要取模，所以 r 最大也超不过 mod while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (chk(mid)) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf(\"%lld\\n\", l % mod); return 0;&#125;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tle666.github.io/tags/贪心/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"}]},{"title":"「USACO10MAR」Great Cow Gathering","date":"2019-07-22T14:03:33.000Z","path":"2019/07/22/[USACO10MAR] Great Cow Gathering/","text":"Description给一个带边权与点权的树 $T$ （ $N$ 个结点 ），找一个点 $x$ 使 $\\sum_{u \\in T\\ \\&amp;\\ u \\neq x} dis_{u,x} \\times c_u$ 取最大值。 对于 $100\\%$ 的数据，有 $1 \\leq N \\leq 100000,\\ 1 \\leq C_i \\leq 1000$ 。 题目链接戳这里 Solution树形 DP 。其实也不能完全算是 DP 。 我们使用调整法。对于点 $1$ ，我们可以 $O(n)$ 地算出 $f_1 = \\sum_{u \\in T\\ \\&amp;\\ u \\neq 1} dis_{u,1} \\times C_u$ 然后递归考虑 $1$ 的儿子结点 $u$ 。我们比较一下 $f_1$ 和 $f_u$ 。可以将这棵树分为两部分。其中一部分（ $up$ ）与点 $1$ 在点 $u$ 的同一边，而另一部分（ $dn$ ）则与点 $u$ 在点 $1$ 同一边。当我们的注意力从 $1$ 转到 $u$ 上时，我们发现 $f$ 的值发生了一些变化。对于 $up$ 那部分的所有点，它们都被加上了一段路程 $dis_{1,u}$ ；而对于 $dn$ 那部分的所有点，它们都减去了 $dis_{1, u}$ 。 题目中的样例 举个例子。对于图上的 $3$ ，我们发现 $f_3 = 1\\times 1 + 1 \\times 2 + 2 \\times 6 = 15$ 。把它分成 $up$ 和 $dn$ ， $up = 3,\\ dn = 12$ 。同理对于 $4$ ， $up = up_3 + 3 \\times (1 + 1) = 9,\\ dn = dn_3 - 3 \\times 2 = 6$ 。 结果，我们发现 $up$ 和 $dn$ 都与前面有关系，所以只用记变化值就行啦。 注意开 long long 。。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100100;#define int long longint n, c[N], f[N], up[N], dn[N], size[N], ans = 1e18;// f up dn 如上文；size[u] 以 u 为根的子树大小（此处指子树中 c[i] 之和）struct edge &#123; int v, w; edge *next; &#125; pool[N &lt;&lt; 1], *h[N], *cur = pool;inline void addedge(int u, int v, int w) &#123; edge *p = ++cur, *q = ++cur; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline int calc(int u, int dis, int fa) &#123; // 求 f[1] int v, res = c[u] * dis; for (edge *p = h[u]; p; p = p-&gt;next) if ((v = p-&gt;v) != fa) &#123; res += calc(v, dis + p-&gt;w, u); &#125; return res;&#125;inline void pre(int u, int fa) &#123; // 求 size int v; size[u] = c[u]; for (edge *p = h[u]; p; p = p-&gt;next) if ((v = p-&gt;v) != fa) &#123; pre(v, u); size[u] += size[v]; &#125;&#125;inline void dfs(int u, int fa) &#123; // 求 f int v; for (edge *p = h[u]; p; p = p-&gt;next) if ((v = p-&gt;v) != fa) &#123; up[v] = (size[1] - size[v]) * p-&gt;w; dn[v] = -size[v] * p-&gt;w; f[v] = f[u] + up[v] + dn[v]; // 记得 up 和 dn 只是相对 u 的变化值 dfs(v, u); &#125;&#125;signed main() &#123; int u, v, w; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; pre(1, 0); f[1] = calc(1, 0, 0); dfs(1, 0); for (int i = 1; i &lt;= n; i++) ans = min(ans, f[i]); printf(\"%lld\\n\", ans); return 0;&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://tle666.github.io/tags/树形DP/"}]},{"title":"「AtCoder Grand Contest 025 B」RGB Coloring","date":"2019-07-20T11:12:41.000Z","path":"2019/07/20/[AtCoder Grand Contest 025 B] RGB Coloring/","text":"Description一个 n 层塔，每层可以不涂颜色或涂红绿蓝三种颜色之一。不涂颜色美观度 $0$ ，涂红色美观度 $A$ ，涂绿色美观度 $A + B$ ，涂蓝色美观度 $B$ 。求使所有层的美观度之和 $=K$ 的涂色方案数 $\\pmod {998244353}$ 对于 $100 \\%$ 的数据， $1 \\leq N \\leq 3 \\times 10^5$ $1 \\leq A,B \\leq 3 \\times 10^5$ $0 \\leq K \\leq 18 \\times 10^{10}$ 题目链接戳这里 Solution好像不是特别难吧（雾 换一个角度想，我们从 $A$ 和 $B$ 处入手。对于 $A$ 和 $B$ ， 我们发现这两个数可以随便地放到任意一层中，即只需满足 $0 \\leq num_A,num_B \\leq N$ 即可，其中 $num_x$ 表示 $x$ 在塔中出现的次数。因此可以写成 Ax + By = K (0 \\leq x,y \\leq N)的形式。我们只需要 $O(N)$ 枚举 $x$ 的取值，再判断与之对应的 $y$ 是否是整数。一对 $x,y$ 对答案的贡献是 $C(n, x) \\times C(n, y)$ ，即 $\\binom{n}{x} \\times \\binom{n}{y}$ 。至于为什么呢，就是因为 $A$ 和 $B$ 两个数并不冲突 —— 可以同时放在一层中，可以独自一层，也可以一层两个都没有；所以 $x$ 个 $A$ 和 $y$ 个 $B$ 可以随便在 $n$ 层中分布。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 300300;const int mod = 998244353;#define int long long#define M(x) (((x) + mod) % mod)int n, a, b, k, c[N], inv[N], s[N], t[N], fac[N], ans, inv2[N];inline int qpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) (res *= a) %= mod; (a *= a) %= mod, b &gt;&gt;= 1; &#125; return res;&#125;inline void prework() &#123; fac[0] = s[0] = 1; inv[0] = 1; // 注意赋初值 for (int i = 1; i &lt;= n; i++) fac[i] = 1ll * fac[i - 1] * i % mod; // 阶乘 for (int i = 1; i &lt;= n; i++) s[i] = 1ll * s[i - 1] * fac[i] % mod; t[n] = qpow(s[n], mod - 2); // 前缀积 O(n + logP) 逆元求法 for (int i = n; i &gt;= 1; i--) t[i - 1] = 1ll * t[i] * fac[i] % mod; for (int i = 1; i &lt;= n; i++) inv[i] = 1ll * t[i] * s[i - 1] % mod;&#125;inline ll C(int M, int N) &#123; // C(M, N) if (N &lt; 0 || N &gt; M) return 0; return M(1ll * fac[M] * M(inv[N] * inv[M - N]));&#125;signed main() &#123; scanf(\"%lld%lld%lld%lld\", &amp;n, &amp;a, &amp;b, &amp;k); prework(); for (int x = 0, y; x &lt;= n; x++) // 枚举 x if ((k - a * x) % b == 0) &#123; // 判断 y 是不是整数 y = (k - a * x) / b; ans += M(1ll * C(n, x) * C(n, y)); // 贡献 &#125; printf(\"%lld\\n\", M(ans)); return 0;&#125;","tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://tle666.github.io/tags/组合数学/"},{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"http://tle666.github.io/tags/排列组合/"}]},{"title":"「BZOJ3884」上帝与集合的正确用法","date":"2019-07-18T14:03:50.000Z","path":"2019/07/18/[BZOJ3884] 上帝与集合的正确用法/","text":"Description求 2^{2^{2 \\cdots}} \\bmod p 对于 $100\\%$ 的数据，有数据组数 $T \\leq 1000$ ， $p \\leq 10^7$ 题目链接戳这里 Solution根据 扩展欧拉定理 ，即当 $b \\geq \\varphi (p)$ 时， a ^ b \\equiv a ^ {b \\bmod \\varphi(p) + \\varphi(p)} \\pmod{p}而当 $b &lt; \\varphi(p)$ 时， a^b \\equiv a ^ {b \\bmod \\varphi(p)} \\equiv a^b \\pmod{p}貌似没啥用？ 由于题目中的 $b$ 是 $2^{2 \\cdots}$ ，所以一定有 $b \\geq \\varphi(p)$，因此递归一下式子就做完了。 具体如下： 1234ll work(ll m) &#123; if (m == 1) return 0; // 带入算一下就能得出 0 return qpow(2, work(phi[m]) + phi[m], m); // 递归， qpow 是快速幂&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 10000100;ll T, P, p[700700], phi[N], cnt;bool vis[N];inline void prework() &#123; phi[1] = 1; for (int i = 2; i &lt;= 1e7; i++) &#123; if (!vis[i]) p[++cnt] = i, phi[i] = i - 1; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= 1e7; j++) &#123; vis[i * p[j]] = true; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break ; &#125; else phi[i * p[j]] = phi[i] * phi[p[j]]; &#125; &#125;&#125;inline ll qpow(ll a, ll b, ll mod) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) (res *= a) %= mod; (a *= a) %= mod, b &gt;&gt;= 1; &#125; return res;&#125;inline ll work(ll m) &#123; if (m == 1) return 0; return qpow(2, work(phi[m]) + phi[m], m);&#125;int main() &#123; prework(); scanf(\"%lld\", &amp;T); while (T--) &#123; scanf(\"%lld\", &amp;P); printf(\"%lld\\n\", (work(P) + P) % P); &#125; return 0;&#125; PS：我没有研究 long long 是否必要，只是保险罢了","tags":[{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://tle666.github.io/tags/欧拉函数/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"http://tle666.github.io/tags/欧拉定理/"}]},{"title":"最小表示法","date":"2019-07-14T12:13:27.000Z","path":"2019/07/14/最小表示法/","text":"有一个字符串，当我们要寻找一个位置，使其从这个位置向后形成一个新字符串，这个新字符串的字典序最小时，就能用到这个算法。 比如对于 $ABCD$ ，就有 $ABCD$ ， $BCDA$ ， $CDAB$ ， $DABC$ 这四种新字符串。 而最小的那个是 $ABCD$ 。 Operations令 i = 0, j = 1, k = 0 ，表示 从 i 开始 k 长度 和 从 j 开始 k 长度 的字符串相同 。 当 str[i] == str[j] 时，不难发现需要进行将 k++ 的操作； 当 str[i] &gt; str[j] 时，我们发现 i 位置比 j 位置字典序要大，因此不能以 i 作为开头了。所以要将 i 向后移动。而 i 开头和 j 开头都有 k 个相同字符，因此要将 i += (k + 1) ； 同理，当 str[i] &lt; str[j] 时， j += (k + 1) 。 最后 i 和 j 中较小的那个就是答案啦。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;char str[100100];inline int getmin() &#123; int n = strlen(str); int i = 0, j = 1, k = 0, t; while (i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n) &#123; t = str[(i + k) % n] - str[(j + k) % n]; // 通过 t 与 0 的大小关系来判断 if (!t) k++; else &#123; if (t &gt; 0) i += (k + 1); else j += (k + 1); if (i == j) j++; k = 0; &#125; &#125; return min(i, j);&#125;int main() &#123; scanf(\"%s\", str); printf(\"%d\\n\", getmin() + 1); // +1 是因为字符串从第零个开始，这样更容易分辨 return 0;&#125;","tags":[{"name":"字符串","slug":"字符串","permalink":"http://tle666.github.io/tags/字符串/"},{"name":"最小表示法","slug":"最小表示法","permalink":"http://tle666.github.io/tags/最小表示法/"}]},{"title":"「HNOI2003」消防局的设立","date":"2019-06-18T13:29:01.000Z","path":"2019/06/18/[HNOI2003] 消防局的设立/","text":"Description一棵 $n$ 个结点的树，问最少几个特殊点能覆盖满整个图。 其中，一个特殊点能覆盖与它距离不超过 2 的所有点。 对于 $100\\%$ 的数据，满足 $n \\leq 1000$ 题目链接戳这里 Solution就是个大贪心。。 每次找到深度最大的未覆盖的结点，并贪心地在它祖父结点处放个消防站（即特殊点）。由于前提，所以这个点的所有子结点全部都被覆盖了。因此放在祖父结点处最优。 那么如何判断这个点是否被覆盖了呢？问题在于兄弟结点。其实，可以用 dis 数组维护距离一个特殊点的最短距离；此时当 dis[fa] == 1 时，就能确定它被覆盖了。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;const int INF = 0x3f3f3f3f;int n, que[N], dep[N], fa[N], dis[N], ans;inline bool cmp(int x, int y) &#123; return dep[x] &gt; dep[y];&#125;inline void upd(int u) &#123; int f = fa[u], g = fa[f]; dis[u] = min(dis[u], min(dis[f] + 1, dis[g] + 2)); if (dis[u] &gt; 2) &#123; dis[g] = 0, ans++; dis[fa[g]] = min(dis[fa[g]], 1), dis[fa[fa[g]]] = min(dis[fa[fa[g]]], 2); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); dis[0] = INF; for (int i = 1; i &lt;= n; i++) dis[i] = INF, que[i] = i; for (int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;fa[i]); dep[i] = dep[fa[i]] + 1; que[i] = i; &#125; sort(que + 1, que + n + 1, cmp); // 按深度排序 for (int i = 1; i &lt;= n; i++) upd(que[i]); printf(\"%d\\n\", ans); return 0;&#125;","tags":[{"name":"贪心","slug":"贪心","permalink":"http://tle666.github.io/tags/贪心/"}]},{"title":"Coding Style","date":"2019-06-13T13:11:46.000Z","path":"2019/06/13/Coding Style/","text":"这是本人的代码风格。 在下列规则中，部分来自于文末的谷歌代码规范。 整体 两空格缩进 使用 $Source\\ Code\\ Pro$ 字体，大小为 14 号 $Sublime$ 编辑器最佳 一行的长度通常不要超过 60 列，一定不能超过 90 大括号不换行，但要在大括号前加空格 运算符间通常有空格， ++ 除外 模板 update 2019/8/10 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = (a); i &lt;= (b); i++)#define per(i, a, b) for (int i = (a); i &gt;= (b); i--)#define trv(u) for (edg *p = h[u]; p; p = p-&gt;nxt)typedef long long ll;const int N = 1e5 + 100;const int inf = 0x3f3f3f3f;const int mod = 1e9 + 7;inline int rd() &#123; int s = 0, w = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') &#123; if (c == '-') w = -1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') s = s * 10 + c - '0', c = getchar(); return s * w;&#125;int main() &#123; return 0;&#125; 头文件 通常在程序第一行 （ #pragma 时除外 ） include 和 &lt;头文件&gt; 之间有一个空格 通常只用一个万能头 #include &lt;bits/stdc++.h&gt; 命名空间 在头文件之后，与头文件之间空一行 在它后面也空一行 12345#include &lt;bits/stdc++.h&gt;using namespace std;... 定义 在命名空间之后 通常只需一个定义数组大小的函数 const int N = 100100; 如果有 typedef ... ... ，则将其置于 const int 之前 如果有 #define int long long 这种，则放到 const int 之后 如果有多个恒量（ const int ），则将他们分开 123456typedef long long ll;const int N = 100100;const int MOD = 1e9 + 7;const double eps = 1e-9;#define int long long#define rg register 变量 在定义之后，与定义间有空行 单行长度尽量不超过 60 两行之间不空行 1234bool vis[N];int a[N], b[N &lt;&lt; 1];ll x1, x2, x3, x4, AVeryLongVariableName, a, b, c, d, e, f, g;ll LengthOver60NeedToChangeLine; 结构体 在变量之后，与变量间有空行 在结构体名称与后方大括号间有空格 末尾右括号右侧加空格 1234struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool; 函数 在结构体之后，不同函数间有空行，函数内部没有空行 不管是什么函数都要加上 inline （尽管可能没啥用。。 关于程序中语句的一些要点也就揉到这里面了 for 、 if 和 while 后括号左侧要加空格 循环变量一般不加 register 如果循环内语句不小于两句，就加大括号，通常两句间用分号连接 循环和判断能不加大括号就不加 不加大括号时如果把循环（判断）内的语句放到循环（判断）的同一行内的长度不超过 60 就放到同一行 永远不要把任何语句放到大括号右边 123456789101112131415inline void dfs(int u) &#123; int u; bool x; for (edge *p = h[u]; p; p = p-&gt;next) for (int i = 1; i &lt;= n; i++) &#123; if (i == 1) continue ; else if (i &amp; 1) &#123; a[1] = a[2] = a[3] = a[4] = a[5] = x; &#125; while (i) do &#123; // do while 要加大括号，就算只有一句 i++; &#125; while(i &lt; 5); &#125; puts(\"This is wrong!\"); // 不能这样 return ;&#125; 主函数 通常把初始化写在一个函数内，在主函数内调用 通常使用 int main() ，除非 #define int long long 时才用 signed main() 最后要 return 0 散碎的变量统一放在主函数的开头，如果太多分两行 123456int main() &#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\\n\", a + b); return 0;&#125; 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100100;int n, m, a[N];struct node &#123; int left, right, s, tag; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if (tag) &#123; if (ls) ls-&gt;seta(tag); if (rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[N &lt;&lt; 3], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if (left == right) &#123; r-&gt;s = a[left]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right);&#125;inline void change(node *r, int left, int right, int d) &#123; if (r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if (r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if (r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;int main() &#123; int l, r, d; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); build(root = ++cnt, 1, n); while (m--) &#123; sacnf(\"%d%d%d\", &amp;l, &amp;r, &amp;d); change(root, l, r, d); &#125; return 0;&#125; 谷歌代码风格 ( 建议在新标签页中查看大图 ) google 更详细的中文文字版在这里 最后的最后如果您有什么修改意见，也请在评论区留言，谢谢！","tags":[{"name":"优化","slug":"优化","permalink":"http://tle666.github.io/tags/优化/"}]},{"title":"「Codeforces 518D」Ilya and Escalator","date":"2019-06-05T14:19:23.000Z","path":"2019/06/05/[Codeforces 518D] Ilya and Escalator/","text":"Description有 $n$ 个人排成一列，每秒中队伍最前面的人 $p$ 的概率走上电梯（一旦走上就不会下电梯）或者有 $(1-p)$ 的概率不动。问 $t$ 秒过后，在电梯上的人的数量的期望。 对于 $100 \\%$ 的数据，满足 $n,t\\leq2000$ 题目链接戳这里 Solution期望 $DP$ 。 设 $dp_{i,j}$ 表示第 $i$ 秒已经走上 $j$ 个人的概率。 则有 ans = \\sum_{i = 1}^n dp_{t, i}转移方程如下（一定注意边界！）： dp_{i, j}=\\left\\{ \\begin{array}{ll}dp_{i -1,0}\\times(1-p) & j=0\\\\dp_{i - 1, j - 1}\\times p+dp_{i-1,j}\\times (1-p) & 1\\le j","tags":[{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"期望","slug":"期望","permalink":"http://tle666.github.io/tags/期望/"}]},{"title":"「HAOI2007」反素数","date":"2019-05-17T11:14:38.000Z","path":"2019/05/17/[HAOI2007] 反素数/","text":"Description对于一个数 $x$ ，只要它满足对于任意一个 $&lt; x$ 的数 $i$ ，均有 $g(i) &lt; g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。 题目连接戳这里 Solution设答案为 ans 。则有 ans = 2^{\\alpha_1} \\cdot 3^{\\alpha_2} \\cdot 5^{\\alpha_3} \\cdot ... \\cdot 31^{\\alpha_{11}}我们能够得出结论：若果 ans 为反素数，则 $\\alpha_1 \\geq \\alpha_2 \\geq \\alpha_3 \\geq … \\geq \\alpha_{11}$ 口糊 证明： 对于 ${p_1}^{\\alpha_1} \\cdot {p_2}^{\\alpha_2}$ ，假设 $p_1 &lt; p_2$ 且 $\\alpha_1 &lt; \\alpha_2$ ，则数 ${p_1}^{\\alpha_2} \\cdot {p_2}^{\\alpha_1}$ 必定 $&lt;{p_1}^{\\alpha_1} \\cdot {p_2}^{\\alpha_2}$ 但两数的约数个数相等，矛盾！ 比如说 $2^3\\cdot3^5$ ，则 $2^5\\cdot3^3&lt;2^3\\cdot3^5$ 但这两个数的约数和却相等。矛盾！ 只需暴力递归即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 30;int n, a[N], p[N] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31&#125;;int ans, mx;inline int qpow(int a, int b) &#123; // 不必须的快速幂 int res = 1; while (b) &#123; if (b &amp; 1) res *= a; a *= a, b &gt;&gt;= 1; &#125; return res;&#125;inline void upd(int cur) &#123; // 更新答案 int res = 1, tmp; for (int i = 1; i &lt;= cur; i++) res *= (a[i] + 1); tmp = 1; for (int i = 1; i &lt;= cur; i++) tmp *= qpow(p[i], a[i]); if (mx &lt; res) &#123; mx = res; ans = tmp; &#125; if(mx == res &amp;&amp; ans &gt; tmp) // 注意这种情况！ ans = tmp;&#125;inline void dfs(int cur, int cnt, int last) &#123; // 递归 for (int i = 0; i &lt;= cnt; i++) &#123; if (i) last *= p[cur]; if (last &gt; n) &#123; upd(cur); return ; &#125; a[cur] = i; if (!i) upd(cur); else dfs(cur + 1, i, last); &#125;&#125;signed main() &#123; scanf(\"%lld\", &amp;n); dfs(1, 31, 1); printf(\"%lld\\n\", ans); return 0;&#125;","tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"}]},{"title":"「JZOJ4964」Rhyme","date":"2019-05-08T14:53:33.000Z","path":"2019/05/08/[JZOJ4964] Rhyme/","text":"Description由于多次交换邮票没有满足所有人的需求，小$Z$被赶出了集邮部。无处可去的小$Z$决定加入音乐部，为了让音乐部的人注意到自己的才华，小$Z$想写一首曲子。为了让自己的曲子更好听，小$Z$找到了一些好听曲子作为模板。曲谱可以表示成只包含小写字母的字符串，小$Z$希望自己最终的曲谱中任意一个长度为$K$的子串都是一个模板的子串。现在小$Z$想知道自己的曲谱最长可以是多长，如果可以无限长的话请输出INF。 Input本题的每个测试点有多组数据，对于每组数据： 第一行两个整数$N$，$K$分别表示模板的个数与$K$值。 接下来$N$行，每行一个字符串表示一个模板。（只包含$’a’$~$’z’$） 每组数据字符串总长不超过$100000$，$1\\leq K\\leq100000$。每个测试点数据不超过$10$组。 Output对于每组数据输出一行表示曲子最长可以是多长，如果可以无限长的话输出$INF$。 Sample Input12341 4abcabc1 5abcabc Sample Output12INF6 样例解释 第一个样例的曲子可以是$”abc”$不断循环。 第二个样例的曲子最长是$”abcabc”$。 Hint对于一个$K$值来说，任意一个长度小于$K$的字符串均可行。 Solution字符串哈希 + 拓扑排序。 题目中给了固定的$K$，因此很容易想到字符串哈希。 于是我们可以哈希一下所有长度为$(K-1)$的子串，前一个与后一个以哈希值连边。最后拓扑一下就行了。 特别地，如果图上有环，那就说明是$INF$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N = 100100;const int M = 2e6;const ull MOD = 9223372036854775807;queue&lt;int&gt; Q;char str[N];int T, n, k, ans;int ind[M], S[N], f[M];ull hs[M], K;bool vis[M];struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[M], *cnt = pool;inline int num(const char &amp;x) &#123; return x - 'a' + 1;&#125;inline void addedge(int u, int v) &#123; edge *p = ++cnt; ind[v]++; vis[u] = vis[v] = true; p-&gt;v = v, p-&gt;next = h[u], h[u] = p;&#125;inline ull qpow(ull a, ull b) &#123; ull res = 1; while(b) &#123; if(b &amp; 1) (res *= a) %= MOD; b &gt;&gt;= 1, (a *= a) %= MOD; &#125; return res;&#125;inline ull Hash(ull d) &#123; ull p = d % M; while(hs[p] &amp;&amp; hs[p] != d) &#123; p++; if(p &gt;= M) p -= M; &#125; hs[p] = d; return p;&#125;inline void tpsort() &#123; int u, v; while(!Q.empty()) &#123; u = Q.front(); Q.pop(); ans = max(ans, f[u]); for(edge *p = h[u]; p; p = p-&gt;next) &#123; if(!(--ind[v = p-&gt;v])) Q.push(v); f[v] = max(f[v], f[u] + 1); &#125; &#125;&#125;inline void prework() &#123; K = qpow(26, k - 1); cnt = pool; memset(h, 0, sizeof(h)); memset(f, 0, sizeof(f)); memset(ind, 0, sizeof(ind)); memset(vis, false, sizeof(vis)); while(!Q.empty()) Q.pop();&#125;int main() &#123; while(scanf(\"%d%d\", &amp;T, &amp;k) != EOF) &#123; prework(); while(T--) &#123; scanf(\"%s\", str + 1); n = strlen(str + 1); if(n &lt; k) continue ; for(int i = 1; i &lt;= n; i++) S[i] = num(str[i]); ull tmp = 0, u = 0, v = 0; for(int i = 1; i &lt; k; i++) (tmp *= 26) += S[i]; for(int i = k; i &lt;= n; i++) &#123; u = Hash(tmp); (tmp *= 26) += (ull) (S[i] - S[i - k + 1] * K); v = Hash(tmp); addedge(u, v); &#125; &#125; ans = k - 1; for(int i = 0; i &lt; M; i++) if(vis[i] &amp;&amp; !ind[i]) Q.push(i), f[i] = k - 1; tpsort(); bool flag = false; for(int i = 0; i &lt; M; i++) if(ind[i] &amp;&amp; vis[i]) &#123; flag = true; break ; &#125; if(flag) puts(\"INF\"); else printf(\"%d\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://tle666.github.io/tags/字符串哈希/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://tle666.github.io/tags/拓扑排序/"}]},{"title":"决策单调性","date":"2019-05-04T08:42:42.000Z","path":"2019/05/04/决策单调性/","text":"在做动归题时，我们常会遇到复杂度过高的情况。 决策单调性可以帮你减轻复杂度带来的负担。 Monge Condition即 四边形不等式； 对于 $w(i,j)$ 和依次递增的四个数 $a, b, c, d$ 只要 w(a, c) + w(b, d) \\leq w(a, d) + w(b, c)那么我们就说函数 $w(i, j)$ 满足四边形不等式。 就好比一个矩形，其左上角为 $(a, c)$，右下角为 $(b, d)$，左上角的值加右下角的值 其名称也是因此而来的。 决策单调性对于一个转移方程 f_i = \\min(f_j + w_{j, i})其中 $1 \\leq j &lt; i$； 设 $opt(i)$ 代表 $(f_j + w_{j, i})$ 最小时的 $j$，即 f_i = f_{opt(i)} + w_{opt(i), i}这里显然有 $opt(i) &lt; i$ 决策单调性就是指 $opt(i) \\leq opt(i + 1)$ 结论：若 $w_{i, j}$ 满足四边形不等式，则转移方程满足决策单调性，即 四边形不等式推出决策单调性。 证明: 由定义， f_i = f_{opt(i)} + w_{opt(i), i}f_{i + 1} = f_{opt(i + 1)} + w_{opt(i + 1), i + 1}$w$ 满足 $Monge\\ Condition$； 若 $opt(i) &gt; opt(i + 1)$，即决策单调性不成立； opt(i + 1) < opt(i) \\leq i < i + 1令 $a = opt(i + 1),\\ b = opt(i),\\ c = i,\\ d = i + 1$； 由 $Monge\\ Condition$， w(a, c) + w(b, d) \\leq w(a, d) + w(b, c)因为 $f_i$ 和 $f_{i + 1}$ 都取到了最小值，所以 $(f_i + f_{i + 1})_{\\min}$ 而 $(f_i + f_{i + 1}) = f_a + f_b + w(a, d) + w(b, c)$ ​ $\\geq f_a + f_b + w(a, c) + w(b, d)$ 矛盾！ 取法： 令 $f_i = f_{opt(i + 1)} + w_{opt(i + 1), i}$，$f_(i + 1) = f_{opt(i)} + w_{opt(i), i + 1}$， 即互换 $opt(i),\\ opt(i + 1)$ 即可。 ∴$opt(i) \\leq opt(i + 1)$ 证毕。 简单例题： 「CF321E」Ciel and Gondolas 「NOI2009」诗人小G","tags":[{"name":"优化","slug":"优化","permalink":"http://tle666.github.io/tags/优化/"},{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"},{"name":"四边形不等式","slug":"四边形不等式","permalink":"http://tle666.github.io/tags/四边形不等式/"}]},{"title":"「SPOJ1811」LCS - Longest Common Substring","date":"2019-04-27T12:34:13.000Z","path":"2019/04/27/[SPOJ1811] LCS - Longest Common Substring/","text":"Description输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出0 。 对于$100 \\%$的数据，$|S| \\leq 250000$ 题目链接戳这里 Solution这道题可以作为后缀数组的练手题。调了5个小时。。。 后缀数组是对一个字符串的操作啊，那这道题不是2个嘛？ 把它整到一个里面就行啦！ 忽然想到$Manacher$算法，中间每两个字符不是用$隔开了吗？ 对啊！ 就在两个单词中间加个$就行啦~ 举个栗子： S_1 = \"firststring\"S_2 = \"secondstring\"（双引号不包括在字符串中） 则整合后的字符串 S = \"firststring$secondstring\"很简单吧、 于是这个问题就转化为了在一个字符串里找最长重复子串啦 ——这不就是$height$数组嘛 但是注意有一个小条件 两个最长子串必须在不同的单词之间哦！ 这个随便判断一下就行啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000100;char s[2][N];int n, m, ans, len, x[N], y[N];int rk[N], sa[N], h[N], c[N], a[N];// 其中 h 数组就是 height 数组inline void rsort() &#123; for(int i = 1; i &lt;= m; i++) c[i] = 0; for(int i = 1; i &lt;= n; i++) c[x[i]]++; for(int i = 2; i &lt;= m; i++) c[i] += c[i - 1]; for(int i = n; i &gt;= 1; i--) sa[c[x[y[i]]]--] = y[i];&#125;inline void getSA() &#123; int p = 0; for(int i = 1; i &lt;= n; i++) x[i] = a[i], y[i] = i; rsort(); for(int k = 1; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= 1) &#123; p = 0; for(int i = n - k + 1; i &lt;= n; i++) y[++p] = i; for(int i = 1; i &lt;= n; i++) if(sa[i] &gt; k) y[++p] = sa[i] - k; rsort(); swap(x, y); x[sa[1]] = 1, p = 2; for(int i = 2; i &lt;= n; i++) if(y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = p - 1; else x[sa[i]] = p++; m = p; &#125;&#125;inline void getH() &#123; for(int i = 1; i &lt;= n; i++) rk[sa[i]] = i; int L = 0, j; for(int i = 1; i &lt;= n; i++) &#123; j = sa[rk[i] - 1]; if(L) L--; while(a[i + L] == a[j + L]) L++; h[rk[i]] = L; &#125;&#125;int main() &#123; scanf(\"%s%s\", s[0], s[1]); len = n = strlen(s[0]), m = strlen(s[1]); n += m + 1, m = 128; for(int i = 1; i &lt;= len; i++) a[i] = s[0][i - 1]; a[len + 1] = '$'; for(int i = len + 2; i &lt;= n; i++) a[i] = s[1][i - len - 2]; getSA(); getH(); for(int i = 2; i &lt;= n; i++) if((sa[i] &gt; len &amp;&amp; sa[i - 1] &lt; len) || (sa[i] &lt; len &amp;&amp; sa[i - 1] &gt; len)) ans = max(ans, h[i]); printf(\"%d\\n\", ans); return 0;&#125;","tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://tle666.github.io/tags/后缀数组/"}]},{"title":"「BZOJ2561」最小生成树","date":"2019-03-27T12:53:07.000Z","path":"2019/03/27/[BZOJ2561] 最小生成树/","text":"Description一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。 对于$100\\%$的数据，$N,\\ L \\leq 20000$，$M \\leq 200000$ 题目链接戳这里 Solution思路妙啊！ 如果$L$那条边可能出现在最小生成树上，那么就有边权$&lt;L$的边不能连通其两端点$(u, v)$，否则将$u$和$v$连起来再删除$L$那条边显然更小。这不就是最小割嘛！ 最大生成树也同理，于是答案就是两次最小割之和。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200200;const int INF = 0x7f7f7f7f;int n, m, S, T, L, lev[N], ans;struct edge &#123; int v, c; edge *next, *rev;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct node &#123; int u, v, c;&#125; a[N];inline void clear() &#123; memset(pool, 0, sizeof(pool)), memset(h, NULL, sizeof(h)), cnt = pool;&#125;inline void addedge(int u, int v, int c) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;c = c, p-&gt;next = h[u], h[u] = p, p-&gt;rev = q; q-&gt;v = u, q-&gt;c = c, q-&gt;next = h[v], h[v] = q, q-&gt;rev = p;&#125;inline bool makelev() &#123; int u, v; memset(lev, -1, sizeof(lev)); queue&lt;int&gt; Q; Q.push(S), lev[S] = 0; while(!Q.empty()) &#123; u = Q.front(), Q.pop(); for(edge *p = h[u]; p; p = p-&gt;next) if(!(lev[v = p-&gt;v] + 1) &amp;&amp; p-&gt;c &gt; 0) &#123; lev[v] = lev[u] + 1; Q.push(v); &#125; &#125; return (lev[T] != -1);&#125;inline int dfs(int u, int flow) &#123; int v, res = 0, f; if(u == T) return flow; for(edge *p = h[u]; p; p = p-&gt;next) if(lev[v = p-&gt;v] == lev[u] + 1 &amp;&amp; p-&gt;c &gt; 0) &#123; f = dfs(v, min(p-&gt;c, flow)); flow -= f, p-&gt;c -= f; res += f, p-&gt;rev-&gt;c += f; if(!flow) break ; &#125; if(!res) lev[u] = -1; return res;&#125;inline int dinic() &#123; int res = 0; while(makelev()) res += dfs(S, INF); return res;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].c); scanf(\"%d%d%d\", &amp;S, &amp;T, &amp;L); for(int i = 1; i &lt;= m; i++) if(a[i].c &gt; L) addedge(a[i].u, a[i].v, 1); // 注意这里的边权 ans += dinic(); clear(); for(int i = 1; i &lt;= m; i++) if(a[i].c &lt; L) addedge(a[i].u, a[i].v, 1); // 这里也是 ans += dinic(); printf(\"%d\\n\", ans); return 0;&#125;/*3 23 2 11 2 31 2 2*/","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://tle666.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"http://tle666.github.io/tags/最大流/"},{"name":"最小割","slug":"最小割","permalink":"http://tle666.github.io/tags/最小割/"}]},{"title":"「HDU6203」ping ping ping","date":"2019-03-21T14:25:47.000Z","path":"2019/03/21/[HDU6203] ping ping ping/","text":"Description$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 U V 无法连通。问无法通行的点最少有多少个。 对于$100 \\%$的数据，$3 \\leq n \\leq 10^4$，$p \\leq 5 \\times 10^4$ 题目链接戳这里 Solution考虑到我们要求的是$u$到$v$上不能通行，很显然 能想到可以通过树上前序与后序$DFS$序来维护。具体方法如下： 根据所给的树预处理出每个点的前序 $DFS$ 序和后序$DFS$ 序（需一起标号），和每个点的深度。 根据 $p$ 组 U V 处理每组两点之间的 $LCA$ 。压入优先队列（$LCA$ 深度大的点优先，即往前走）。 对于出队的U V及其对应的 $LCA$ ，判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。 判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。 处理方式：由于之前已经处理出每个点的前后序 $DFS$ 序 $in$ 和 $out$ 。 对于某点 $U$ 若在已禁止通行点 $P$ 的子树中，则 $In[P]≤In[U]≤Out[U]≤Out[P]In[P]≤In[U]≤Out[U]≤Out[P]$ 一定成立。 故利用树状数组区间更新单点查询。对每个禁止通行点 $P$ ，标记区间 $[In[P],Out[P]][In[P],Out[P]]$ 中所有点。查询时，若点 $In[U]$ 被标记，则说明 U V 已经被隔断。 同时，由于优先处理 $LCA$ 深度大的点，不会出现点 U V 同时在同一个被禁止通行点 $P$ 的子树内。 若 $U$ ，$V$ 均不在被禁止的点在子树内，则禁止 U V 的 $LCA$ 点，同时对答案贡献 $+1$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100100;int n, p, in[N], out[N], tot, dep[N];int st[N][25], fa[N], C[N &lt;&lt; 1], ans;bool vis[N];struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct P &#123; int u, v, lca; inline bool operator &lt; (const P &amp;x) const &#123; return dep[lca] &lt; dep[x.lca]; &#125;&#125; rec;priority_queue&lt;P&gt; pq;inline void prework() &#123; // 注意多组数据的清空 ans = tot = 0, cnt = pool, tot = 0; while(!pq.empty()) pq.pop(); memset(h, NULL, sizeof(h)), memset(pool, 0, sizeof(pool)), memset(in, 0, sizeof(in)), memset(out, 0, sizeof(out)), memset(dep, 0, sizeof(dep)), memset(st, 0, sizeof(st)), memset(fa, 0, sizeof(fa)), memset(vis, false, sizeof(vis)), memset(C, 0, sizeof(C));&#125;inline void addedge(int u, int v) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u, int depth) &#123; int v; in[u] = ++tot; dep[u] = depth, vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u; dfs(v, depth + 1); &#125; out[u] = ++tot;&#125;inline int LCA(int u, int v) &#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(int i = 19; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return fa[u];&#125;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; for(; x; x -= lowbit(x)) res += C[x]; return res;&#125;inline void change(int x, int d) &#123; for(; x &lt; (N &lt;&lt; 1); x += lowbit(x)) C[x] += d;&#125;inline void work() &#123; // 主要函数 int u, v; prework(); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(++u, ++v); &#125; ++n, dfs(1, 1); for(int i = 1; i &lt;= n; i++) st[i][0] = fa[i]; for(int i = 1; i &lt;= 20; i++) for(int j = 1; j &lt;= n; j++) st[j][i] = st[st[j][i - 1]][i - 1]; scanf(\"%d\", &amp;p); for(int i = 1; i &lt;= p; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); rec.u = ++u, rec.v = ++v, rec.lca = LCA(u, v); pq.push(rec); &#125; while(!pq.empty()) &#123; rec = pq.top(), pq.pop(); if(!(sum(in[rec.u]) + sum(in[rec.v]))) change(in[rec.lca], 1), change(out[rec.lca] + 1, -1), ans++; &#125; printf(\"%d\\n\", ans);&#125;int main() &#123; while(scanf(\"%d\", &amp;n) != EOF) work(); return 0;&#125;","tags":[{"name":"LCA","slug":"LCA","permalink":"http://tle666.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://tle666.github.io/tags/倍增/"},{"name":"树状数组","slug":"树状数组","permalink":"http://tle666.github.io/tags/树状数组/"},{"name":"DFS序","slug":"DFS序","permalink":"http://tle666.github.io/tags/DFS序/"}]},{"title":"「SPOJ1043」GSS1","date":"2019-03-17T01:51:27.000Z","path":"2019/03/17/[SPOJ1043] GSS1/","text":"Description给一段可能有负数的序列，查询最大子段和。 对于$100 \\%$的数据，序列长度$N \\leq 50000$，$a[i] \\leq 15007$ 题目链接戳这里 Solution线段树查询最大子段和。 这里需要维护四个信息： $s$ 区间和 $mx$ 区间最大子段和 $lmx$ 区间前缀和最大值 $rmx$ 区间后缀和最大值 则维护的时候就像这样 1234s = ls-&gt;s + rs-&gt;s,mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), // 注意有三种情况lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); 其中$ls$，$rs$分别是左子，右子。 还有一个注意事项：$query$（查询）的时候返回值要是$node*$！只有这样才能够维护四个信息。 Code码风在这种题里很重要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 1001000;int n, m, a[MAXN];struct node &#123; int left, right, mx, lmx, rmx, s; node *ls, *rs; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s, mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx), rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); &#125;&#125; pool[MAXN &lt;&lt; 5], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = r-&gt;mx = r-&gt;lmx = r-&gt;rmx = a[left]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline node *query(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else &#123; node *L, *R, *res; L = query(r-&gt;ls, left, r-&gt;ls-&gt;right), R = query(r-&gt;rs, r-&gt;rs-&gt;left, right), res = ++cnt, res-&gt;s = L-&gt;s + R-&gt;s, res-&gt;left = L-&gt;left, res-&gt;right = R-&gt;right, res-&gt;mx = max(L-&gt;rmx + R-&gt;lmx, max(L-&gt;mx, R-&gt;mx)), res-&gt;lmx = max(L-&gt;s + R-&gt;lmx, L-&gt;lmx), res-&gt;rmx = max(R-&gt;s + L-&gt;rmx, R-&gt;rmx); return res; &#125;&#125;int main() &#123; int left, right; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); build(root = cnt, 1, n); scanf(\"%d\", &amp;m); while(m--) &#123; scanf(\"%d%d\", &amp;left, &amp;right); printf(\"%d\\n\", query(root, left, right)-&gt;mx); &#125; return 0;&#125;","tags":[{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"}]},{"title":"「ZJOI2009」时态同步","date":"2019-03-15T14:46:47.000Z","path":"2019/03/15/[ZJOI2009] 时态同步/","text":"Description一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。 对于$100\\%$的数据，$N \\leq 500000$，边权$t_e \\leq 1000000$。 题目连接戳这里 Solution树形$DP$的板子题。 令$dp_x$为叶子结点到$x$结点的最大时间。 则有 $dp_x = \\max (dp_{son[x]} + dis_{x,\\ son[x]})$ 因此 $ans = \\sum (dp_x - dp_{son[x]} - dis_{x,\\ son[x]})$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 500500#define int long longint n, root, dp[MAXN], ans, fa[MAXN];bool vis[MAXN];struct edge &#123; int v, w; edge *next;&#125; pool[MAXN &lt;&lt; 1], *h[MAXN], *cnt = pool;inline void addedge(int u, int v, int w) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u) &#123; int v; vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u, dfs(v); dp[u] = max(dp[u], dp[v] + p-&gt;w); &#125; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u]) ans += (dp[u] - dp[v] - p-&gt;w);&#125;signed main() &#123; int u, v, w; scanf(\"%lld%lld\", &amp;n, &amp;root); for(int i = 1; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; dfs(root); printf(\"%lld\\n\", ans); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://tle666.github.io/tags/树形DP/"}]},{"title":"「SCOI2009」windy 数","date":"2019-03-10T05:40:03.000Z","path":"2019/03/10/[SCOI2009] windy数/","text":"Description求$A$，$B$之间所有满足相邻两位之间差$\\geq2$的整数。 对于$100$%的数据， $1 \\leq A \\leq B \\leq 2 \\times 10^9$。 Solution数位$DP$模板题。 令$dp_{i,j}$表示第$i$位，上一位为$j$的总方案数（一直到结束）。 然后逐位$DP$即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;ll dp[110][11], d[110];inline ll calc(int x, int p) &#123; if(dp[x][p] + 1) return dp[x][p]; if(!x) return dp[x][p] = 1; ll res = 0; for(int q = 0; q &lt; 10; q++) if(abs(p - q) &gt;= 2) res += calc(x - 1, q); return dp[x][p] = res;&#125;inline ll solve(ll x) &#123; int m = 0, ans = 0, pre = -110; while(x) d[m++] = x % 10, x /= 10; for(int i = 1; i &lt; m; i++) for(int j = 1; j &lt;= 9; j++) ans += calc(i - 1, j); for(int i = m - 1; i &gt;= 0; i--) &#123; for(int j = (i == m - 1); j &lt; d[i]; j++) if(abs(pre - j) &gt;= 2) ans += calc(i, j); if(abs(pre - d[i]) &lt; 2) break ; pre = d[i]; &#125; return ans;&#125;int main() &#123; ll l, r; memset(dp, -1, sizeof(dp)); scanf(\"%lld%lld\", &amp;l, &amp;r); printf(\"%lld\\n\", solve(r + 1) - solve(l)); return 0;&#125;","tags":[{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"数位DP","slug":"数位DP","permalink":"http://tle666.github.io/tags/数位DP/"}]},{"title":"非旋 Treap 详解","date":"2019-03-09T14:23:07.000Z","path":"2019/03/09/非旋Treap详解/","text":"Introduction “$Treap$的旋转好难啊！” “你不知道非旋$treap$吗？” （被一顿吊打。。 这就是$FHQ-Treap$。 前置技能：小根堆 &amp; $Treap$（不必须） 提示：此博客图片较多，如无法加载请刷新重试~ Definition12345678struct node &#123; int d, rnd, size; node *ls, *rs; inline void upd() &#123; &#125; inline void push() &#123; &#125;&#125; pool[MAXN &lt;&lt; 1], *root, *cnt = pool; $d$是真实权值，$rnd$是随机权值，$size$是子树大小； $ls$是左儿子，$rs$是右儿子； $upd$是从下往上更新信息（例如$size$）； $push$是下发懒标记。 $root$是根。 OperationsMerge 假设有两颗子树x，y，且 x 的所有节点的值都小于 y 的所有节点的值，随机权值 rnd 都以小根堆的形式存储。 img 此时要合并 x , y 。我们先比较它们的根的随机权值，发现1&lt;3，因为要满足小根堆性质，于是 x 的左子树全部不变，让它的右子树继续和 y 合并。 img 这时我们发现，随机权值 rnd 5&gt;3，所以 y 接到 root(图中rot) 的下方，成为 root 的右儿子，y的右子树全部不变，让y的左子树继续和x合并（以满足平衡树的性质）。 img 由于5&gt;4，所以y和y的右子树作为root的左儿子，y的左子树继续和x合并。 img 以此类推…… 最后，我们发现 x 为 0 ，所以直接返回 y ，合并结束。 img Code1234567891011inline node *merge(node *l, node *r) &#123; if(!l || !r) return l ? l : r; // 如果有一边为空 if(l-&gt;rnd &lt; r-&gt;rnd) &#123; l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r); l-&gt;upd(); return l; &#125; else &#123; r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls); r-&gt;upd(); return r; &#125;&#125; Split1.按权值split首先得有个基准值 a ，即权值小于等于 a 的节点全部进入左树（下图中会将此类节点染红），大于a的节点全部进入右树（下图中会将此类节点染蓝）。这里以a=25为例。 img 首先，发现rot的权值=15","tags":[{"name":"fhq-treap","slug":"fhq-treap","permalink":"http://tle666.github.io/tags/fhq-treap/"}]},{"title":"「luogu1558」色板游戏","date":"2019-03-06T13:45:17.000Z","path":"2019/03/06/[luogu1558] 色板游戏/","text":"Description对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作： 将$a[l]$到$a[r]$赋值为$d$； 询问$a[l]$到$a[r]$有几种不同的数。 操作$m$次，$d \\in [1,\\ t]$ 对于$100$%的数据， $1 \\leq n \\leq 100000$，$1 \\leq t \\leq 30$，$1 \\leq m \\leq 100000$ 题目链接戳这里 Solution线段树的基础题 然后我错了9遍 很有意思的一道题，有两种不同的解法 解法一比较暴力，建$t$棵线段树即可。 第$i$棵线段树只存值为$i$的数组有哪些。 常数比较大。 $6$次提交，不开$O2$最高只能$80$分，就算开了$O2$也只能$90$。。 你们自己想卡常就卡去吧。。 我的$80$分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, mx, tag; node *ls, *rs; inline void seta(int x) &#123; tag = x, mx = (x == 1 ? 1 : 0);&#125; inline void upd() &#123; mx = max(ls-&gt;mx, rs-&gt;mx);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 8], *root[35], *cnt = pool;inline void build1(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;mx = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build1(ls, left, mid), build1(rs, mid + 1, right); r-&gt;upd();&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) return ; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right);&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;mx; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;int main() &#123; int A, B, C, ans; n = read(), t = read(), m = read(); build1(root[1] = cnt, 1, n); for(int i = 2; i &lt;= t; i++) build(root[i] = ++cnt, 1, n); while(m--) &#123; scanf(\"%s\", ch); A = read(), B = read(); if(A &gt; B) swap(A, B); if(ch[0] == 'C') &#123; C = read(); for(int i = 1; i &lt;= t; i++) if(i != C) change(root[i], A, B, -1); else change(root[C], A, B, 1); &#125; else &#123; ans = 0; for(int i = 1; i &lt;= t; i++) ans += query(root[i], A, B); printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; 解法二$100$%的正解。 用二进制来表示区间的取值情况。 比如$a_1 = 1,\\ a_2 = 2,\\ a_3 = 3,\\ a_4 = 2$， 我们不妨设数值$i$是$2^{i - 1}$ 则1,2合起来就是0011； 1,3合起来就是0101； 注意：2,3,4合起来是0110而不是0120！ 大体上和解法一比较类似 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, s, tag; // s 就是存压位的那个。 node *ls, *rs; inline void seta(int x) &#123; s = (1 &lt;&lt; (x - 1)), tag = x;&#125; inline void upd() &#123; s = (ls-&gt;s | rs-&gt;s);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return (query(r-&gt;ls, left, r-&gt;ls-&gt;right) | query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline int count(int x) &#123; int res = 0; for(int i = 30; i &gt;= 0; i--) if(x &gt;= (1 &lt;&lt; i)) x -= (1 &lt;&lt; i), res++; return res;&#125;int main() &#123; int left, right, d; n = read(), t = read(), m = read(); build(root = cnt, 1, n); while(m--) &#123; scanf(\"%s\", ch), left = read(), right = read(); if(left &gt; right) swap(left, right); if(ch[0] == 'C') &#123; d = read(); change(root, left, right, d); &#125; else printf(\"%d\\n\", count(query(root, left, right))); &#125; return 0;&#125;/*2 2 4C 1 1 2P 1 2C 2 2 2P 1 2*/","tags":[{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"}]},{"title":"平面向量练习小结","date":"2019-03-02T15:02:11.000Z","path":"2019/03/02/平面向量练习小结/","text":"最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。 坐标表示法对于向量，我们能不能制定一种与坐标类似，与有序数对一一对应的方法呢？ 这就是向量的“万能方法”——坐标表示法。 对于向量$\\overrightarrow{AB}$，我们令$A$为坐标的原点，以两个夹角不为零的向量为坐标轴，不妨设$\\overrightarrow{p}$为$x$轴，$\\overrightarrow{q}$为$y$轴。我们可以将$\\overrightarrow{AB}$定义为$(x,\\ y)$，其中$x,y \\in \\mathbb{R}$。此时满足$\\overrightarrow{AB} = x \\overrightarrow{p} + y \\overrightarrow{q}$。 通常，为了方便起见，我们就将$\\overrightarrow{p}$和$\\overrightarrow{q}$设为$x$轴和$y$轴正半轴方向上的的单位向量。 这样，题目中复杂的条件就可以通过下面的公式化繁而简了。 一些有用的公式 在以下公式中，默认$\\overrightarrow{A} = (x_1,y_1),\\ \\overrightarrow{B} = (x_2,y_2)$ $\\overrightarrow{A} + \\overrightarrow{B} = (x_1 + y_1, x_2 + y_2)$ $\\overrightarrow{A} - \\overrightarrow{B} = (x_1 - y_1, x_2 - y_2)$ $\\overrightarrow{A} \\cdot \\overrightarrow{B} = x_1x_2+y_1y_2$ 由此我们可以推出 $\\cos&lt;\\overrightarrow{A}, \\overrightarrow{B}&gt; = \\frac{x_1x_2 + y_1y_2}{\\sqrt{x_1^2 + y_1^2} \\cdot \\sqrt{x_2^2 + y_2^2}}$","tags":[{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"},{"name":"平面向量","slug":"平面向量","permalink":"http://tle666.github.io/tags/平面向量/"}]},{"title":"「NOIP2011」Car的旅行路线","date":"2019-03-02T14:29:03.000Z","path":"2019/03/02/[NOIP2011] Car的旅行路线/","text":"Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\\leq10$，矩形个数$\\leq100$。 题目链接戳这里 Solution打死我也不告诉你我Floyd模板打错了 通过$floyd$处理出任意两点（注意不是矩形）之间的最小费用即可。 但这道题细节还是不少的—— 只给你矩形的三个顶点 先通过勾股定理逆定理来求出哪个是直角，然后第四个点的坐标就出来了。 矩形可以是歪的，即它的边不一定平行于坐标轴。 多组数据注意初始化。 飞机和汽车费用不一样，需要分别计算。 最后只输出1位小数 $Hint$：两点间距离公式 $dis\\ =\\ \\sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2}$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 110int _, S, t, A, B, tot;double w[MAXN][MAXN], ans; // w 是两点间的最小费用inline double sq(int x) &#123; return (double)x * x;&#125;struct point &#123; int id, t, x, y; // id 城市编号，t 列车费用 inline void INIT(int _id, int _t, int _x, int _y) &#123; id = _id, t = _t, x = _x, y = _y; &#125; // 赋值函数（更简单的忘了怎么写了 QwQ inline double dis(point &amp;a) &#123; return sqrt(sq(x - a.x) + sq(y - a.y)); &#125; // 两点间距离 inline void rct(point &amp;a, point &amp;b, point &amp;c) &#123; id = a.id, t = a.t; int P = sq(a.x - b.x) + sq(a.y - b.y), Q = sq(b.x - c.x) + sq(b.y - c.y), R = sq(c.x - a.x) + sq(c.y - a.y); if(P + Q == R) x = a.x + c.x - b.x, y = a.y + c.y - b.y; else if(P + R == Q) x = b.x + c.x - a.x, y = b.y + c.y - a.y; else x = a.x + b.x - c.x, y = a.y + b.y - c.y; &#125; // 处理第四个点的坐标&#125; p[MAXN];inline void prework() &#123; static point P, Q; static double c, d; memset(w, 0x3f, sizeof(w)); for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) &#123; if(i == j) continue ; P = p[i], Q = p[j], d = P.dis(Q), c = 0.0; if(P.id == Q.id) c = d * P.t; else c = d * (double)t; w[i][j] = w[j][i] = c; &#125;&#125; // 处理距离，注意初始化int main() &#123; int x1, y1, x2, y2, x3, y3, _t; point p1, p2, p3, p4; scanf(\"%d\", &amp;_); while(_--) &#123; // 多组数据 scanf(\"%d%d%d%d\", &amp;S, &amp;t, &amp;A, &amp;B); tot = 0; for(int i = 1; i &lt;= S; i++) &#123; scanf(\"%d%d%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;_t); p1.INIT(i, _t, x1, y1), p2.INIT(i, _t, x2, y2), p3.INIT(i, _t, x3, y3), p4.rct(p1, p2, p3); p[++tot] = p1, p[++tot] = p2, p[++tot] = p3, p[++tot] = p4; &#125; prework(); for(int k = 1; k &lt;= tot; k++) // 一开始把 k 套到最里面了。。 for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); ans = 0x7f7f7f7f; for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) if(p[i].id == A &amp;&amp; p[j].id == B) ans = min(ans, w[i][j]); printf(\"%.1lf\\n\", ans); // 只保留1位！ &#125; return 0;&#125;/*13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3*/","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"Floyd","slug":"Floyd","permalink":"http://tle666.github.io/tags/Floyd/"}]},{"title":"「USACO15DEC」最大流","date":"2019-02-23T02:52:20.000Z","path":"2019/02/23/[USACO15DEC] 最大流/","text":"Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \\leq n \\leq 50000,\\ 1 \\leq k \\leq 100000$ 题目链接戳这里 Solution树链剖分模板题！没学过的戳这里 对于每次操作$u$，$v$，我们只需要执行一次树链剖分里最基本的修改操作：路径修改即可。 最后你再用基本操作$query$求一次区间点权最大值就A了啊！ 详见代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, k, tot, wson[MAXN], dep[MAXN], fa[MAXN], dfn[MAXN], pre[MAXN], size[MAXN], top[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存树 int left, right, Max, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, Max += x;&#125; inline void upd() &#123; Max = max(ls-&gt;Max, rs-&gt;Max);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[wson[u]] &lt; size[v]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u] &amp;&amp; v != wson[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;Max = 0; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(1); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right); else change(r-&gt;ls, left, r-&gt;ls-&gt;right), change(r-&gt;rs, r-&gt;rs-&gt;left, right); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 区间求 max r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;Max; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline void Qchange(int u, int v) &#123; // 路径点权加一 int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right);&#125;int main() &#123; int u, v; scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(k--) &#123; scanf(\"%d%d\", &amp;u, &amp;v); Qchange(u, v); &#125; printf(\"%d\\n\", query(root, 1, n)); // 最后输出最大值 return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"}]},{"title":"数学公式","date":"2019-02-19T03:19:30.000Z","path":"2019/02/19/公式/","text":"这里有一些重要的初高中数学公式，可供参考。 恒等变形$a^3 + b^3 = (a + b)(a^2 - ab + b)$ $a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \\dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$ $2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \\geqslant 0$ $(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$ $(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$ $(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$ $(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$ $(a_1^2 + a_2^2 + a_3^2 + \\cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \\cdots + b_n^2) \\geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \\cdots + a_nb_n)^2$ —— $Cauchy$不等式 $(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$ 几何定理斯特瓦尔特定理 斯特瓦尔特 $BD \\cdot AC^2 + DC \\cdot AB^2 = BC \\cdot AD^2 + BD \\cdot DC \\cdot BC$ 推论：中线长公式$AD = \\frac{1}{2} \\sqrt{2(AB^2 + AC^2) - BC^2}$ 欧拉线 $\\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。 九点圆 九点圆 在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。 西姆松线 西姆松线 过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。 史坦纳定理 史坦纳定理 $H$ 为$\\triangle ABC$ 垂心，$D$为$\\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\\triangle ABC$的西姆松线通过线段$DH$的中点。 三角函数定义$\\cot\\alpha = \\frac{1}{\\tan\\alpha} \\qquad \\sec\\alpha = \\frac{1}{\\cos\\alpha} \\qquad \\csc\\alpha = \\frac{1}{\\sin\\alpha}$ 诱导公式$\\sin ( \\pi + \\alpha) =- \\sin \\alpha \\qquad \\cos(\\pi + \\alpha) = -\\cos \\alpha \\qquad \\tan (\\pi + \\alpha) = \\tan \\alpha$ $\\sin (-\\alpha) = -\\sin\\alpha \\qquad \\cos (-\\alpha) = \\cos\\alpha \\qquad \\tan(-\\alpha) = -\\tan\\alpha$ $\\sin (\\pi - \\alpha) = \\sin \\alpha \\qquad \\cos (\\pi - \\alpha) = -\\cos\\alpha \\qquad \\tan(\\pi - \\alpha) = -\\tan\\alpha$ $\\sin(2\\pi - \\alpha) = -\\sin\\alpha \\qquad \\cos(2\\pi - \\alpha) = \\cos\\alpha \\qquad \\tan(2\\pi - \\alpha) = -\\tan\\alpha$ $\\sin (\\frac{\\pi}{2} + \\alpha) = \\cos\\alpha \\qquad \\sin(\\frac{\\pi}{2} - \\alpha) = \\cos\\alpha$ $\\cos(\\frac{\\pi}{2} + \\alpha) = -\\sin\\alpha \\qquad \\cos(\\frac{\\pi}{2} - \\alpha) = \\sin\\alpha$ $\\tan(\\frac{\\pi}{2} + \\alpha) = -\\cot\\alpha \\qquad \\tan(\\frac{\\pi}{2} - \\alpha) = \\cot\\alpha$ $\\tan(\\frac{\\pi}{4} + \\alpha) = \\frac{1 + \\tan\\alpha}{1 - \\tan\\alpha}$ 推论 $(\\sin\\frac{\\alpha}{2} \\pm \\cos\\frac{\\alpha}{2})^2 = 1 \\pm \\sin\\alpha$ 两角和（差）公式$\\sin(\\alpha \\pm \\beta) = \\sin\\alpha\\cos\\beta \\pm \\cos\\alpha\\sin\\beta$ $\\cos(\\alpha \\pm \\beta) = \\cos\\alpha\\cos\\beta \\mp \\sin\\alpha\\sin\\beta$ $\\tan(\\alpha \\pm \\beta) = \\frac{\\tan\\alpha \\pm \\tan\\beta}{1 \\mp \\tan\\alpha\\tan\\beta}$ 二倍角公式$\\sin 2\\alpha = 2\\sin\\alpha\\cos\\alpha$ $\\cos2\\alpha = 2\\cos^2\\alpha - 1 = 1 - 2\\sin^2\\alpha = \\frac{1-\\tan^2\\alpha}{1+\\tan^2\\alpha}$ $\\tan2\\alpha = \\frac{2\\tan\\alpha}{1-\\tan^2\\alpha}$ 三倍角公式$\\sin(3\\alpha) = 3\\sin\\alpha - 4\\sin^3\\alpha \\qquad \\cos(3\\alpha) = 4\\cos ^ 3\\alpha - 3\\cos\\alpha$ 降幂公式$\\sin^2\\alpha = \\frac{1 - \\cos2\\alpha}{2} \\qquad \\cos^2\\alpha = \\frac{1 + \\cos2\\alpha}{2} \\qquad \\tan^2\\alpha = \\frac{1 - \\cos2\\alpha}{1 + \\cos2\\alpha}$ 辅助角公式$a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}(\\frac{a\\sin x}{\\sqrt{a^2 + b^2}} + \\frac{b\\cos x}{\\sqrt{a^2 + b^2}})$ 或 $a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}\\sin(x + \\varphi)$，其中 $\\sin\\varphi = \\frac{b}{\\sqrt{a ^ 2 + b ^ 2}},\\ \\cos\\varphi = \\frac{a}{\\sqrt{a^2 + b^2}}$ 万能公式$\\sin\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}$ $\\cos\\alpha = \\frac{1 - \\tan^2\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}$ $\\tan\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 - \\tan^2\\frac{\\alpha}{2}}$ 和差化积$\\sin\\alpha \\pm \\sin\\beta = 2\\sin\\frac{\\alpha \\pm \\beta}{2}\\cos\\frac{\\alpha \\mp \\beta}{2}$ $\\cos\\alpha + \\cos\\beta = 2\\cos\\frac{\\alpha + \\beta}{2}\\cos\\frac{\\alpha - \\beta}{2}$ $\\cos\\alpha - \\cos\\beta = -2\\sin\\frac{\\alpha + \\beta}{2}\\sin\\frac{\\alpha - \\beta}{2}$ $\\tan\\alpha \\pm \\tan\\beta = \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos\\alpha\\cos\\beta}$ 积化和差$\\sin\\alpha\\cos\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) + \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\sin\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) - \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\cos\\beta = \\frac{1}{2}(\\cos(\\alpha +\\beta) + \\cos(\\alpha - \\beta))$ $\\sin\\alpha\\sin\\beta = -\\frac{1}{2}(\\cos(\\alpha + \\beta) - \\cos(\\alpha - \\beta))$","tags":[{"name":"三角函数","slug":"三角函数","permalink":"http://tle666.github.io/tags/三角函数/"},{"name":"代数","slug":"代数","permalink":"http://tle666.github.io/tags/代数/"},{"name":"几何","slug":"几何","permalink":"http://tle666.github.io/tags/几何/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"}]},{"title":"树链剖分详解","date":"2019-02-02T15:13:25.000Z","path":"2019/02/02/树链剖分详解/","text":"Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u$到$v$的权值都加$d$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。 前置技能：线段树（重要） &amp; 倍增求 $LCA$（不必须） Definition &amp; Steps 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。 首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念： $size_i$：以$i$为根的子树中结点个数 $dfn_i$：$i$结点的$dfs$序，即其新编号 $pre_i$：$dfn$的反函数，若$dfn_i\\ =\\ j$，则$pre_j\\ =\\ i$，即$dfn_{pre_i}\\ =\\ 1$。 $fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号） $dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\\ =\\ 1$ $w_i$：$i$结点的权值 重儿子：一个结点所有子结点中$size$最大的子节点，用$wson[i]$表示 轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点 重边：一个结点和它的重儿子的连边 轻边：一个节点和它的轻儿子的连边 重链：由多条重边首尾顺次连接而成的链（路径） 轻链：有多条轻边首尾顺次连接而成的链（路径） $top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上） 上一张百度百科的图： 图片没了吗？可以到百度百科上看 如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可； 同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$ 递归伪代码如下： 123456789void dfs1(int u, int f) // u 当前结点，f 是 u 的父亲结点 size[u] = 1 for each v that connects to u : // u 的子结点 if(v != f) // v 不是 u 的父亲 fa[v] = u // 说明 v 是 u 的子结点 dep[v] = dep[u] + 1 // 深度维护 dfs(v, u) // 继续递归 size[u] += size[v] // 将子树的 size 加到这棵树的 size 上 if(size[wson[u]] &lt; size[v]) wson[u] = v // 更新重儿子 可以手动模拟一下 这样，我们就求出了每个结点的重儿子 $wson$ ； 特别地，每个叶子结点的重儿子都为 $0$ 每个标红点的结点都是一条重链的链首（$top$）， 而加粗的边则是重链。 比如，$1 \\rightarrow 4 \\rightarrow 9 \\rightarrow 13 \\rightarrow 14$ 就是一条重链，而 $2 \\rightarrow 6 \\rightarrow 11$ 也是另一条重链； 另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子， 例如 $top[3]\\ =\\ 3$； 回顾一下，还有哪些信息没有维护呢？ $dfn,\\ pre,\\ top$ 其实，这三个只需要另一个递归函数就足够啦！ 12345678void dfs2(int u, int tp) // u 是当前结点，tp 是 u 所在重链的链首 top[u] = tp dfn[u] = ++tot // tot 是时间戳 pre[tot] = u // pre 是 dfn 的反函数 if(wson[u]) dfs2(wson[u], tp); // 只要 u 有重儿子，那就可以继续下去 for each v that connects to u : if(v != fa[u] &amp;&amp; v != wson[u]) // v 是 u 的轻儿子 dfs2(v, v); // 轻儿子是重链的链首 图中边上的数字就是 $dfs2$ 递归的顺序，不明白的可以参考一下。 检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？ $Answer:\\ 10,\\ 8$。 好了，树链剖分阶段到此结束。 将这棵树剖分成了许多链，现在就可以用线段树维护了~ 写上了一段带修改查询的线段树模板。。。 现在轮到处理问题的阶段了。 为了便于理解，我们就先实现两个最基础的操作吧： 路径点权求和、路径点权修改 大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。 举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。） 图片没了吗？可以到百度百科上看 为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。 这个和倍增求 $LCA$ 有点像。 先找到 $dep$ 更深的结点，$11$（$dep[11]\\ &gt;\\ dep[9]$） 将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和 我们可以用事先维护好的 $dfn$ 来帮助 由于 $top[11]\\ =\\ 2$，所以我们在求 $2=&gt;11$ 的和 我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！ 线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$ res += query(root, dfn[top[11]], dfn[11]) 这是，操作变成了求 $res\\ +\\ 9 \\Rightarrow11$ 的路径点权和。 所以我们将 $11$ 变为 $fa[top[11]]\\ =\\ 1$ 这是，我们发现 $1$ 和 $9$ 共链了。 所以像刚才一样， res += query(root, dfn[1], dfn[9]) 即可！ 将上面的步骤转化成代码： 1234567891011void Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; // 只要不共链 if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); // 每次都要让 top 深一些的往上跳 res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); // 注意大小关系！ res += query(root, left, right); return res;&#125; 很简单吧！ 修改操作类似， 12345678910vois Qchange(int u, int v, int d) &#123; // u 到 v 的路径上点权加 d int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125; 除了这两个基础操作以外，还有一类比较常见的操作：子树。 其实这种操作比刚才两种还简单。 我们考虑以 $2$ 为根的子树： 图片没了吗？可以到百度百科上看 不难发现，这棵子树里所有结点的 $dfn$ 是连续的。为什么呢？因为 $dfn$ 是通过 $dfs$ 得到的。 因此很显然在这整棵子树中， $dfn$ 最小的那个结点就是子树的根。而最大的则是 $dfn + size - 1$ 。 （其中 $size$ 是这棵子树的大小） 所以代码只需要一句话， 1234567inline int Tsum(int u) &#123; // 询问以 u 为根的子树 return query(root, dfn[u], dfn[u] + size[u] - 1);&#125;inline void Tchange(int u, int d) &#123; // 修改以 u 为根的子树 change(root, dfn[u], dfn[u] + size[u] - 1, d);&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];int dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存线段树 int left, right, s, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[wson[u]]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; // 线段树模板 r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = w[pre[left]]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; // 线段树模板 if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 线段树模板 r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return query(r-&gt;ls, left, r-&gt;ls-&gt;right) + query(r-&gt;rs, r-&gt;rs-&gt;left, right);&#125;inline int Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); res += query(root, left, right); return res;&#125;inline void Qchange(int u, int v, int d) &#123; int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125;int main() &#123; int op, u, v, d; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); // 读入点权 for(int i = 1; i &lt; n; i++) &#123; // 读图 scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; // 这步不能忘，否则 dfs1 没用！ dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(m--) &#123; // 操作 scanf(\"%d%d%d\", &amp;op, &amp;u, &amp;v); if(op == 1) printf(\"%d\\n\", Qsum(u, v)); else &#123; scanf(\"%d\", &amp;d); Qchange(u, v, d); &#125; &#125; return 0;&#125; Examples【模板】 树链剖分 「SDOI2011」 染色","tags":[{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"}]},{"title":"「BZOJ5165」树上倍增","date":"2019-02-02T09:59:01.000Z","path":"2019/02/02/[BZOJ5165] 树上倍增/","text":"Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\\leq 3 \\times 10^6$ ，操作次数 $m \\leq 10^3$，$k \\leq 10^3$ 题目链接： BZOJ P5165 Solution思路题目名称已经给了好嘛。。。 就是倍增啊。。 其实这题的难点不是在于思路想法，而是在于卡空间！ 操作1 $A \\ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1$。 维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$ 具体的维护方法见下面的代码 1234567dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = 1st[i][j] = k 代表 编号为i的节点向上跳2 ^ j个点到编号为k的节点因此st[i][0]即为节点i的父亲dep[++n] = dep[x] + 1; // 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号for(int i = 20; i &gt;= 0; i--) // 2 ^ 21 &gt; 3e6，因此只需维护到20即可 st[n][i] = st[st[n][i - 1]][i - 1]; // 倍增数组标准维护语句 操作2 $Q \\ k\\ p1\\ p2\\ p3\\ …$ 查询$p1,\\ p2,\\ p3\\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。 这个我想没什么好讲的吧。 就是依次求$LCA$就行啦。如果不懂详见代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 3000003int n = 1, m, dep[MAXN], st[MAXN][21], P;char ch[2]; // 读入操作用，char可能会咕掉inline void insert(int x) &#123; // 新建节点操作，上文讲过 dep[++n] = dep[x] + 1, st[n][0] = x; for(register int i = 1; i &lt;= 20; i++) st[n][i] = st[st[n][i - 1]][i - 1];&#125;inline int LCA(int u, int v) &#123; // 基本的LCA操作，不解释 if(dep[u] &gt; dep[v]) swap(u, v); for(register int i = 20; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(register int i = 20; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return st[u][0];&#125;int main() &#123; int k, lca; dep[1] = 1; // 将root的深度设为1 scanf(\"%d\", &amp;m); while(m--) &#123; scanf(\"%s%d\", ch, &amp;k); if(ch[0] == 'A') insert(k); else &#123; scanf(\"%d\", &amp;lca); //依次求LCA for(register int i = 1; i &lt; k; i++) scanf(\"%d\", &amp;P), lca = LCA(lca, P); printf(\"%d\\n\", lca); &#125; &#125;&#125;","tags":[{"name":"优化","slug":"优化","permalink":"http://tle666.github.io/tags/优化/"},{"name":"LCA","slug":"LCA","permalink":"http://tle666.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://tle666.github.io/tags/倍增/"}]},{"title":"快速读入详解","date":"2019-01-27T03:41:50.000Z","path":"2019/01/27/快速读入详解/","text":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 常数 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\\overline{abcd} = 10 \\times (10 \\times (10 \\times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \\times |n|$，其中$sgn(x)$为$x$的符号。","tags":[{"name":"优化","slug":"优化","permalink":"http://tle666.github.io/tags/优化/"}]},{"title":"浅谈二分","date":"2019-01-27T03:39:50.000Z","path":"2019/01/27/浅谈二分/","text":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \\in \\mathbb{Z}$，即整数$mid = \\lfloor \\dfrac{a + b}{2} \\rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 函数求零点 $L = 0, R = 4, mid = \\lfloor \\dfrac{0 + 4}{2} \\rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \\lfloor \\dfrac{0 + 2}{2} \\rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \\times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \\lfloor \\dfrac{L + R}{2} \\rfloor = 50$，设答案为$ans$。 只要$L \\leqslant R$，尝试$mid$，\\left\\{ \\begin{aligned} & 若mid > ans，则R = mid； \\\\ & 若mid < ans，则L = mid + 1； \\\\ & 若mid = ans，猜对了。 \\end{aligned} \\right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……","tags":[{"name":"二分答案","slug":"二分答案","permalink":"http://tle666.github.io/tags/二分答案/"}]},{"title":"「luogu1462」通往奥格瑞玛的道路","date":"2019-01-27T03:36:50.000Z","path":"2019/01/27/[luogu1462] 通往奥格瑞玛的道路/","text":"Description$n$个点$m$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b$短，并且经过的点权之和最大。 输出这个最大值 看完题面感觉语文要挂科。。。o(╥﹏╥)o Solution这题正解 $SPFA\\ +$ 二分 二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts(\"AFK\"); else printf(\"%d\\n\", left); return 0;&#125;","tags":[{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://tle666.github.io/tags/SPFA/"}]},{"title":"「CQOI2009」中位数","date":"2019-01-27T03:33:40.000Z","path":"2019/01/27/[CQOI2009] 中位数/","text":"Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \\leq 100000,\\ 1 \\leq b \\leq n$。 题目传送门Solution标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf(\"%d\",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf(\"%d\\n\",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;","tags":[{"name":"哈希","slug":"哈希","permalink":"http://tle666.github.io/tags/哈希/"}]},{"title":"并查集入门","date":"2018-10-04T03:21:10.000Z","path":"2018/10/04/并查集/","text":"并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\\n\",ans); return 0;&#125;","tags":[{"name":"并查集","slug":"并查集","permalink":"http://tle666.github.io/tags/并查集/"}]}]