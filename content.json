{"meta":{"title":"P_Wang's Blog","subtitle":"自己选择的路，跪着也要走完。","description":"OIer!","author":"P_Wang","url":"http://tle666.github.io"},"pages":[{"title":"","date":"2019-02-02T10:18:16.311Z","updated":"2019-02-02T10:18:16.311Z","comments":true,"path":"baidu_verify_o1tQMBIJO5.html","permalink":"http://tle666.github.io/baidu_verify_o1tQMBIJO5.html","excerpt":"","text":"o1tQMBIJO5"},{"title":"","date":"2019-03-10T07:01:41.991Z","updated":"2019-03-10T07:01:41.991Z","comments":true,"path":"baidu_verify_U51fhF2DWG.html","permalink":"http://tle666.github.io/baidu_verify_U51fhF2DWG.html","excerpt":"","text":"U51fhF2DWG"},{"title":"关于","date":"2018-08-31T07:13:58.000Z","updated":"2019-01-27T05:28:08.406Z","comments":true,"path":"about/index.html","permalink":"http://tle666.github.io/about/index.html","excerpt":"","text":"本人乃无实力瑟瑟发抖萌新OIer 欢迎加QQ随时吊打我哦~ QQ：3271252272"},{"title":"文章分类","date":"2018-08-31T07:16:02.000Z","updated":"2018-08-31T07:20:06.448Z","comments":true,"path":"categories/index.html","permalink":"http://tle666.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-01-26T14:17:50.000Z","updated":"2019-03-31T03:32:20.775Z","comments":true,"path":"friends/index.html","permalink":"http://tle666.github.io/friends/index.html","excerpt":"","text":"常用网站网址洛谷 | BZOJ | Graph Editor | 图床 | OIerDb | BZOJ离线题库 | DarkBzoj 同学$AcF’s\\ Blog$ $HLT’s\\ Blog$ $WZL’s\\ Blog$ $TLL’s\\ Blog$ 欢迎互换友链！"},{"title":"标签","date":"2018-08-31T07:15:42.000Z","updated":"2018-08-31T07:20:43.294Z","comments":true,"path":"tags/index.html","permalink":"http://tle666.github.io/tags/index.html","excerpt":"","text":""},{"title":"搜索","date":"2018-08-31T09:49:52.000Z","updated":"2018-08-31T09:51:16.269Z","comments":true,"path":"search/index.html","permalink":"http://tle666.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"「SPOJ1811」LCS - Longest Common Substring","slug":"[SPOJ1811] LCS - Longest Common Substring","date":"2019-04-27T12:34:13.000Z","updated":"2019-04-27T12:55:22.895Z","comments":true,"path":"2019/04/27/[SPOJ1811] LCS - Longest Common Substring/","link":"","permalink":"http://tle666.github.io/2019/04/27/[SPOJ1811] LCS - Longest Common Substring/","excerpt":"Description输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出0 。 对于$100 \\%$的数据，$|S| \\leq 250000$","text":"Description输入$2$个长度不大于$250000$的字符串，只由小写英文字母构成，要求输出这$2$个字符串的最长公共子串长度。如果没有公共子串则输出0 。 对于$100 \\%$的数据，$|S| \\leq 250000$ 题目链接戳这里 Solution这道题可以作为后缀数组的练手题。调了5个小时。。。 后缀数组是对一个字符串的操作啊，那这道题不是2个嘛？ 把它整到一个里面就行啦！ 忽然想到$Manacher$算法，中间每两个字符不是用$隔开了吗？ 对啊！ 就在两个单词中间加个$就行啦~ 举个栗子： S_1 = \"firststring\"S_2 = \"secondstring\"（双引号不包括在字符串中） 则整合后的字符串 S = \"firststring$secondstring\"很简单吧、 于是这个问题就转化为了在一个字符串里找最长重复子串啦 ——这不就是$height$数组嘛 但是注意有一个小条件 两个最长子串必须在不同的单词之间哦！ 这个随便判断一下就行啦。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000100;char s[2][N];int n, m, ans, len, x[N], y[N];int rk[N], sa[N], h[N], c[N], a[N];// 其中 h 数组就是 height 数组inline void rsort() &#123; for(int i = 1; i &lt;= m; i++) c[i] = 0; for(int i = 1; i &lt;= n; i++) c[x[i]]++; for(int i = 2; i &lt;= m; i++) c[i] += c[i - 1]; for(int i = n; i &gt;= 1; i--) sa[c[x[y[i]]]--] = y[i];&#125;inline void getSA() &#123; int p = 0; for(int i = 1; i &lt;= n; i++) x[i] = a[i], y[i] = i; rsort(); for(int k = 1; k &lt;= n &amp;&amp; p &lt; n; k &lt;&lt;= 1) &#123; p = 0; for(int i = n - k + 1; i &lt;= n; i++) y[++p] = i; for(int i = 1; i &lt;= n; i++) if(sa[i] &gt; k) y[++p] = sa[i] - k; rsort(); swap(x, y); x[sa[1]] = 1, p = 2; for(int i = 2; i &lt;= n; i++) if(y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = p - 1; else x[sa[i]] = p++; m = p; &#125;&#125;inline void getH() &#123; for(int i = 1; i &lt;= n; i++) rk[sa[i]] = i; int L = 0, j; for(int i = 1; i &lt;= n; i++) &#123; j = sa[rk[i] - 1]; if(L) L--; while(a[i + L] == a[j + L]) L++; h[rk[i]] = L; &#125;&#125;int main() &#123; scanf(\"%s%s\", s[0], s[1]); len = n = strlen(s[0]), m = strlen(s[1]); n += m + 1, m = 128; for(int i = 1; i &lt;= len; i++) a[i] = s[0][i - 1]; a[len + 1] = '$'; for(int i = len + 2; i &lt;= n; i++) a[i] = s[1][i - len - 2]; getSA(); getH(); for(int i = 2; i &lt;= n; i++) if((sa[i] &gt; len &amp;&amp; sa[i - 1] &lt; len) || (sa[i] &lt; len &amp;&amp; sa[i - 1] &gt; len)) ans = max(ans, h[i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://tle666.github.io/tags/后缀数组/"}]},{"title":"「BZOJ2561」最小生成树","slug":"[BZOJ2561] 最小生成树","date":"2019-03-27T12:53:07.000Z","updated":"2019-03-27T13:11:38.931Z","comments":true,"path":"2019/03/27/[BZOJ2561] 最小生成树/","link":"","permalink":"http://tle666.github.io/2019/03/27/[BZOJ2561] 最小生成树/","excerpt":"Description一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)​$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。 对于$100\\%$的数据，$N,\\ L \\leq 20000$，$M \\leq 200000$","text":"Description一个$N$个点，$M$条边的带边权的连通无向图，假设现在加入一条边权为$L$的边$(u,v)​$，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。 对于$100\\%$的数据，$N,\\ L \\leq 20000$，$M \\leq 200000$ 题目链接戳这里 Solution思路妙啊！ 如果$L$那条边可能出现在最小生成树上，那么就有边权$&lt;L$的边不能连通其两端点$(u, v)$，否则将$u$和$v$连起来再删除$L$那条边显然更小。这不就是最小割嘛！ 最大生成树也同理，于是答案就是两次最小割之和。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200200;const int INF = 0x7f7f7f7f;int n, m, S, T, L, lev[N], ans;struct edge &#123; int v, c; edge *next, *rev;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct node &#123; int u, v, c;&#125; a[N];inline void clear() &#123; memset(pool, 0, sizeof(pool)), memset(h, NULL, sizeof(h)), cnt = pool;&#125;inline void addedge(int u, int v, int c) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;c = c, p-&gt;next = h[u], h[u] = p, p-&gt;rev = q; q-&gt;v = u, q-&gt;c = c, q-&gt;next = h[v], h[v] = q, q-&gt;rev = p;&#125;inline bool makelev() &#123; int u, v; memset(lev, -1, sizeof(lev)); queue&lt;int&gt; Q; Q.push(S), lev[S] = 0; while(!Q.empty()) &#123; u = Q.front(), Q.pop(); for(edge *p = h[u]; p; p = p-&gt;next) if(!(lev[v = p-&gt;v] + 1) &amp;&amp; p-&gt;c &gt; 0) &#123; lev[v] = lev[u] + 1; Q.push(v); &#125; &#125; return (lev[T] != -1);&#125;inline int dfs(int u, int flow) &#123; int v, res = 0, f; if(u == T) return flow; for(edge *p = h[u]; p; p = p-&gt;next) if(lev[v = p-&gt;v] == lev[u] + 1 &amp;&amp; p-&gt;c &gt; 0) &#123; f = dfs(v, min(p-&gt;c, flow)); flow -= f, p-&gt;c -= f; res += f, p-&gt;rev-&gt;c += f; if(!flow) break ; &#125; if(!res) lev[u] = -1; return res;&#125;inline int dinic() &#123; int res = 0; while(makelev()) res += dfs(S, INF); return res;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) scanf(\"%d%d%d\", &amp;a[i].u, &amp;a[i].v, &amp;a[i].c); scanf(\"%d%d%d\", &amp;S, &amp;T, &amp;L); for(int i = 1; i &lt;= m; i++) if(a[i].c &gt; L) addedge(a[i].u, a[i].v, 1); // 注意这里的边权 ans += dinic(); clear(); for(int i = 1; i &lt;= m; i++) if(a[i].c &lt; L) addedge(a[i].u, a[i].v, 1); // 这里也是 ans += dinic(); printf(\"%d\\n\", ans); return 0;&#125;/*3 23 2 11 2 31 2 2*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://tle666.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"http://tle666.github.io/tags/最大流/"},{"name":"最小割","slug":"最小割","permalink":"http://tle666.github.io/tags/最小割/"}]},{"title":"「HDU6203」ping ping ping","slug":"[HDU6203] ping ping ping","date":"2019-03-21T14:25:47.000Z","updated":"2019-03-27T13:04:57.485Z","comments":true,"path":"2019/03/21/[HDU6203] ping ping ping/","link":"","permalink":"http://tle666.github.io/2019/03/21/[HDU6203] ping ping ping/","excerpt":"Description$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 U V 无法连通。问无法通行的点最少有多少个。 对于$100 \\%$的数据，$3 \\leq n \\leq 10^4$，$p \\leq 5 \\times 10^4$","text":"Description$n+1$个点$n$条边的树（点标号 $0-n$），有若干个点无法通行，导致 $p$ 组 U V 无法连通。问无法通行的点最少有多少个。 对于$100 \\%$的数据，$3 \\leq n \\leq 10^4$，$p \\leq 5 \\times 10^4$ 题目链接戳这里 Solution考虑到我们要求的是$u$到$v$上不能通行，很显然 能想到可以通过树上前序与后序$DFS$序来维护。具体方法如下： 根据所给的树预处理出每个点的前序 $DFS$ 序和后序$DFS$ 序（需一起标号），和每个点的深度。 根据 $p$ 组 U V 处理每组两点之间的 $LCA$ 。压入优先队列（$LCA$ 深度大的点优先，即往前走）。 对于出队的U V及其对应的 $LCA$ ，判断点 $U$ 或点 $V$ 是否在之前已禁止的某点的子树中。 判断点 $U$ 或点 $V​$ 是否在之前已禁止的某点的子树中。 处理方式：由于之前已经处理出每个点的前后序 $DFS$ 序 $in$ 和 $out$ 。 对于某点 $U$ 若在已禁止通行点 $P$ 的子树中，则 $In[P]≤In[U]≤Out[U]≤Out[P]In[P]≤In[U]≤Out[U]≤Out[P]$ 一定成立。 故利用树状数组区间更新单点查询。对每个禁止通行点 $P$ ，标记区间 $[In[P],Out[P]][In[P],Out[P]]$ 中所有点。查询时，若点 $In[U]$ 被标记，则说明 U V 已经被隔断。 同时，由于优先处理 $LCA$ 深度大的点，不会出现点 U V 同时在同一个被禁止通行点 $P$ 的子树内。 若 $U$ ，$V$ 均不在被禁止的点在子树内，则禁止 U V 的 $LCA$ 点，同时对答案贡献 $+1$ 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100100;int n, p, in[N], out[N], tot, dep[N];int st[N][25], fa[N], C[N &lt;&lt; 1], ans;bool vis[N];struct edge &#123; int v; edge *next;&#125; pool[N &lt;&lt; 1], *h[N], *cnt = pool;struct P &#123; int u, v, lca; inline bool operator &lt; (const P &amp;x) const &#123; return dep[lca] &lt; dep[x.lca]; &#125;&#125; rec;priority_queue&lt;P&gt; pq;inline void prework() &#123; // 注意多组数据的清空 ans = tot = 0, cnt = pool, tot = 0; while(!pq.empty()) pq.pop(); memset(h, NULL, sizeof(h)), memset(pool, 0, sizeof(pool)), memset(in, 0, sizeof(in)), memset(out, 0, sizeof(out)), memset(dep, 0, sizeof(dep)), memset(st, 0, sizeof(st)), memset(fa, 0, sizeof(fa)), memset(vis, false, sizeof(vis)), memset(C, 0, sizeof(C));&#125;inline void addedge(int u, int v) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u, int depth) &#123; int v; in[u] = ++tot; dep[u] = depth, vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u; dfs(v, depth + 1); &#125; out[u] = ++tot;&#125;inline int LCA(int u, int v) &#123; if(dep[u] &gt; dep[v]) swap(u, v); for(int i = 19; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(int i = 19; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return fa[u];&#125;inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline int sum(int x) &#123; int res = 0; for(; x; x -= lowbit(x)) res += C[x]; return res;&#125;inline void change(int x, int d) &#123; for(; x &lt; (N &lt;&lt; 1); x += lowbit(x)) C[x] += d;&#125;inline void work() &#123; // 主要函数 int u, v; prework(); for(int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(++u, ++v); &#125; ++n, dfs(1, 1); for(int i = 1; i &lt;= n; i++) st[i][0] = fa[i]; for(int i = 1; i &lt;= 20; i++) for(int j = 1; j &lt;= n; j++) st[j][i] = st[st[j][i - 1]][i - 1]; scanf(\"%d\", &amp;p); for(int i = 1; i &lt;= p; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); rec.u = ++u, rec.v = ++v, rec.lca = LCA(u, v); pq.push(rec); &#125; while(!pq.empty()) &#123; rec = pq.top(), pq.pop(); if(!(sum(in[rec.u]) + sum(in[rec.v]))) change(in[rec.lca], 1), change(out[rec.lca] + 1, -1), ans++; &#125; printf(\"%d\\n\", ans);&#125;int main() &#123; while(scanf(\"%d\", &amp;n) != EOF) work(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"LCA","slug":"LCA","permalink":"http://tle666.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://tle666.github.io/tags/倍增/"},{"name":"树状数组","slug":"树状数组","permalink":"http://tle666.github.io/tags/树状数组/"},{"name":"DFS序","slug":"DFS序","permalink":"http://tle666.github.io/tags/DFS序/"}]},{"title":"「SPOJ1043」GSS1","slug":"[SPOJ1043] GSS1","date":"2019-03-17T01:51:27.000Z","updated":"2019-03-27T13:06:21.584Z","comments":true,"path":"2019/03/17/[SPOJ1043] GSS1/","link":"","permalink":"http://tle666.github.io/2019/03/17/[SPOJ1043] GSS1/","excerpt":"Description给一段可能有负数的序列，查询最大子段和。 对于$100 \\%$的数据，序列长度$N \\leq 50000$，$a[i] \\leq 15007$","text":"Description给一段可能有负数的序列，查询最大子段和。 对于$100 \\%$的数据，序列长度$N \\leq 50000$，$a[i] \\leq 15007$ 题目链接戳这里 Solution线段树查询最大子段和。 这里需要维护四个信息： $s$ 区间和 $mx$ 区间最大子段和 $lmx$ 区间前缀和最大值 $rmx$ 区间后缀和最大值 则维护的时候就像这样 1234s = ls-&gt;s + rs-&gt;s,mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), // 注意有三种情况lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx),rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); 其中$ls​$，$rs​$分别是左子，右子。 还有一个注意事项：$query$（查询）的时候返回值要是$node*$！只有这样才能够维护四个信息。 Code码风在这种题里很重要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 1001000;int n, m, a[MAXN];struct node &#123; int left, right, mx, lmx, rmx, s; node *ls, *rs; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s, mx = max(ls-&gt;rmx + rs-&gt;lmx, max(ls-&gt;mx, rs-&gt;mx)), lmx = max(ls-&gt;lmx, ls-&gt;s + rs-&gt;lmx), rmx = max(rs-&gt;rmx, rs-&gt;s + ls-&gt;rmx); &#125;&#125; pool[MAXN &lt;&lt; 5], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = r-&gt;mx = r-&gt;lmx = r-&gt;rmx = a[left]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline node *query(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else &#123; node *L, *R, *res; L = query(r-&gt;ls, left, r-&gt;ls-&gt;right), R = query(r-&gt;rs, r-&gt;rs-&gt;left, right), res = ++cnt, res-&gt;s = L-&gt;s + R-&gt;s, res-&gt;left = L-&gt;left, res-&gt;right = R-&gt;right, res-&gt;mx = max(L-&gt;rmx + R-&gt;lmx, max(L-&gt;mx, R-&gt;mx)), res-&gt;lmx = max(L-&gt;s + R-&gt;lmx, L-&gt;lmx), res-&gt;rmx = max(R-&gt;s + L-&gt;rmx, R-&gt;rmx); return res; &#125;&#125;int main() &#123; int left, right; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); build(root = cnt, 1, n); scanf(\"%d\", &amp;m); while(m--) &#123; scanf(\"%d%d\", &amp;left, &amp;right); printf(\"%d\\n\", query(root, left, right)-&gt;mx); &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"}]},{"title":"「ZJOI2009」时态同步","slug":"[ZJOI2009] 时态同步","date":"2019-03-15T14:46:47.000Z","updated":"2019-03-27T13:06:47.550Z","comments":true,"path":"2019/03/15/[ZJOI2009] 时态同步/","link":"","permalink":"http://tle666.github.io/2019/03/15/[ZJOI2009] 时态同步/","excerpt":"Description一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。 对于$100\\%$的数据，$N \\leq 500000$，边权$t_e \\leq 1000000$。","text":"Description一棵有$N$个结点，带边权的有根树，求至少需要增加多少边权才能使根结点到叶子结点的所有路径的权值和相同。 对于$100\\%$的数据，$N \\leq 500000$，边权$t_e \\leq 1000000$。 题目连接戳这里 Solution树形$DP$的板子题。 令$dp_x$为叶子结点到$x$结点的最大时间。 则有 $dp_x = \\max (dp_{son[x]} + dis_{x,\\ son[x]})$ 因此 $ans = \\sum (dp_x - dp_{son[x]} - dis_{x,\\ son[x]})$ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 500500#define int long longint n, root, dp[MAXN], ans, fa[MAXN];bool vis[MAXN];struct edge &#123; int v, w; edge *next;&#125; pool[MAXN &lt;&lt; 1], *h[MAXN], *cnt = pool;inline void addedge(int u, int v, int w) &#123; edge *p = ++cnt, *q = ++cnt; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs(int u) &#123; int v; vis[u] = true; for(edge *p = h[u]; p; p = p-&gt;next) if(!vis[v = p-&gt;v]) &#123; fa[v] = u, dfs(v); dp[u] = max(dp[u], dp[v] + p-&gt;w); &#125; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u]) ans += (dp[u] - dp[v] - p-&gt;w);&#125;signed main() &#123; int u, v, w; scanf(\"%lld%lld\", &amp;n, &amp;root); for(int i = 1; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; dfs(root); printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://tle666.github.io/tags/树形DP/"}]},{"title":"「SCOI2009」windy 数","slug":"[SCOI2009] windy数","date":"2019-03-10T05:40:03.000Z","updated":"2019-03-27T13:06:03.951Z","comments":true,"path":"2019/03/10/[SCOI2009] windy数/","link":"","permalink":"http://tle666.github.io/2019/03/10/[SCOI2009] windy数/","excerpt":"Description求$A$，$B$之间所有满足相邻两位之间差$\\geq2$的整数。","text":"Description求$A$，$B$之间所有满足相邻两位之间差$\\geq2$的整数。 对于$100$%的数据， $1 \\leq A \\leq B \\leq 2 \\times 10^9$。 Solution数位$DP$模板题。 令$dp_{i,j}$表示第$i$位，上一位为$j$的总方案数（一直到结束）。 然后逐位$DP$即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;ll dp[110][11], d[110];inline ll calc(int x, int p) &#123; if(dp[x][p] + 1) return dp[x][p]; if(!x) return dp[x][p] = 1; ll res = 0; for(int q = 0; q &lt; 10; q++) if(abs(p - q) &gt;= 2) res += calc(x - 1, q); return dp[x][p] = res;&#125;inline ll solve(ll x) &#123; int m = 0, ans = 0, pre = -110; while(x) d[m++] = x % 10, x /= 10; for(int i = 1; i &lt; m; i++) for(int j = 1; j &lt;= 9; j++) ans += calc(i - 1, j); for(int i = m - 1; i &gt;= 0; i--) &#123; for(int j = (i == m - 1); j &lt; d[i]; j++) if(abs(pre - j) &gt;= 2) ans += calc(i, j); if(abs(pre - d[i]) &lt; 2) break ; pre = d[i]; &#125; return ans;&#125;int main() &#123; ll l, r; memset(dp, -1, sizeof(dp)); scanf(\"%lld%lld\", &amp;l, &amp;r); printf(\"%lld\\n\", solve(r + 1) - solve(l)); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"http://tle666.github.io/tags/DP/"},{"name":"数位DP","slug":"数位DP","permalink":"http://tle666.github.io/tags/数位DP/"}]},{"title":"非旋 Treap 详解","slug":"非旋Treap详解","date":"2019-03-09T14:23:07.000Z","updated":"2019-03-10T05:32:36.868Z","comments":true,"path":"2019/03/09/非旋Treap详解/","link":"","permalink":"http://tle666.github.io/2019/03/09/非旋Treap详解/","excerpt":"Introduction “$Treap$的旋转好难啊！” “你不知道非旋$treap$吗？” （被一顿吊打。。 这就是$FHQ-Treap$。","text":"Introduction “$Treap$的旋转好难啊！” “你不知道非旋$treap$吗？” （被一顿吊打。。 这就是$FHQ-Treap$。 前置技能：小根堆 &amp; $Treap$（不必须） 提示：此博客图片较多，如无法加载请刷新重试~ Definition12345678struct node &#123; int d, rnd, size; node *ls, *rs; inline void upd() &#123; &#125; inline void push() &#123; &#125;&#125; pool[MAXN &lt;&lt; 1], *root, *cnt = pool; $d$是真实权值，$rnd$是随机权值，$size$是子树大小； $ls$是左儿子，$rs$是右儿子； $upd$是从下往上更新信息（例如$size$）； $push$是下发懒标记。 $root$是根。 OperationsMerge 假设有两颗子树x，y，且 x 的所有节点的值都小于 y 的所有节点的值，随机权值 rnd 都以小根堆的形式存储。 此时要合并 x , y 。我们先比较它们的根的随机权值，发现1&lt;3，因为要满足小根堆性质，于是 x 的左子树全部不变，让它的右子树继续和 y 合并。 这时我们发现，随机权值 rnd 5&gt;3，所以 y 接到 root(图中rot) 的下方，成为 root 的右儿子，y的右子树全部不变，让y的左子树继续和x合并（以满足平衡树的性质）。 由于5&gt;4，所以y和y的右子树作为root的左儿子，y的左子树继续和x合并。 以此类推…… 最后，我们发现 x 为 0 ，所以直接返回 y ，合并结束。 Code1234567891011inline node *merge(node *l, node *r) &#123; if(!l || !r) return l ? l : r; // 如果有一边为空 if(l-&gt;rnd &lt; r-&gt;rnd) &#123; l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r); l-&gt;upd(); return l; &#125; else &#123; r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls); r-&gt;upd(); return r; &#125;&#125; Split1.按权值split首先得有个基准值 a ，即权值小于等于 a 的节点全部进入左树（下图中会将此类节点染红），大于a的节点全部进入右树（下图中会将此类节点染蓝）。这里以a=25为例。 首先，发现rot的权值=15&lt;25，由平衡树的性质可知，rot的左子树所有节点权值一定小于25，所以rot和它的的左子树全部进入左树，继续拆分rot的右子树。 32&gt;25，所以 rot 和它的右子树全部进入右树，继续拆分 rot 的左子树。 29&gt;25，同上。 24&lt;25，所以拆分右子树。 27&gt;25，所以拆分左子树。 发现此时rot为0，所以拆分完毕，返回。 2.按排名split就是把前 k 个节点拆入左树，其它节点拆入右树。这里以k=5为例。 rot的左子树的siz+1=3&lt;5，所以rot和它的左子树进入左树，其他节点拆分5-3=2个节点进入左树。 4+1&gt;2，所以rot和右子树进入右树，其它节点继续拆分出2个节点进入左树。 3+1&gt;2，同上。 1+1=2，所以rot和左子树进入左树，其它节点继续拆分2-2=0个节点进入左树。 1+0&gt;0，所以rot和右子树进入右树，其它节点继续拆分0个节点进入左树。 rot为0，拆分结束。 Code12345678// 按排名分inline void split(node *p, node *&amp;l, node *&amp;r, int k) &#123; if(!p) &#123; l = r = NULL; return ;&#125; p-&gt;push(); if(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k); else l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - 1); p-&gt;upd();&#125; Other OperationsFHQ treap 的核心操作只有 merge 和 split 两个，其他操作都是基于这两个操作实现的。 插入插入权值为 x 的节点时，先新建一个节点，再以 x 为界按权值 split 整棵树为a,b，再按顺序 merge a，x，b。 删除要删除x，先将整棵树以 x-1 为界按权值split 成a和b，再将 b 以 1 为界 按排名split 成c和d，则 c 就是要删除的节点。最后按顺序merge a，b，d。 （当然，这是在要删除节点必定存在的情况下才能进行的操作，不存在的情况请自行脑补） 查询 x 的排名先将整棵树以x-1按权值split成a和b，则a的siz+1即为x的排名。 查询排名为 k 的值先split出整棵树前k-1小节点，则右树最小节点即为所求节点，再次split 即可。 查x前驱将整棵树以x-1按权值split，左树中最大节点即为所求节点，转入第x小值问题。 查x后继将整棵树以x按权值split，右树中最小节点即为所求节点，转入第x小值问题。 Problems文艺平衡树 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100#define size(a) ((a) ? a-&gt;size : 0)int n, m;struct node &#123; int d, rnd, size, tag; node *ls, *rs; inline void sets() &#123; tag ^= 1;&#125; inline void upd() &#123; size = size(ls) + size(rs) + 1;&#125; inline void push() &#123; if(tag) &#123; swap(ls, rs); if(ls) ls-&gt;sets(); if(rs) rs-&gt;sets(); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 1], *root, *cnt = pool;inline node *newnode(int d) &#123; // 新建 node *p = ++cnt; p-&gt;d = d, p-&gt;rnd = (rand() &lt;&lt; 15) + rand(), p-&gt;size = 1, p-&gt;tag = 0; return p;&#125;inline node *merge(node *l, node *r) &#123; if(!l || !r) return l ? l : r; if(l-&gt;rnd &lt; r-&gt;rnd) &#123; l-&gt;push(), l-&gt;rs = merge(l-&gt;rs, r); l-&gt;upd(); return l; &#125; else &#123; r-&gt;push(), r-&gt;ls = merge(l, r-&gt;ls); r-&gt;upd(); return r; &#125;&#125;inline void split(node *p, node *&amp;l, node *&amp;r, int k) &#123; if(!p) &#123; l = r = NULL; return ;&#125; p-&gt;push(); if(size(p-&gt;ls) &gt;= k) r = p, split(p-&gt;ls, l, p-&gt;ls, k); else l = p, split(p-&gt;rs, p-&gt;rs, r, k - size(l-&gt;ls) - 1); p-&gt;upd();&#125;inline int rk(node *p, int x) &#123; // 排名 if(!p) return 0; p-&gt;push(); if(p-&gt;d &gt;= x) return rk(p-&gt;ls, x); else return size(p-&gt;ls) + 1 + rk(p-&gt;rs, x);&#125;inline void rev(int l, int r) &#123; // 翻转 node *p, *q, *s; split(root, p, q, l - 1), split(q, q, s, r - l + 1); q-&gt;tag ^= 1, root = merge(merge(p, q), s);&#125;inline void print(node *r) &#123; // 输出 r-&gt;push(); if(r-&gt;ls) print(r-&gt;ls); printf(\"%d \", r-&gt;d); if(r-&gt;rs) print(r-&gt;rs);&#125;int main() &#123; srand((unsigned long long) new char); int left, right; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; node *tmp = newnode(i); root = merge(root, tmp); &#125; while(m--) &#123; scanf(\"%d%d\", &amp;left, &amp;right); rev(left, right); &#125; print(root); return 0;&#125; After Words此文章参考了部分以下文章，出处： https://www.cnblogs.com/Judge/p/9506980.html （这篇文章很优质！）","categories":[],"tags":[{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"fhq-treap","slug":"fhq-treap","permalink":"http://tle666.github.io/tags/fhq-treap/"}]},{"title":"「luogu1558」色板游戏","slug":"[luogu1558] 色板游戏","date":"2019-03-06T13:45:17.000Z","updated":"2019-03-27T13:05:38.271Z","comments":true,"path":"2019/03/06/[luogu1558] 色板游戏/","link":"","permalink":"http://tle666.github.io/2019/03/06/[luogu1558] 色板游戏/","excerpt":"Description对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作： 将$a[l]$到$a[r]$赋值为$d​$； 询问$a[l]​$到$a[r]​$有几种不同的数。 操作$m$次，$d \\in [1,\\ t]$ 对于$100​$%的数据， $1 \\leq n \\leq 100000$，$1 \\leq t \\leq 30$，$1 \\leq m \\leq 100000$","text":"Description对于长度为$n$的数组$a$初始值都为$1$，有两种不同的操作： 将$a[l]$到$a[r]$赋值为$d​$； 询问$a[l]​$到$a[r]​$有几种不同的数。 操作$m$次，$d \\in [1,\\ t]$ 对于$100​$%的数据， $1 \\leq n \\leq 100000$，$1 \\leq t \\leq 30$，$1 \\leq m \\leq 100000$ 题目链接戳这里 Solution线段树的基础题 然后我错了9遍 很有意思的一道题，有两种不同的解法 解法一比较暴力，建$t​$棵线段树即可。 第$i$棵线段树只存值为$i$的数组有哪些。 常数比较大。 $6$次提交，不开$O2$最高只能$80$分，就算开了$O2$也只能$90$。。 你们自己想卡常就卡去吧。。 我的$80​$分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, mx, tag; node *ls, *rs; inline void seta(int x) &#123; tag = x, mx = (x == 1 ? 1 : 0);&#125; inline void upd() &#123; mx = max(ls-&gt;mx, rs-&gt;mx);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 8], *root[35], *cnt = pool;inline void build1(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;mx = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build1(ls, left, mid), build1(rs, mid + 1, right); r-&gt;upd();&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) return ; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right);&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;mx; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;int main() &#123; int A, B, C, ans; n = read(), t = read(), m = read(); build1(root[1] = cnt, 1, n); for(int i = 2; i &lt;= t; i++) build(root[i] = ++cnt, 1, n); while(m--) &#123; scanf(\"%s\", ch); A = read(), B = read(); if(A &gt; B) swap(A, B); if(ch[0] == 'C') &#123; C = read(); for(int i = 1; i &lt;= t; i++) if(i != C) change(root[i], A, B, -1); else change(root[C], A, B, 1); &#125; else &#123; ans = 0; for(int i = 1; i &lt;= t; i++) ans += query(root[i], A, B); printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; 解法二$100$%的正解。 用二进制来表示区间的取值情况。 比如$a_1 = 1,\\ a_2 = 2,\\ a_3 = 3,\\ a_4 = 2$， 我们不妨设数值$i$是$2^{i - 1}$ 则1,2合起来就是0011； 1,3合起来就是0101； 注意：2,3,4合起来是0110而不是0120！ 大体上和解法一比较类似 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, t;char ch[2];inline int read() &#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125;struct node &#123; int left, right, s, tag; // s 就是存压位的那个。 node *ls, *rs; inline void seta(int x) &#123; s = (1 &lt;&lt; (x - 1)), tag = x;&#125; inline void upd() &#123; s = (ls-&gt;s | rs-&gt;s);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = 1; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return (query(r-&gt;ls, left, r-&gt;ls-&gt;right) | query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline int count(int x) &#123; int res = 0; for(int i = 30; i &gt;= 0; i--) if(x &gt;= (1 &lt;&lt; i)) x -= (1 &lt;&lt; i), res++; return res;&#125;int main() &#123; int left, right, d; n = read(), t = read(), m = read(); build(root = cnt, 1, n); while(m--) &#123; scanf(\"%s\", ch), left = read(), right = read(); if(left &gt; right) swap(left, right); if(ch[0] == 'C') &#123; d = read(); change(root, left, right, d); &#125; else printf(\"%d\\n\", count(query(root, left, right))); &#125; return 0;&#125;/*2 2 4C 1 1 2P 1 2C 2 2 2P 1 2*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"}]},{"title":"平面向量练习小结","slug":"平面向量练习小结","date":"2019-03-02T15:02:11.000Z","updated":"2019-03-03T01:14:02.267Z","comments":true,"path":"2019/03/02/平面向量练习小结/","link":"","permalink":"http://tle666.github.io/2019/03/02/平面向量练习小结/","excerpt":"最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。","text":"最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。 坐标表示法对于向量，我们能不能制定一种与坐标类似，与有序数对一一对应的方法呢？ 这就是向量的“万能方法”——坐标表示法。 对于向量$\\overrightarrow{AB}$，我们令$A$为坐标的原点，以两个夹角不为零的向量为坐标轴，不妨设$\\overrightarrow{p}$为$x$轴，$\\overrightarrow{q}$为$y$轴。我们可以将$\\overrightarrow{AB}$定义为$(x,\\ y)$，其中$x,y \\in \\mathbb{R}$。此时满足$\\overrightarrow{AB} = x \\overrightarrow{p} + y \\overrightarrow{q}$。 通常，为了方便起见，我们就将$\\overrightarrow{p}$和$\\overrightarrow{q}$设为$x$轴和$y$轴正半轴方向上的的单位向量。 这样，题目中复杂的条件就可以通过下面的公式化繁而简了。 一些有用的公式 在以下公式中，默认$\\overrightarrow{A} = (x_1,y_1),\\ \\overrightarrow{B} = (x_2,y_2)$ $\\overrightarrow{A} + \\overrightarrow{B} = (x_1 + y_1, x_2 + y_2)$ $\\overrightarrow{A} - \\overrightarrow{B} = (x_1 - y_1, x_2 - y_2)$ $\\overrightarrow{A} \\cdot \\overrightarrow{B} = x_1x_2+y_1y_2$ 由此我们可以推出 $\\cos&lt;\\overrightarrow{A}, \\overrightarrow{B}&gt; = \\frac{x_1x_2 + y_1y_2}{\\sqrt{x_1^2 + y_1^2} \\cdot \\sqrt{x_2^2 + y_2^2}}$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"},{"name":"平面向量","slug":"平面向量","permalink":"http://tle666.github.io/tags/平面向量/"}]},{"title":"「NOIP2011提高」Car的旅行路线","slug":"[NOIP2011提高] Car的旅行路线","date":"2019-03-02T14:29:03.000Z","updated":"2019-03-27T13:05:50.779Z","comments":true,"path":"2019/03/02/[NOIP2011提高] Car的旅行路线/","link":"","permalink":"http://tle666.github.io/2019/03/02/[NOIP2011提高] Car的旅行路线/","excerpt":"Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\\leq10$，矩形个数$\\leq100$。","text":"Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\\leq10$，矩形个数$\\leq100$。 题目链接戳这里 Solution打死我也不告诉你我Floyd模板打错了 通过$floyd$处理出任意两点（注意不是矩形）之间的最小费用即可。 但这道题细节还是不少的—— 只给你矩形的三个顶点 先通过勾股定理逆定理来求出哪个是直角，然后第四个点的坐标就出来了。 矩形可以是歪的，即它的边不一定平行于坐标轴。 多组数据注意初始化。 飞机和汽车费用不一样，需要分别计算。 最后只输出1位小数 $Hint$：两点间距离公式 $dis\\ =\\ \\sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2}$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 110int _, S, t, A, B, tot;double w[MAXN][MAXN], ans; // w 是两点间的最小费用inline double sq(int x) &#123; return (double)x * x;&#125;struct point &#123; int id, t, x, y; // id 城市编号，t 列车费用 inline void INIT(int _id, int _t, int _x, int _y) &#123; id = _id, t = _t, x = _x, y = _y; &#125; // 赋值函数（更简单的忘了怎么写了 QwQ inline double dis(point &amp;a) &#123; return sqrt(sq(x - a.x) + sq(y - a.y)); &#125; // 两点间距离 inline void rct(point &amp;a, point &amp;b, point &amp;c) &#123; id = a.id, t = a.t; int P = sq(a.x - b.x) + sq(a.y - b.y), Q = sq(b.x - c.x) + sq(b.y - c.y), R = sq(c.x - a.x) + sq(c.y - a.y); if(P + Q == R) x = a.x + c.x - b.x, y = a.y + c.y - b.y; else if(P + R == Q) x = b.x + c.x - a.x, y = b.y + c.y - a.y; else x = a.x + b.x - c.x, y = a.y + b.y - c.y; &#125; // 处理第四个点的坐标&#125; p[MAXN];inline void prework() &#123; static point P, Q; static double c, d; memset(w, 0x3f, sizeof(w)); for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) &#123; if(i == j) continue ; P = p[i], Q = p[j], d = P.dis(Q), c = 0.0; if(P.id == Q.id) c = d * P.t; else c = d * (double)t; w[i][j] = w[j][i] = c; &#125;&#125; // 处理距离，注意初始化int main() &#123; int x1, y1, x2, y2, x3, y3, _t; point p1, p2, p3, p4; scanf(\"%d\", &amp;_); while(_--) &#123; // 多组数据 scanf(\"%d%d%d%d\", &amp;S, &amp;t, &amp;A, &amp;B); tot = 0; for(int i = 1; i &lt;= S; i++) &#123; scanf(\"%d%d%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;_t); p1.INIT(i, _t, x1, y1), p2.INIT(i, _t, x2, y2), p3.INIT(i, _t, x3, y3), p4.rct(p1, p2, p3); p[++tot] = p1, p[++tot] = p2, p[++tot] = p3, p[++tot] = p4; &#125; prework(); for(int k = 1; k &lt;= tot; k++) // 一开始把 k 套到最里面了。。 for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); ans = 0x7f7f7f7f; for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) if(p[i].id == A &amp;&amp; p[j].id == B) ans = min(ans, w[i][j]); printf(\"%.1lf\\n\", ans); // 只保留1位！ &#125; return 0;&#125;/*13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"Floyd","slug":"Floyd","permalink":"http://tle666.github.io/tags/Floyd/"}]},{"title":"「USACO15DEC」最大流","slug":"[USACO15DEC] 最大流","date":"2019-02-23T02:52:20.000Z","updated":"2019-03-27T13:06:35.130Z","comments":true,"path":"2019/02/23/[USACO15DEC] 最大流/","link":"","permalink":"http://tle666.github.io/2019/02/23/[USACO15DEC] 最大流/","excerpt":"Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \\leq n \\leq 50000,\\ 1 \\leq k \\leq 100000$","text":"Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \\leq n \\leq 50000,\\ 1 \\leq k \\leq 100000$ 题目链接戳这里 Solution树链剖分模板题！没学过的戳这里 对于每次操作$u$，$v​$，我们只需要执行一次树链剖分里最基本的修改操作：路径修改即可。 最后你再用基本操作$query$求一次区间点权最大值就A了啊！ 详见代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, k, tot, wson[MAXN], dep[MAXN], fa[MAXN], dfn[MAXN], pre[MAXN], size[MAXN], top[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存树 int left, right, Max, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, Max += x;&#125; inline void upd() &#123; Max = max(ls-&gt;Max, rs-&gt;Max);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[wson[u]] &lt; size[v]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u] &amp;&amp; v != wson[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;Max = 0; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(1); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right); else change(r-&gt;ls, left, r-&gt;ls-&gt;right), change(r-&gt;rs, r-&gt;rs-&gt;left, right); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 区间求 max r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;Max; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline void Qchange(int u, int v) &#123; // 路径点权加一 int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right);&#125;int main() &#123; int u, v; scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(k--) &#123; scanf(\"%d%d\", &amp;u, &amp;v); Qchange(u, v); &#125; printf(\"%d\\n\", query(root, 1, n)); // 最后输出最大值 return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"},{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"}]},{"title":"数学公式","slug":"公式","date":"2019-02-19T03:19:30.000Z","updated":"2019-03-09T12:26:48.074Z","comments":true,"path":"2019/02/19/公式/","link":"","permalink":"http://tle666.github.io/2019/02/19/公式/","excerpt":"这里有一些重要的初高中数学公式，可供参考。","text":"这里有一些重要的初高中数学公式，可供参考。 恒等变形$a^3 + b^3 = (a + b)(a^2 - ab + b)$ $a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \\dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$ $2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \\geqslant 0$ $(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$ $(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$ $(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$ $(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$ $(a_1^2 + a_2^2 + a_3^2 + \\cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \\cdots + b_n^2) \\geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \\cdots + a_nb_n)^2$ —— $Cauchy$不等式 $(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$ 几何定理斯特瓦尔特定理 $BD \\cdot AC^2 + DC \\cdot AB^2 = BC \\cdot AD^2 + BD \\cdot DC \\cdot BC$ 推论：中线长公式$AD = \\frac{1}{2} \\sqrt{2(AB^2 + AC^2) - BC^2}$ 欧拉线 $\\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。 九点圆 在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。 西姆松线 过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。 史坦纳定理 $H$ 为$\\triangle ABC$ 垂心，$D$为$\\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\\triangle ABC$的西姆松线通过线段$DH$的中点。 三角函数定义$\\cot\\alpha = \\frac{1}{\\tan\\alpha} \\qquad \\sec\\alpha = \\frac{1}{\\cos\\alpha} \\qquad \\csc\\alpha = \\frac{1}{\\sin\\alpha}$ 诱导公式$\\sin ( \\pi + \\alpha) =- \\sin \\alpha \\qquad \\cos(\\pi + \\alpha) = -\\cos \\alpha \\qquad \\tan (\\pi + \\alpha) = \\tan \\alpha$ $\\sin (-\\alpha) = -\\sin\\alpha \\qquad \\cos (-\\alpha) = \\cos\\alpha \\qquad \\tan(-\\alpha) = -\\tan\\alpha$ $\\sin (\\pi - \\alpha) = \\sin \\alpha \\qquad \\cos (\\pi - \\alpha) = -\\cos\\alpha \\qquad \\tan(\\pi - \\alpha) = -\\tan\\alpha$ $\\sin(2\\pi - \\alpha) = -\\sin\\alpha \\qquad \\cos(2\\pi - \\alpha) = \\cos\\alpha \\qquad \\tan(2\\pi - \\alpha) = -\\tan\\alpha$ $\\sin (\\frac{\\pi}{2} + \\alpha) = \\cos\\alpha \\qquad \\sin(\\frac{\\pi}{2} - \\alpha) = \\cos\\alpha$ $\\cos(\\frac{\\pi}{2} + \\alpha) = -\\sin\\alpha \\qquad \\cos(\\frac{\\pi}{2} - \\alpha) = \\sin\\alpha$ $\\tan(\\frac{\\pi}{2} + \\alpha) = -\\cot\\alpha \\qquad \\tan(\\frac{\\pi}{2} - \\alpha) = \\cot\\alpha$ $\\tan(\\frac{\\pi}{4} + \\alpha) = \\frac{1 + \\tan\\alpha}{1 - \\tan\\alpha}$ 推论 $(\\sin\\frac{\\alpha}{2} \\pm \\cos\\frac{\\alpha}{2})^2 = 1 \\pm \\sin\\alpha$ 两角和（差）公式$\\sin(\\alpha \\pm \\beta) = \\sin\\alpha\\cos\\beta \\pm \\cos\\alpha\\sin\\beta$ $\\cos(\\alpha \\pm \\beta) = \\cos\\alpha\\cos\\beta \\mp \\sin\\alpha\\sin\\beta$ $\\tan(\\alpha \\pm \\beta) = \\frac{\\tan\\alpha \\pm \\tan\\beta}{1 \\mp \\tan\\alpha\\tan\\beta}$ 二倍角公式$\\sin 2\\alpha = 2\\sin\\alpha\\cos\\alpha$ $\\cos2\\alpha = 2\\cos^2\\alpha - 1 = 1 - 2\\sin^2\\alpha = \\frac{1-\\tan^2\\alpha}{1+\\tan^2\\alpha}$ $\\tan2\\alpha = \\frac{2\\tan\\alpha}{1-\\tan^2\\alpha}$ 三倍角公式$\\sin(3\\alpha) = 3\\sin\\alpha - 4\\sin^3\\alpha \\qquad \\cos(3\\alpha) = 4\\cos ^ 3\\alpha - 3\\cos\\alpha$ 降幂公式$\\sin^2\\alpha = \\frac{1 - \\cos2\\alpha}{2} \\qquad \\cos^2\\alpha = \\frac{1 + \\cos2\\alpha}{2} \\qquad \\tan^2\\alpha = \\frac{1 - \\cos2\\alpha}{1 + \\cos2\\alpha}$ 辅助角公式$a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}(\\frac{a\\sin x}{\\sqrt{a^2 + b^2}} + \\frac{b\\cos x}{\\sqrt{a^2 + b^2}})$ 或 $a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}\\sin(x + \\varphi)$，其中 $\\sin\\varphi = \\frac{b}{\\sqrt{a ^ 2 + b ^ 2}},\\ \\cos\\varphi = \\frac{a}{\\sqrt{a^2 + b^2}}$ 万能公式$\\sin\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}$ $\\cos\\alpha = \\frac{1 - \\tan^2\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}​$ $\\tan\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 - \\tan^2\\frac{\\alpha}{2}}$ 和差化积$\\sin\\alpha \\pm \\sin\\beta = 2\\sin\\frac{\\alpha \\pm \\beta}{2}\\cos\\frac{\\alpha \\mp \\beta}{2}$ $\\cos\\alpha + \\cos\\beta = 2\\cos\\frac{\\alpha + \\beta}{2}\\cos\\frac{\\alpha - \\beta}{2}$ $\\cos\\alpha - \\cos\\beta = -2\\sin\\frac{\\alpha + \\beta}{2}\\sin\\frac{\\alpha - \\beta}{2}$ $\\tan\\alpha \\pm \\tan\\beta = \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos\\alpha\\cos\\beta}$ 积化和差$\\sin\\alpha\\cos\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) + \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\sin\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) - \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\cos\\beta = \\frac{1}{2}(\\cos(\\alpha +\\beta) + \\cos(\\alpha - \\beta))$ $\\sin\\alpha\\sin\\beta = -\\frac{1}{2}(\\cos(\\alpha + \\beta) - \\cos(\\alpha - \\beta))$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"三角函数","slug":"三角函数","permalink":"http://tle666.github.io/tags/三角函数/"},{"name":"代数","slug":"代数","permalink":"http://tle666.github.io/tags/代数/"},{"name":"几何","slug":"几何","permalink":"http://tle666.github.io/tags/几何/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"}]},{"title":"树链剖分详解","slug":"树链剖分详解","date":"2019-02-02T15:13:25.000Z","updated":"2019-03-06T13:47:05.034Z","comments":true,"path":"2019/02/02/树链剖分详解/","link":"","permalink":"http://tle666.github.io/2019/02/02/树链剖分详解/","excerpt":"Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u​$到$v​$的权值都加$d​$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。","text":"Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u​$到$v​$的权值都加$d​$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。 前置技能：线段树（重要） &amp; 倍增求 $LCA​$（不必须） Definition &amp; Steps 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。 首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念： $size_i$：以$i​$为根的子树中结点个数 $dfn_i$：$i$结点的$dfs$序，即其新编号 $pre_i$：$dfn$的反函数，若$dfn_i\\ =\\ j$，则$pre_j\\ =\\ i$，即$dfn_{pre_i}\\ =\\ 1$。 $fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号） $dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\\ =\\ 1$ $w_i$：$i$结点的权值 重儿子：一个结点所有子结点中$size​$最大的子节点，用$wson[i]​$表示 轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点 重边：一个结点和它的重儿子的连边 轻边：一个节点和它的轻儿子的连边 重链：由多条重边首尾顺次连接而成的链（路径） 轻链：有多条轻边首尾顺次连接而成的链（路径） $top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上） 上一张百度百科的图： 如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可； 同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$ 递归伪代码如下： 123456789void dfs1(int u, int f) // u 当前结点，f 是 u 的父亲结点 size[u] = 1 for each v that connects to u : // u 的子结点 if(v != f) // v 不是 u 的父亲 fa[v] = u // 说明 v 是 u 的子结点 dep[v] = dep[u] + 1 // 深度维护 dfs(v, u) // 继续递归 size[u] += size[v] // 将子树的 size 加到这棵树的 size 上 if(size[wson[u]] &lt; size[v]) wson[u] = v // 更新重儿子 可以手动模拟一下 这样，我们就求出了每个结点的重儿子 $wson$ ； 特别地，每个叶子结点的重儿子都为 $0$ 每个标红点的结点都是一条重链的链首（$top$）， 而加粗的边则是重链。 比如，$1=&gt;4=&gt;9=&gt;13=&gt;14$ 就是一条重链，而 $2=&gt;6=&gt;11$ 也是另一条重链； 另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子， 例如 $top[3]\\ =\\ 3​$； 回顾一下，还有哪些信息没有维护呢？ $dfn,\\ pre,\\ top$ 其实，这三个只需要另一个递归函数就足够啦！ 12345678void dfs2(int u, int tp) // u 是当前结点，tp 是 u 所在重链的链首 top[u] = tp dfn[u] = ++tot // tot 是时间戳 pre[tot] = u // pre 是 dfn 的反函数 if(wson[u]) dfs2(wson[u], tp); // 只要 u 有重儿子，那就可以继续下去 for each v that connects to u : if(v != fa[u] &amp;&amp; v != wson[u]) // v 是 u 的轻儿子 dfs2(v, v); // 轻儿子是重链的链首 图中边上的数字就是 $dfs2$ 递归地顺序，不明白的可以参考一下。 检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？ $Answer:\\ 10,\\ 8$。 好了，树链剖分阶段到此结束。 将这棵树剖分成了许多链，现在就可以用线段树维护了~ 写上了一段带修改查询的线段树模板。。。 现在轮到处理问题的阶段了。 为了便于理解，我们就先实现两个最基础的操作吧： 路径点权求和、路径点权修改 大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。 举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。） 为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。 这个和倍增求 $LCA$ 有点像。 先找到 $dep$ 更深的结点，$11$（$dep[11]\\ &gt;\\ dep[9]$） 将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和 我们可以用事先维护好的 $dfn​$ 来帮助 由于 $top[11]\\ =\\ 2$，所以我们在求 $2=&gt;11$ 的和 我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！ 线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$ res += query(root, dfn[top[11]], dfn[11]) 这是，操作变成了求 $res\\ +\\ 9=&gt;11$ 的路径点权和。 所以我们将 $11$ 变为 $fa[top[11]]\\ =\\ 1$ 这是，我们发现 $1$ 和 $9$ 共链了。 所以像刚才一样， res += query(root, dfn[1], dfn[9]) 即可！ 将上面的步骤转化成代码： 1234567891011void Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; // 只要不共链 if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); // 每次都要让 top 深一些的往上跳 res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); // 注意大小关系！ res += query(root, left, right); return res;&#125; 很简单吧！ 修改操作类似， 12345678910vois Qchange(int u, int v, int d) &#123; // u 到 v 的路径上点权加 d int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];int dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存线段树 int left, right, s, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[wson[u]]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; // 线段树模板 r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = w[pre[left]]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; // 线段树模板 if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 线段树模板 r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return query(r-&gt;ls, left, r-&gt;ls-&gt;right) + query(r-&gt;rs, r-&gt;rs-&gt;left, right);&#125;inline int Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); res += query(root, left, right); return res;&#125;inline void Qchange(int u, int v, int d) &#123; int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125;int main() &#123; int op, u, v, d; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); // 读入点权 for(int i = 1; i &lt; n; i++) &#123; // 读图 scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; // 这步不能忘，否则 dfs1 没用！ dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(m--) &#123; // 操作 scanf(\"%d%d%d\", &amp;op, &amp;u, &amp;v); if(op == 1) printf(\"%d\\n\", Qsum(u, v)); else &#123; scanf(\"%d\", &amp;d); Qchange(u, v, d); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"},{"name":"线段树","slug":"线段树","permalink":"http://tle666.github.io/tags/线段树/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"}]},{"title":"「BZOJ5165」树上倍增","slug":"[BZOJ5165] 树上倍增","date":"2019-02-02T09:59:01.000Z","updated":"2019-03-27T13:04:18.299Z","comments":true,"path":"2019/02/02/[BZOJ5165] 树上倍增/","link":"","permalink":"http://tle666.github.io/2019/02/02/[BZOJ5165] 树上倍增/","excerpt":"Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\\leq 3 \\times 10^6$ ，操作次数 $m \\leq 10^3$，$k \\leq 10^3$","text":"Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\\leq 3 \\times 10^6$ ，操作次数 $m \\leq 10^3$，$k \\leq 10^3$ 题目链接： BZOJ P5165 Solution思路题目名称已经给了好嘛。。。 就是倍增啊。。 其实这题的难点不是在于思路想法，而是在于卡空间！ 操作1 $A \\ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1​$。 维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$ 具体的维护方法见下面的代码 1234567dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = 1st[i][j] = k 代表 编号为i的节点向上跳2 ^ j个点到编号为k的节点因此st[i][0]即为节点i的父亲dep[++n] = dep[x] + 1; // 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号for(int i = 20; i &gt;= 0; i--) // 2 ^ 21 &gt; 3e6，因此只需维护到20即可 st[n][i] = st[st[n][i - 1]][i - 1]; // 倍增数组标准维护语句 操作2 $Q \\ k\\ p1\\ p2\\ p3\\ …$ 查询$p1,\\ p2,\\ p3\\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。 这个我想没什么好讲的吧。 就是依次求$LCA$就行啦。如果不懂详见代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 3000003int n = 1, m, dep[MAXN], st[MAXN][21], P;char ch[2]; // 读入操作用，char可能会咕掉inline void insert(int x) &#123; // 新建节点操作，上文讲过 dep[++n] = dep[x] + 1, st[n][0] = x; for(register int i = 1; i &lt;= 20; i++) st[n][i] = st[st[n][i - 1]][i - 1];&#125;inline int LCA(int u, int v) &#123; // 基本的LCA操作，不解释 if(dep[u] &gt; dep[v]) swap(u, v); for(register int i = 20; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(register int i = 20; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return st[u][0];&#125;int main() &#123; int k, lca; dep[1] = 1; // 将root的深度设为1 scanf(\"%d\", &amp;m); while(m--) &#123; scanf(\"%s%d\", ch, &amp;k); if(ch[0] == 'A') insert(k); else &#123; scanf(\"%d\", &amp;lca); //依次求LCA for(register int i = 1; i &lt; k; i++) scanf(\"%d\", &amp;P), lca = LCA(lca, P); printf(\"%d\\n\", lca); &#125; &#125;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"LCA","slug":"LCA","permalink":"http://tle666.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://tle666.github.io/tags/倍增/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"}]},{"title":"快速读入详解","slug":"快速读入详解","date":"2019-01-27T03:41:50.000Z","updated":"2019-01-27T03:52:07.671Z","comments":true,"path":"2019/01/27/快速读入详解/","link":"","permalink":"http://tle666.github.io/2019/01/27/快速读入详解/","excerpt":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板","text":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 卡常！ 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 ——来自~~某度~~百科…… 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read()&#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\\overline{abcd} = 10 \\times (10 \\times (10 \\times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \\times |n|$，其中$sgn(x)$为$x$的符号。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"卡常","slug":"卡常","permalink":"http://tle666.github.io/tags/卡常/"}]},{"title":"浅谈二分","slug":"浅谈二分","date":"2019-01-27T03:39:50.000Z","updated":"2019-01-27T03:59:03.795Z","comments":true,"path":"2019/01/27/浅谈二分/","link":"","permalink":"http://tle666.github.io/2019/01/27/浅谈二分/","excerpt":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。","text":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \\in \\mathbb{Z}$，即整数$mid = \\lfloor \\dfrac{a + b}{2} \\rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 $L = 0, R = 4, mid = \\lfloor \\dfrac{0 + 4}{2} \\rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \\lfloor \\dfrac{0 + 2}{2} \\rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \\times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \\lfloor \\dfrac{L + R}{2} \\rfloor = 50$，设答案为$ans$。 只要$L \\leqslant R$，尝试$mid$，\\left\\{ \\begin{aligned} & 若mid > ans，则R = mid； \\\\ & 若mid < ans，则L = mid + 1； \\\\ & 若mid = ans，猜对了。 \\end{aligned} \\right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"}]},{"title":"「luogu1462」通往奥格瑞玛的道路","slug":"[luogu1462] 通往奥格瑞玛的道路","date":"2019-01-27T03:36:50.000Z","updated":"2019-03-27T13:05:23.523Z","comments":true,"path":"2019/01/27/[luogu1462] 通往奥格瑞玛的道路/","link":"","permalink":"http://tle666.github.io/2019/01/27/[luogu1462] 通往奥格瑞玛的道路/","excerpt":"Description$n$个点$m​$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b​$短，并且经过的点权之和最大。 输出这个最大值","text":"Description$n$个点$m​$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b​$短，并且经过的点权之和最大。 输出这个最大值 看完题面感觉语文要挂科。。。o(╥﹏╥)o Solution这题正解 $SPFA\\ +​$ 二分 二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts(\"AFK\"); else printf(\"%d\\n\", left); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://tle666.github.io/tags/SPFA/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"}]},{"title":"「CQOI2009」中位数","slug":"[CQOI2009] 中位数","date":"2019-01-27T03:33:40.000Z","updated":"2019-03-27T13:04:38.269Z","comments":true,"path":"2019/01/27/[CQOI2009] 中位数/","link":"","permalink":"http://tle666.github.io/2019/01/27/[CQOI2009] 中位数/","excerpt":"Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \\leq 100000,\\ 1 \\leq b \\leq n$。","text":"Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \\leq 100000,\\ 1 \\leq b \\leq n$。 题目传送门Solution标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf(\"%d\",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf(\"%d\\n\",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"}]},{"title":"并查集入门","slug":"并查集","date":"2018-10-04T03:21:10.000Z","updated":"2019-01-27T03:43:34.209Z","comments":true,"path":"2018/10/04/并查集/","link":"","permalink":"http://tle666.github.io/2018/10/04/并查集/","excerpt":"并查集是维护集合相关问题的利器！","text":"并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"并查集","slug":"并查集","permalink":"http://tle666.github.io/tags/并查集/"}]}]}