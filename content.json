{"meta":{"title":"P_Wang's Blog","subtitle":"自己选择的路，跪着也要走完。","description":"OIer!","author":"P_Wang","url":"http://tle666.github.io"},"pages":[{"title":"","date":"2019-02-02T10:18:16.311Z","updated":"2019-02-02T10:18:16.311Z","comments":true,"path":"baidu_verify_o1tQMBIJO5.html","permalink":"http://tle666.github.io/baidu_verify_o1tQMBIJO5.html","excerpt":"","text":"o1tQMBIJO5"},{"title":"关于","date":"2018-08-31T07:13:58.000Z","updated":"2019-01-27T05:28:08.406Z","comments":true,"path":"about/index.html","permalink":"http://tle666.github.io/about/index.html","excerpt":"","text":"本人乃无实力瑟瑟发抖萌新OIer 欢迎加QQ随时吊打我哦~ QQ：3271252272"},{"title":"文章分类","date":"2018-08-31T07:16:02.000Z","updated":"2018-08-31T07:20:06.448Z","comments":true,"path":"categories/index.html","permalink":"http://tle666.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-31T07:15:42.000Z","updated":"2018-08-31T07:20:43.294Z","comments":true,"path":"tags/index.html","permalink":"http://tle666.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-01-26T14:17:50.000Z","updated":"2019-01-27T03:50:28.329Z","comments":true,"path":"friends/index.html","permalink":"http://tle666.github.io/friends/index.html","excerpt":"","text":"$AcF$"},{"title":"搜索","date":"2018-08-31T09:49:52.000Z","updated":"2018-08-31T09:51:16.269Z","comments":true,"path":"search/index.html","permalink":"http://tle666.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"平面向量练习小结","slug":"平面向量练习小结","date":"2019-03-02T15:02:11.000Z","updated":"2019-03-03T01:14:02.267Z","comments":true,"path":"2019/03/02/平面向量练习小结/","link":"","permalink":"http://tle666.github.io/2019/03/02/平面向量练习小结/","excerpt":"最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。","text":"最近做了一些关于平面向量的习题，发现了一种近乎万能的套路。 这篇文章不适合向量零基础的同学看。 坐标表示法对于向量，我们能不能制定一种与坐标类似，与有序数对一一对应的方法呢？ 这就是向量的“万能方法”——坐标表示法。 对于向量$\\overrightarrow{AB}$，我们令$A$为坐标的原点，以两个夹角不为零的向量为坐标轴，不妨设$\\overrightarrow{p}$为$x$轴，$\\overrightarrow{q}$为$y$轴。我们可以将$\\overrightarrow{AB}$定义为$(x,\\ y)$，其中$x,y \\in \\mathbb{R}$。此时满足$\\overrightarrow{AB} = x \\overrightarrow{p} + y \\overrightarrow{q}$。 通常，为了方便起见，我们就将$\\overrightarrow{p}$和$\\overrightarrow{q}$设为$x$轴和$y$轴正半轴方向上的的单位向量。 这样，题目中复杂的条件就可以通过下面的公式化繁而简了。 一些有用的公式 在以下公式中，默认$\\overrightarrow{A} = (x_1,y_1),\\ \\overrightarrow{B} = (x_2,y_2)$ $\\overrightarrow{A} + \\overrightarrow{B} = (x_1 + y_1, x_2 + y_2)$ $\\overrightarrow{A} - \\overrightarrow{B} = (x_1 - y_1, x_2 - y_2)$ $\\overrightarrow{A} \\cdot \\overrightarrow{B} = x_1x_2+y_1y_2$ 由此我们可以推出 $\\cos&lt;\\overrightarrow{A}, \\overrightarrow{B}&gt; = \\frac{x_1x_2 + y_1y_2}{\\sqrt{x_1^2 + y_1^2} \\cdot \\sqrt{x_2^2 + y_2^2}}$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"},{"name":"平面向量","slug":"平面向量","permalink":"http://tle666.github.io/tags/平面向量/"}]},{"title":"[NOIP2011提高] Car的旅行路线","slug":"[NOIP2011提高] Car的旅行路线","date":"2019-03-02T14:29:03.000Z","updated":"2019-03-02T14:49:47.098Z","comments":true,"path":"2019/03/02/[NOIP2011提高] Car的旅行路线/","link":"","permalink":"http://tle666.github.io/2019/03/02/[NOIP2011提高] Car的旅行路线/","excerpt":"Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\\leq10$，矩形个数$\\leq100$。","text":"Description给你$n$个矩形，每个矩形自己的四个顶点两两相同，并且经过的费用为长度乘$t$；而所有矩形之间路程的费用为长度乘$T$（不包括同一矩形内两点的边）。 求$A$点到$B$点的最小费用。 对于$100$%的数据，数据组数$\\leq10$，矩形个数$\\leq100$。 题目链接戳这里 Solution打死我也不告诉你我Floyd模板打错了 通过$floyd$处理出任意两点（注意不是矩形）之间的最小费用即可。 但这道题细节还是不少的—— 只给你矩形的三个顶点 先通过勾股定理逆定理来求出哪个是直角，然后第四个点的坐标就出来了。 矩形可以是歪的，即它的边不一定平行于坐标轴。 多组数据注意初始化。 飞机和汽车费用不一样，需要分别计算。 最后只输出1位小数 $Hint$：两点间距离公式 $dis\\ =\\ \\sqrt{(x_1 - x_2) ^ 2 + (y_1 - y_2) ^ 2}$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 110int _, S, t, A, B, tot;double w[MAXN][MAXN], ans; // w 是两点间的最小费用inline double sq(int x) &#123; return (double)x * x;&#125;struct point &#123; int id, t, x, y; // id 城市编号，t 列车费用 inline void INIT(int _id, int _t, int _x, int _y) &#123; id = _id, t = _t, x = _x, y = _y; &#125; // 赋值函数（更简单的忘了怎么写了 QwQ inline double dis(point &amp;a) &#123; return sqrt(sq(x - a.x) + sq(y - a.y)); &#125; // 两点间距离 inline void rct(point &amp;a, point &amp;b, point &amp;c) &#123; id = a.id, t = a.t; int P = sq(a.x - b.x) + sq(a.y - b.y), Q = sq(b.x - c.x) + sq(b.y - c.y), R = sq(c.x - a.x) + sq(c.y - a.y); if(P + Q == R) x = a.x + c.x - b.x, y = a.y + c.y - b.y; else if(P + R == Q) x = b.x + c.x - a.x, y = b.y + c.y - a.y; else x = a.x + b.x - c.x, y = a.y + b.y - c.y; &#125; // 处理第四个点的坐标&#125; p[MAXN];inline void prework() &#123; static point P, Q; static double c, d; memset(w, 0x3f, sizeof(w)); for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) &#123; if(i == j) continue ; P = p[i], Q = p[j], d = P.dis(Q), c = 0.0; if(P.id == Q.id) c = d * P.t; else c = d * (double)t; w[i][j] = w[j][i] = c; &#125;&#125; // 处理距离，注意初始化int main() &#123; int x1, y1, x2, y2, x3, y3, _t; point p1, p2, p3, p4; scanf(\"%d\", &amp;_); while(_--) &#123; // 多组数据 scanf(\"%d%d%d%d\", &amp;S, &amp;t, &amp;A, &amp;B); tot = 0; for(int i = 1; i &lt;= S; i++) &#123; scanf(\"%d%d%d%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;_t); p1.INIT(i, _t, x1, y1), p2.INIT(i, _t, x2, y2), p3.INIT(i, _t, x3, y3), p4.rct(p1, p2, p3); p[++tot] = p1, p[++tot] = p2, p[++tot] = p3, p[++tot] = p4; &#125; prework(); for(int k = 1; k &lt;= tot; k++) // 一开始把 k 套到最里面了。。 for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) w[i][j] = min(w[i][j], w[i][k] + w[k][j]); ans = 0x7f7f7f7f; for(int i = 1; i &lt;= tot; i++) for(int j = 1; j &lt;= tot; j++) if(p[i].id == A &amp;&amp; p[j].id == B) ans = min(ans, w[i][j]); printf(\"%.1lf\\n\", ans); // 只保留1位！ &#125; return 0;&#125;/*13 10 1 31 1 1 3 3 1 302 5 7 4 5 2 18 6 8 8 11 6 3*/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"Floyd","slug":"Floyd","permalink":"http://tle666.github.io/tags/Floyd/"}]},{"title":"[USACO15DEC] 最大流","slug":"[USACO15DEC] 最大流","date":"2019-02-23T02:52:20.000Z","updated":"2019-02-23T02:53:54.055Z","comments":true,"path":"2019/02/23/[USACO15DEC] 最大流/","link":"","permalink":"http://tle666.github.io/2019/02/23/[USACO15DEC] 最大流/","excerpt":"Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \\leq n \\leq 50000,\\ 1 \\leq k \\leq 100000$","text":"Description给你一颗$n$个结点的树。 有$k$个操作，每个操作有两个数$u$和$v$，使$u$到$v$路径上的所有点权都加一。 最后输出最大的点权值。 对于$100$%的的数据，满足$2 \\leq n \\leq 50000,\\ 1 \\leq k \\leq 100000$ 题目链接戳这里 Solution树链剖分模板题！没学过的戳这里 对于每次操作$u$，$v​$，我们只需要执行一次树链剖分里最基本的修改操作：路径修改即可。 最后你再用基本操作$query$求一次区间点权最大值就A了啊！ 详见代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, k, tot, wson[MAXN], dep[MAXN], fa[MAXN], dfn[MAXN], pre[MAXN], size[MAXN], top[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存树 int left, right, Max, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, Max += x;&#125; inline void upd() &#123; Max = max(ls-&gt;Max, rs-&gt;Max);&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[wson[u]] &lt; size[v]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != fa[u] &amp;&amp; v != wson[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;Max = 0; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right) &#123; if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(1); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right); else change(r-&gt;ls, left, r-&gt;ls-&gt;right), change(r-&gt;rs, r-&gt;rs-&gt;left, right); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 区间求 max r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;Max; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return max(query(r-&gt;ls, left, r-&gt;ls-&gt;right), query(r-&gt;rs, r-&gt;rs-&gt;left, right));&#125;inline void Qchange(int u, int v) &#123; // 路径点权加一 int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right);&#125;int main() &#123; int u, v; scanf(\"%d%d\", &amp;n, &amp;k); for(int i = 1; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(k--) &#123; scanf(\"%d%d\", &amp;u, &amp;v); Qchange(u, v); &#125; printf(\"%d\\n\", query(root, 1, n)); // 最后输出最大值 return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"}]},{"title":"数学公式","slug":"公式","date":"2019-02-19T03:19:30.000Z","updated":"2019-02-19T08:03:58.048Z","comments":true,"path":"2019/02/19/公式/","link":"","permalink":"http://tle666.github.io/2019/02/19/公式/","excerpt":"这里有一些重要的初高中数学公式，可供参考。","text":"这里有一些重要的初高中数学公式，可供参考。 恒等变形$a^3 + b^3 = (a + b)(a^2 - ab + b)$ $a^3 + b^3 + c^3 - 3abc = (a + b + c)(a^2 + a^2 + c^2 - a - b - c) = \\dfrac{1}{2}(a + b + c)((a - b)^2 + (b - c)^2 + (c - a)^2)$ $2(a^2 + b^2 + c^2 - ab - bc - ca) = (a - b)^2 + (b - c)^2 + (c - a)^2 \\geqslant 0$ $(a + b)(b + c)(c + a) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 2abc$ $(a - b)(b - c)(c - a) = ab^2 + bc^2 + ca^2 - a^2b - b^2c - c^2a$ $(a + b + c)(ab + bc + ca) = ab^2 + bc^2 + ca^2 + a^2b + b^2c + c^2a + 3abc$ $(a^2 + b^2)(c^2 + d^2) = (ad - bc)^2 + (ac - bd)^2$ $(a_1^2 + a_2^2 + a_3^2 + \\cdots + a_n^2)(b_1^2 + b_2^2 + b_3^2 + \\cdots + b_n^2) \\geqslant (a_1b_1 + a_2b_2 + a_3b_3 + \\cdots + a_nb_n)^2$ —— $Cauchy$不等式 $(a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3a^2b + 3ab^2 + 3b^2c + 3bc^2 +3c^2a + 3ca^2 + 6abc$ 几何定理斯特瓦尔特定理 $BD \\cdot AC^2 + DC \\cdot AB^2 = BC \\cdot AD^2 + BD \\cdot DC \\cdot BC$ 推论：中线长公式$AD = \\frac{1}{2} \\sqrt{2(AB^2 + AC^2) - BC^2}$ 欧拉线 $\\triangle ABC$ 的外心 $O$ 、重心 $G$、垂心 $H$ 共线。 九点圆 在任意的三角形中，三边的中点、三条高的垂足、三条高的交点(垂心)与三角形顶点连线的中点，这九个点共圆。 西姆松线 过三角形外接圆上异于三角形顶点的任意一点作三边或其延长线上的垂线，则三垂足共线。 史坦纳定理 $H$ 为$\\triangle ABC$ 垂心，$D$为$\\triangle ABC$ 外异于三角形顶点的任意一点，则点$D$关于$\\triangle ABC$的西姆松线通过线段$DH$的中点。 三角函数定义$\\cot\\alpha = \\frac{1}{\\tan\\alpha} \\qquad \\sec\\alpha = \\frac{1}{\\cos\\alpha} \\qquad \\csc\\alpha = \\frac{1}{\\sin\\alpha}$ 诱导公式$\\sin ( \\pi + \\alpha) =- \\sin \\alpha \\qquad \\cos(\\pi + \\alpha) = -\\cos \\alpha \\qquad \\tan (\\pi + \\alpha) = \\tan \\alpha$ $\\sin (-\\alpha) = -\\sin\\alpha \\qquad \\cos (-\\alpha) = \\cos\\alpha \\qquad \\tan(-\\alpha) = -\\tan\\alpha$ $\\sin (\\pi - \\alpha) = \\sin \\alpha \\qquad \\cos (\\pi - \\alpha) = -\\cos\\alpha \\qquad \\tan(\\pi - \\alpha) = -\\tan\\alpha$ $\\sin(2\\pi - \\alpha) = -\\sin\\alpha \\qquad \\cos(2\\pi - \\alpha) = \\cos\\alpha \\qquad \\tan(2\\pi - \\alpha) = -\\tan\\alpha$ $\\sin (\\frac{\\pi}{2} + \\alpha) = \\cos\\alpha \\qquad \\sin(\\frac{\\pi}{2} - \\alpha) = \\cos\\alpha$ $\\cos(\\frac{\\pi}{2} + \\alpha) = -\\sin\\alpha \\qquad \\cos(\\frac{\\pi}{2} - \\alpha) = \\sin\\alpha$ $\\tan(\\frac{\\pi}{2} + \\alpha) = -\\cot\\alpha \\qquad \\tan(\\frac{\\pi}{2} - \\alpha) = \\cot\\alpha$ 两角和（差）公式$\\sin(\\alpha \\pm \\beta) = \\sin\\alpha\\cos\\beta \\pm \\cos\\alpha\\sin\\beta$ $\\cos(\\alpha \\pm \\beta) = \\cos\\alpha\\cos\\beta \\mp \\sin\\alpha\\sin\\beta$ $\\tan(\\alpha \\pm \\beta) = \\frac{\\tan\\alpha \\pm \\tan\\beta}{1 \\mp \\tan\\alpha\\tan\\beta}$ 二倍角公式$\\sin 2\\alpha = 2\\sin\\alpha\\cos\\alpha$ $\\cos2\\alpha = 2\\cos^2\\alpha - 1 = 1 - 2\\sin^2\\alpha = \\frac{1-\\tan^2\\alpha}{1+\\tan^2\\alpha}$ $\\tan2\\alpha = \\frac{2\\tan\\alpha}{1-\\tan^2\\alpha}$ 三倍角公式$\\sin(3\\alpha) = 3\\sin\\alpha - 4\\sin^3\\alpha \\qquad \\cos(3\\alpha) = 4\\cos ^ 3\\alpha - 3\\cos\\alpha$ 降幂公式$\\sin^2\\alpha = \\frac{1 - \\cos2\\alpha}{2} \\qquad \\cos^2\\alpha = \\frac{1 + \\cos2\\alpha}{2} \\qquad \\tan^2\\alpha = \\frac{1 - \\cos2\\alpha}{1 + \\cos2\\alpha}$ 辅助角公式$a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}(\\frac{a\\sin x}{\\sqrt{a^2 + b^2}} + \\frac{b\\cos x}{\\sqrt{a^2 + b^2}})$ 或 $a\\sin x + b\\cos x = \\sqrt{a^2 + b^2}\\sin(x + \\varphi)$，其中 $\\sin\\varphi = \\frac{b}{\\sqrt{a ^ 2 + b ^ 2}},\\ \\cos\\varphi = \\frac{a}{\\sqrt{a^2 + b^2}}$ 万能公式$\\sin\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}$ $\\cos\\alpha = \\frac{1 - \\tan^2\\frac{\\alpha}{2}}{1 + \\tan^2\\frac{\\alpha}{2}}$ $\\tan\\alpha = \\frac{2\\tan\\frac{\\alpha}{2}}{1 - \\tan^2\\frac{\\alpha}{2}}$ 和差化积$\\sin\\alpha \\pm \\sin\\beta = 2\\sin\\frac{\\alpha \\pm \\beta}{2}\\cos\\frac{\\alpha \\mp \\beta}{2}$ $\\cos\\alpha + \\cos\\beta = 2\\cos\\frac{\\alpha + \\beta}{2}\\cos\\frac{\\alpha - \\beta}{2}$ $\\cos\\alpha - \\cos\\beta = -2\\sin\\frac{\\alpha + \\beta}{2}\\sin\\frac{\\alpha - \\beta}{2}$ $\\tan\\alpha \\pm \\tan\\beta = \\frac{\\sin(\\alpha \\pm \\beta)}{\\cos\\alpha\\cos\\beta}$ 积化和差$\\sin\\alpha\\cos\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) + \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\sin\\beta = \\frac{1}{2}(\\sin(\\alpha + \\beta) - \\sin(\\alpha - \\beta))$ $\\cos\\alpha\\cos\\beta = \\frac{1}{2}(\\cos(\\alpha +\\beta) + \\cos(\\alpha - \\beta))$ $\\sin\\alpha\\sin\\beta = -\\frac{1}{2}(\\cos(\\alpha + \\beta) - \\cos(\\alpha - \\beta))$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://tle666.github.io/tags/数学/"},{"name":"公式","slug":"公式","permalink":"http://tle666.github.io/tags/公式/"},{"name":"三角函数","slug":"三角函数","permalink":"http://tle666.github.io/tags/三角函数/"},{"name":"代数","slug":"代数","permalink":"http://tle666.github.io/tags/代数/"},{"name":"几何","slug":"几何","permalink":"http://tle666.github.io/tags/几何/"}]},{"title":"树链剖分详解","slug":"树链剖分详解","date":"2019-02-02T15:13:25.000Z","updated":"2019-02-21T08:07:08.318Z","comments":true,"path":"2019/02/02/树链剖分详解/","link":"","permalink":"http://tle666.github.io/2019/02/02/树链剖分详解/","excerpt":"Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u​$到$v​$的权值都加$d​$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。","text":"Introduction当我们想要同时完成 求树上$u$到$v$的权值和 将树上$u​$到$v​$的权值都加$d​$ 这两种操作时，会怎么做呢？ 相信我们对于这两种操作分别都会解决，但是如果一旦放到同一道题里，我们就会束手无策了。 树链剖分便由此而来了。 前置技能：线段树（重要） &amp; 倍增求 $LCA​$（不必须） Definition &amp; Steps 树剖是通过将一棵有根树分成多个链，然后利用各种数据结构（如线段树等）来维护这棵链，从而间接地维护这棵树。 首先，为了方便我们对树剖的理解，我们需要知道一些很基础很重要的概念： $size_i$：以$i​$为根的子树中结点个数 $dfn_i$：$i$结点的$dfs$序，即其新编号 $pre_i$：$dfn$的反函数，若$dfn_i\\ =\\ j$，则$pre_j\\ =\\ i$，即$dfn_{pre_i}\\ =\\ 1$。 $fa_i$：$i$结点的父亲结点（除$dfn$和$pre$外，一切结点编号非特殊说明均为默认编号） $dep_i$：$i$的深度，默认根的深度为$1$，即$dep_{root}\\ =\\ 1$ $w_i$：$i$结点的权值 重儿子：一个结点所有子结点中$size​$最大的子节点，用$wson[i]​$表示 轻儿子：一个结点所有子结点中除了重儿子的其它所有子结点 重边：一个结点和它的重儿子的连边 轻边：一个节点和它的轻儿子的连边 重链：由多条重边首尾顺次连接而成的链（路径） 轻链：有多条轻边首尾顺次连接而成的链（路径） $top_i$：$i$所在的重链的链首（可以证明每个结点都在一条重链上） 上一张百度百科的图： 如果我们想知道$1$的重儿子是谁，那么我们只需递归地求一下它每棵子树的$size$即可； 同时，我们还可以顺便维护出所有结点的 $fa$ 和 $dep$ 递归伪代码如下： 123456789void dfs1(int u, int f) // u 当前结点，f 是 u 的父亲结点 size[u] = 1 for each v that connects to u : // u 的子结点 if(v != f) // v 不是 u 的父亲 fa[v] = u // 说明 v 是 u 的子结点 dep[v] = dep[u] + 1 // 深度维护 dfs(v, u) // 继续递归 size[u] += size[v] // 将子树的 size 加到这棵树的 size 上 if(size[wson[u]] &lt; size[v]) wson[u] = v // 更新重儿子 可以手动模拟一下 这样，我们就求出了每个结点的重儿子 $wson$ ； 特别地，每个叶子结点的重儿子都为 $0$ 每个标红点的结点都是一条重链的链首（$top$）， 而加粗的边则是重链。 比如，$1=&gt;4=&gt;9=&gt;13=&gt;14$ 就是一条重链，而 $2=&gt;6=&gt;11$ 也是另一条重链； 另外我们会注意到，除了根节点以外的所有重链链首都是轻儿子， 例如 $top[3]\\ =\\ 3​$； 回顾一下，还有哪些信息没有维护呢？ $dfn,\\ pre,\\ top$ 其实，这三个只需要另一个递归函数就足够啦！ 12345678void dfs2(int u, int tp) // u 是当前结点，tp 是 u 所在重链的链首 top[u] = tp dfn[u] = ++tot // tot 是时间戳 pre[tot] = u // pre 是 dfn 的反函数 if(wson[u]) dfs2(wson[u], tp); // 只要 u 有重儿子，那就可以继续下去 for each v that connects to u : if(v != fa[u] &amp;&amp; v != wson[u]) // v 是 u 的轻儿子 dfs2(v, v); // 轻儿子是重链的链首 图中边上的数字就是 $dfs2$ 递归地顺序，不明白的可以参考一下。 检测一下你有没有明白：$2$ 的 $dfn$ 是几？$7$ 的 $pre$ 是几？ $Answer:\\ 10,\\ 8$。 好了，树链剖分阶段到此结束。 将这棵树剖分成了许多链，现在就可以用线段树维护了~ 写上了一段带修改查询的线段树模板。。。 现在轮到处理问题的阶段了。 为了便于理解，我们就先实现两个最基础的操作吧： 路径点权求和、路径点权修改 大体思路很简单，就是把这条路径分成若干条原来的重链，然后依次实现。 举个栗子：求 $9$ 到 $11$ 路径上的点权之和（还是上面那张图。。） 为了简单起见，我们暂定每个点的点权是它的编号（不是 $dfn$）。 这个和倍增求 $LCA$ 有点像。 先找到 $dep$ 更深的结点，$11$（$dep[11]\\ &gt;\\ dep[9]$） 将答案 $res$ 加上 $11$ 到 $top[11]$ 的点权和 我们可以用事先维护好的 $dfn​$ 来帮助 由于 $top[11]\\ =\\ 2$，所以我们在求 $2=&gt;11$ 的和 我们发现因为这是一条重链，所以这条路径上的每个点的 $dfn$ 都是连续的！ 线段树有用了，注意 $dfn[top[11]] &lt; dfn[11]$ res += query(root, dfn[top[11]], dfn[11]) 这是，操作变成了求 $res\\ +\\ 9=&gt;11$ 的路径点权和。 所以我们将 $11$ 变为 $fa[top[11]]\\ =\\ 1$ 这是，我们发现 $1$ 和 $9$ 共链了。 所以像刚才一样， res += query(root, dfn[1], dfn[9]) 即可！ 将上面的步骤转化成代码： 1234567891011void Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; // 只要不共链 if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); // 每次都要让 top 深一些的往上跳 res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); // 注意大小关系！ res += query(root, left, right); return res;&#125; 很简单吧！ 修改操作类似， 12345678910vois Qchange(int u, int v, int d) &#123; // u 到 v 的路径上点权加 d int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125; Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 100100int n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN];int dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];struct edge &#123; // 存图 int v; edge *next;&#125; epool[MAXN &lt;&lt; 1], *h[MAXN], *ecnt = epool;struct node &#123; // 存线段树 int left, right, s, tag; node *ls, *rs; inline void seta(int x) &#123; tag += x, s += (right - left + 1) * x;&#125; inline void upd() &#123; s = ls-&gt;s + rs-&gt;s;&#125; inline void push() &#123; if(tag) &#123; if(ls) ls-&gt;seta(tag); if(rs) rs-&gt;seta(tag); tag = 0; &#125; &#125;&#125; pool[MAXN &lt;&lt; 3], *root, *cnt = pool;inline void addedge(int u, int v) &#123; // 加边 edge *p = ++ecnt, *q = ++ecnt; p-&gt;v = v, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;next = h[v], h[v] = q;&#125;inline void dfs1(int u, int f) &#123; int v; size[u] = 1; for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != f) &#123; fa[v] = u, dep[v] = dep[u] + 1; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[wson[u]]) wson[u] = v; &#125;&#125;inline void dfs2(int u, int tp) &#123; int v; top[u] = tp; dfn[u] = ++tot, pre[tot] = u; if(wson[u]) dfs2(wson[u], tp); for(edge *p = h[u]; p; p = p-&gt;next) if((v = p-&gt;v) != wson[u] &amp;&amp; v != fa[u]) dfs2(v, v);&#125;inline void build(node *r, int left, int right) &#123; // 线段树模板 r-&gt;left = left, r-&gt;right = right; if(left == right) &#123; r-&gt;s = w[pre[left]]; return ; &#125; int mid = (left + right) &gt;&gt; 1; node *ls = ++cnt, *rs = ++cnt; r-&gt;ls = ls, r-&gt;rs = rs; build(ls, left, mid), build(rs, mid + 1, right); r-&gt;upd();&#125;inline void change(node *r, int left, int right, int d) &#123; // 线段树模板 if(r-&gt;left == left &amp;&amp; r-&gt;right == right) &#123; r-&gt;seta(d); return ; &#125; r-&gt;push(); if(r-&gt;ls-&gt;right &gt;= right) change(r-&gt;ls, left, right, d); else if(r-&gt;rs-&gt;left &lt;= left) change(r-&gt;rs, left, right, d); else change(r-&gt;ls, left, r-&gt;ls-&gt;right, d), change(r-&gt;rs, r-&gt;rs-&gt;left, right, d); r-&gt;upd();&#125;inline int query(node *r, int left, int right) &#123; // 线段树模板 r-&gt;push(); if(r-&gt;left == left &amp;&amp; r-&gt;right == right) return r-&gt;s; if(r-&gt;ls-&gt;right &gt;= right) return query(r-&gt;ls, left, right); else if(r-&gt;rs-&gt;left &lt;= left) return query(r-&gt;rs, left, right); else return query(r-&gt;ls, left, r-&gt;ls-&gt;right) + query(r-&gt;rs, r-&gt;rs-&gt;left, right);&#125;inline int Qsum(int u, int v) &#123; int left, right, res = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); res += query(root, dfn[top[v]], dfn[v]); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); res += query(root, left, right); return res;&#125;inline void Qchange(int u, int v, int d) &#123; int left, right; while(top[u] != top[v]) &#123; if(dep[top[u]] &gt; dep[top[v]]) swap(u, v); change(root, dfn[top[v]], dfn[v], d); v = fa[top[v]]; &#125; left = dfn[u], right = dfn[v]; if(left &gt; right) swap(left, right); change(root, left, right, d);&#125;int main() &#123; int op, u, v, d; scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;w[i]); // 读入点权 for(int i = 1; i &lt; n; i++) &#123; // 读图 scanf(\"%d%d\", &amp;u, &amp;v); addedge(u, v); &#125; dep[1] = 1; // 这步不能忘，否则 dfs1 没用！ dfs1(1, 0), dfs2(1, 1); build(root = cnt, 1, n); while(m--) &#123; // 操作 scanf(\"%d%d%d\", &amp;op, &amp;u, &amp;v); if(op == 1) printf(\"%d\\n\", Qsum(u, v)); else &#123; scanf(\"%d\", &amp;d); Qchange(u, v, d); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://tle666.github.io/tags/树链剖分/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"}]},{"title":"[BZOJ5165] 树上倍增","slug":"[BZOJ5165] 树上倍增","date":"2019-02-02T09:59:01.000Z","updated":"2019-02-02T12:30:16.846Z","comments":true,"path":"2019/02/02/[BZOJ5165] 树上倍增/","link":"","permalink":"http://tle666.github.io/2019/02/02/[BZOJ5165] 树上倍增/","excerpt":"Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\\leq 3 \\times 10^6$ ，操作次数 $m \\leq 10^3$，$k \\leq 10^3$","text":"Description维护一棵支持插入节点与求$k$个节点的$LCA$的树。 总节点数 $n\\leq 3 \\times 10^6$ ，操作次数 $m \\leq 10^3$，$k \\leq 10^3$ 题目链接： BZOJ P5165 Solution思路题目名称已经给了好嘛。。。 就是倍增啊。。 其实这题的难点不是在于思路想法，而是在于卡空间！ 操作1 $A \\ x$ 新建一个节点，将它作为$x$节点的儿子，编号为当前节点总数$+1​$。 维护一下倍增$LCA$所需的信息：深度信息$dep$、倍增数组$st$ 具体的维护方法见下面的代码 1234567dep[i] = j 代表 编号为i的节点深度为j，我们默认dep[root] = 1st[i][j] = k 代表 编号为i的节点向上跳2 ^ j个点到编号为k的节点因此st[i][0]即为节点i的父亲dep[++n] = dep[x] + 1; // 即 n++, dep[n] = dep[x] + 1。 n是当前节点编号for(int i = 20; i &gt;= 0; i--) // 2 ^ 21 &gt; 3e6，因此只需维护到20即可 st[n][i] = st[st[n][i - 1]][i - 1]; // 倍增数组标准维护语句 操作2 $Q \\ k\\ p1\\ p2\\ p3\\ …$ 查询$p1,\\ p2,\\ p3\\ …$这些节点的$LCA$。其中$k$表示查询节点的个数。 这个我想没什么好讲的吧。 就是依次求$LCA$就行啦。如果不懂详见代码 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define MAXN 3000003int n = 1, m, dep[MAXN], st[MAXN][21], P;char ch[2]; // 读入操作用，char可能会咕掉inline void insert(int x) &#123; // 新建节点操作，上文讲过 dep[++n] = dep[x] + 1, st[n][0] = x; for(register int i = 1; i &lt;= 20; i++) st[n][i] = st[st[n][i - 1]][i - 1];&#125;inline int LCA(int u, int v) &#123; // 基本的LCA操作，不解释 if(dep[u] &gt; dep[v]) swap(u, v); for(register int i = 20; i &gt;= 0; i--) if(dep[v] - dep[u] &gt;= (1 &lt;&lt; i)) v = st[v][i]; if(u == v) return u; for(register int i = 20; i &gt;= 0; i--) if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i]; return st[u][0];&#125;int main() &#123; int k, lca; dep[1] = 1; // 将root的深度设为1 scanf(\"%d\", &amp;m); while(m--) &#123; scanf(\"%s%d\", ch, &amp;k); if(ch[0] == 'A') insert(k); else &#123; scanf(\"%d\", &amp;lca); //依次求LCA for(register int i = 1; i &lt; k; i++) scanf(\"%d\", &amp;P), lca = LCA(lca, P); printf(\"%d\\n\", lca); &#125; &#125;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"LCA","slug":"LCA","permalink":"http://tle666.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://tle666.github.io/tags/倍增/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"}]},{"title":"快速读入详解","slug":"快速读入详解","date":"2019-01-27T03:41:50.000Z","updated":"2019-01-27T03:52:07.671Z","comments":true,"path":"2019/01/27/快速读入详解/","link":"","permalink":"http://tle666.github.io/2019/01/27/快速读入详解/","excerpt":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板","text":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 卡常！ 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 ——来自~~某度~~百科…… 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read()&#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\\overline{abcd} = 10 \\times (10 \\times (10 \\times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \\times |n|$，其中$sgn(x)$为$x$的符号。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"卡常","slug":"卡常","permalink":"http://tle666.github.io/tags/卡常/"}]},{"title":"浅谈二分","slug":"浅谈二分","date":"2019-01-27T03:39:50.000Z","updated":"2019-01-27T03:59:03.795Z","comments":true,"path":"2019/01/27/浅谈二分/","link":"","permalink":"http://tle666.github.io/2019/01/27/浅谈二分/","excerpt":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。","text":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \\in \\mathbb{Z}$，即整数$mid = \\lfloor \\dfrac{a + b}{2} \\rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 $L = 0, R = 4, mid = \\lfloor \\dfrac{0 + 4}{2} \\rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \\lfloor \\dfrac{0 + 2}{2} \\rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \\times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \\lfloor \\dfrac{L + R}{2} \\rfloor = 50$，设答案为$ans$。 只要$L \\leqslant R$，尝试$mid$，\\left\\{ \\begin{aligned} & 若mid > ans，则R = mid； \\\\ & 若mid < ans，则L = mid + 1； \\\\ & 若mid = ans，猜对了。 \\end{aligned} \\right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"}]},{"title":"[luogu1462] 通往奥格瑞玛的道路","slug":"[luogu1462] 通往奥格瑞玛的道路","date":"2019-01-27T03:36:50.000Z","updated":"2019-02-27T13:11:03.113Z","comments":true,"path":"2019/01/27/[luogu1462] 通往奥格瑞玛的道路/","link":"","permalink":"http://tle666.github.io/2019/01/27/[luogu1462] 通往奥格瑞玛的道路/","excerpt":"Description$n$个点$m​$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b​$短，并且经过的点权之和最大。 输出这个最大值","text":"Description$n$个点$m​$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b​$短，并且经过的点权之和最大。 输出这个最大值 看完题面感觉语文要挂科。。。o(╥﹏╥)o Solution这题正解 $SPFA\\ +​$ 二分 二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts(\"AFK\"); else printf(\"%d\\n\", left); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"http://tle666.github.io/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://tle666.github.io/tags/SPFA/"},{"name":"二分","slug":"二分","permalink":"http://tle666.github.io/tags/二分/"}]},{"title":"[CQOI2009] 中位数","slug":"[CQOI2009] 中位数","date":"2019-01-27T03:33:40.000Z","updated":"2019-02-27T13:11:16.364Z","comments":true,"path":"2019/01/27/[CQOI2009] 中位数/","link":"","permalink":"http://tle666.github.io/2019/01/27/[CQOI2009] 中位数/","excerpt":"Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \\leq 100000,\\ 1 \\leq b \\leq n$。","text":"Description给出$1-n$的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。 对于100%的数据，满足$n \\leq 100000,\\ 1 \\leq b \\leq n$。 题目传送门Solution标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。这样下标的值就不会为负啦。这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf(\"%d\",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf(\"%d\\n\",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.github.io/tags/题解/"}]},{"title":"并查集入门","slug":"并查集","date":"2018-10-04T03:21:10.000Z","updated":"2019-01-27T03:43:34.209Z","comments":true,"path":"2018/10/04/并查集/","link":"","permalink":"http://tle666.github.io/2018/10/04/并查集/","excerpt":"并查集是维护集合相关问题的利器！","text":"并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.github.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.github.io/tags/算法讲解/"},{"name":"并查集","slug":"并查集","permalink":"http://tle666.github.io/tags/并查集/"}]}]}