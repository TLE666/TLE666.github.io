{"meta":{"title":"P_Wang's Blog","subtitle":"自己选择的路，跪着也要走完。","description":"OIer!","author":"P_Wang","url":"http://tle666.gitub.io"},"pages":[{"title":"关于","date":"2018-08-31T07:13:58.000Z","updated":"2019-01-27T05:28:08.406Z","comments":true,"path":"about/index.html","permalink":"http://tle666.gitub.io/about/index.html","excerpt":"","text":"本人乃无实力瑟瑟发抖萌新OIer 欢迎加QQ随时吊打我哦~ QQ：3271252272"},{"title":"友链","date":"2019-01-26T14:17:50.000Z","updated":"2019-01-27T03:50:28.329Z","comments":true,"path":"friends/index.html","permalink":"http://tle666.gitub.io/friends/index.html","excerpt":"","text":"$AcF$"},{"title":"文章分类","date":"2018-08-31T07:16:02.000Z","updated":"2018-08-31T07:20:06.448Z","comments":true,"path":"categories/index.html","permalink":"http://tle666.gitub.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-31T07:15:42.000Z","updated":"2018-08-31T07:20:43.294Z","comments":true,"path":"tags/index.html","permalink":"http://tle666.gitub.io/tags/index.html","excerpt":"","text":""},{"title":"搜索","date":"2018-08-31T09:49:52.000Z","updated":"2018-08-31T09:51:16.269Z","comments":true,"path":"search/index.html","permalink":"http://tle666.gitub.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"快速读入详解","slug":"快速读入详解","date":"2019-01-27T03:41:50.000Z","updated":"2019-01-27T03:52:07.671Z","comments":true,"path":"2019/01/27/快速读入详解/","link":"","permalink":"http://tle666.gitub.io/2019/01/27/快速读入详解/","excerpt":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板","text":"快读是干蛤的呐？这篇文章将讲述快读及其用法和C++模板 当你在信息学竞赛$(OI)$中进入了提高组时，你可能会被卡常！ 卡常！ 程序被卡常数，一般指程序虽然渐进复杂度可以接受，但是由于实现/算法本身的时间常数因子较大，使得无法在OI/ICPC等算法竞赛规定的时限内运行结束。 常数被称为计算机算法竞赛之中最神奇的一类数字，主要特点集中于令人捉摸不透，有时候会让水平很高的选手迷之超时或者超空间。 ——来自~~某度~~百科…… 快速读入 简称快读，是信息学竞赛中卡常数最为常见的方法。 一般来讲，大多数题目的出题人都不会到这种丧心病狂的地步。 不过，以防万一肯定没坏处啊~ 反正代码很简单啦 代码先上代码！讲解在后面。 123456inline int read()&#123; int s = 0, w = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') w = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0', ch = getchar(); return s * w;&#125; // 这是能判负数的C++快读模板 在代码中，只需将cin &gt;&gt; n或scanf(&quot;%d&quot;, &amp;n)改成n = read()即可！ 原理分析为什么$cin$慢？因为它需要和$stdio$保持同步，也就是sync_with_stdio。 为什么$scanf$慢？原因有点复杂。 它可以接受多种形式的输入（数字、字符串等等），因此需要判断。 它因为某些安全原因——输入太快可能会有些玄学的$bug$，具体的我也不太清楚。 其实在$C++$中，依次读入单个字符是比一次读入一个数要快的，因此我们可以用$getchar()$来负责读入。 在实际的文件中，会有许多不必要的隐藏字符，比如换行符\\n等。 因此，我们需要先排除掉这些字符，也就是第一个$while$循环。但是有一个特例：$-21904$中的$-$号。这个负号不是数字啊！于是我们用$w$当数的符号。有负号时，$w$从原来的$1$转化成了$-1$。 于是，我们要特判！if(ch == ‘-’) w = -1;这就是判负号的语句。 下一个循环中，就是位值原理。数$\\overline{abcd} = 10 \\times (10 \\times (10 \\times a + b) + c) + d$，读者自证不难。 最后返回$n = sgn(n) \\times |n|$，其中$sgn(x)$为$x$的符号。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.gitub.io/tags/算法讲解/"},{"name":"卡常","slug":"卡常","permalink":"http://tle666.gitub.io/tags/卡常/"}]},{"title":"浅谈二分","slug":"浅谈二分","date":"2019-01-27T03:39:50.000Z","updated":"2019-01-27T03:59:03.795Z","comments":true,"path":"2019/01/27/浅谈二分/","link":"","permalink":"http://tle666.gitub.io/2019/01/27/浅谈二分/","excerpt":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。","text":"二分法的定义是什么？它的用途又是什么呢？这篇文章将会介绍一下二分法在各类问题中的应用。 大家一定对二分法有所耳闻吧！它的定义是什么？它的用途又是什么？下面我就来介绍一下二分法及其用途。 引子例题找出函数$f(x) = 3x - 3$在闭区间$[0，4]$的零点。 解法 首先，令$L = -1$，$R = 1$。 然后进行如下操作，直到$f(mid) = 0$为止。 算出$L$和$R$的代数平均数$mid$，且$mid \\in \\mathbb{Z}$，即整数$mid = \\lfloor \\dfrac{a + b}{2} \\rfloor$。 若$f(mid) = 0$，找到答案 若$f(mid) &gt; 0$，让$b = mid$，缩小区间 若$f(mid) &lt; 0$，让$a = mid$，缩小区间 回到步骤$1$。 如果你没有明白的话，那就看图吧。。。 $L = 0, R = 4, mid = \\lfloor \\dfrac{0 + 4}{2} \\rfloor = 2$ $f(mid) = f(2) = 3 &gt; 0$ 因为$f(x)$为单调递增函数，所以零点肯定在$2$左边。 缩小范围至$[0,2]$，$R = 2$。 此时$mid = \\lfloor \\dfrac{0 + 2}{2} \\rfloor= 1$ $f(mid) = f(1) = 0$！ 找到答案$0$。 例题回顾（条件） 在上面的例题中，能够正确地使用以上“缩小范围区间”的解法的条件是什么呢? 显然，函数$f(x)$需要是单调的，而到底是递增还是递减就无所谓了。 二分法 对于区间$[a, b]$上连续不断且$f(a) \\times f(b) &lt; 0$的函数$y=f(x)$，通过不断地把函数$f(x)$的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。 在信息学中，二分法最常见的体现就是二分答案。 在这篇随笔中，我主要讲解的就是二分答案。 二分答案 二分答案,是通过不断缩小解可能存在的范围,从而求得问题答案的方法。 举例猜数字 事先准备一个$[1, 100]$的正整数，让电脑猜。每次猜测会告诉猜数与答案的大小关系。 朴素的方法：枚举法，从$1 - 100$依次尝试，直到猜对为止。时间复杂度为$O(n)$。 二分答案： $L = 1, R = 100, mid = \\lfloor \\dfrac{L + R}{2} \\rfloor = 50$，设答案为$ans$。 只要$L \\leqslant R$，尝试$mid$，\\left\\{ \\begin{aligned} & 若mid > ans，则R = mid； \\\\ & 若mid < ans，则L = mid + 1； \\\\ & 若mid = ans，猜对了。 \\end{aligned} \\right. 时间复杂度为$O(log n)$。 为什么二分 更充分地利用已知条件，大幅度减少遍历范围 二分答案具有“先猜后证”的特点，可以给题目多增加一个条件，也许可以大幅度减小算法的时间开销 在什么情况下可以二分 答案存在单调性 什么意思呢？ 我们不妨假设答案满足条件为$1$，不满足为$0$； 那么如果一个答案序列为$0000000111$或$1111100000$，都存在单调性，那就都可以； 而如果序列是$000011011000110000$，那就不满足单调性，于是就不能进行二分答案了。 能够解决的问题二分答案能够解决哪些问题呢？如下： 最大的最小值 最小的最大值 在满足条件的情况下的最小（大）值 最接近一个值的值 …… 在一个单调序列中特殊的点基本上都能二分。 模板（$C++$）1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid, ans; // left为左边界，right为右边界while(left &lt;= right)&#123; // 只要存在区间 mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) ans = mid, right = mid - 1; // 如果mid满足条件，那ans（答案）肯定不大于mid else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", ans); // 输出答案 为什么第五行要加上ans = mid呢？ 原因：如果$mid$恰好就是正确答案，$check(mid)$满足，为$true$，于是进入本句。如果将$right$设为$mid - 1$的话，就永远得不到$ans$了（可以想一想为什么） 这就出现了另一种写法—— 1234567// 这是一个求满足条件的最小值的二分模板int left = 0, right = MAX, mid; // left为左边界，right为右边界while(left &lt; right)&#123; // #注意这里改变# mid = (left + right) &gt;&gt; 1; // 等价于(left + right) / 2，只不过这样写运行速度会稍快一些 if(check(mid)) right = mid; // #注意这里也改变# else left = mid + 1; // 如果不能满足条件，ans区间最小值肯定大于mid&#125; printf(\"%d\\n\", right); // 输出答案 不过我个人建议还是写第一种好（更好理解，不容易错）。 那这两段代码中的$check$函数是干什么的呢？ 其实，布尔型函数$check(x)$是用来判断$x$条件下是否能成功（满足题目条件）。 练习题 奶牛晒衣服 营救 （如果不会最小生成树请自动跳过~） $NOIP2015$ 跳石头 【模板】最长公共子序列 ……","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.gitub.io/tags/算法讲解/"},{"name":"二分","slug":"二分","permalink":"http://tle666.gitub.io/tags/二分/"}]},{"title":"洛谷P1462通往奥格瑞玛的道路","slug":"洛谷P1462通往奥格瑞玛的道路","date":"2019-01-27T03:36:50.000Z","updated":"2019-01-27T03:48:18.675Z","comments":true,"path":"2019/01/27/洛谷P1462通往奥格瑞玛的道路/","link":"","permalink":"http://tle666.gitub.io/2019/01/27/洛谷P1462通往奥格瑞玛的道路/","excerpt":"看完题面感觉语文要挂科。。。o(╥﹏╥)o","text":"看完题面感觉语文要挂科。。。o(╥﹏╥)o 题意：$n$个点$m$条边的带权无向图 每个点还有一个点权 求$1-n$的一条最短路径，使得路径长度比$b$断，并且经过的点权之和最大。 输出这个最大值 思路这题正解 $SPFA$ $+$ 二分 _只看思路的同志们到此为止_ 详情很简单，先来个二分答案，$check()$函数中过一遍$SPFA$，然后跑一下$path$，也就是回溯函数（用来求最短路径），然后判一下符不符合题意就行了$QAQ$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 50010#define INF (int)1e9int n, m, cnt, blood, f[MAXN], dis[MAXN], pre[MAXN], ans; //pre[u]代表u到1的最短路的上一个节点bool flag[MAXN];queue&lt;int&gt; Q;struct edge&#123; //邻接表 int v, w; edge *next;&#125;pool[MAXN &lt;&lt; 1], *h[MAXN];inline void addedge(int u, int v, int w)&#123; //建边函数 edge *p = &amp;pool[++cnt], *q = &amp;pool[++cnt]; p-&gt;v = v, p-&gt;w = w, p-&gt;next = h[u], h[u] = p; q-&gt;v = u, q-&gt;w = w, q-&gt;next = h[v], h[v] = q;&#125;inline void spfa(int money)&#123; //money代表这次至少收取多少钱，所能够走道的最短路 int u, v; for(int i = 2; i &lt;= n; i++) dis[i] = INF; flag[1] = true, Q.push(1); while(!Q.empty())&#123; u = Q.front(), Q.pop(), flag[u] = false; for(edge *p = h[u]; p; p = p-&gt;next) if(dis[v = p-&gt;v] &gt; dis[u] + p-&gt;w &amp;&amp; f[u] &lt;= money)&#123; //注意这里要判一下点权（钱）是否满足要求（money） dis[v] = dis[u] + p-&gt;w, pre[v] = u; if(!flag[v]) Q.push(v), flag[v] = true; &#125; &#125;&#125;inline int path(int u)&#123; //最短路回溯函数（递归调用） if(u == 1) return f[1]; //到头 if(u != 1 &amp;&amp; !pre[u]) return -1; //走不通了（不连通） return max(f[u], path(pre[u])); //最多一次的钱&#125;inline bool check(int x)&#123; //二分函数 spfa(x); int tmp = path(n); if(tmp &lt;= x &amp;&amp; tmp &gt;= 0 &amp;&amp; dis[n] &lt;= blood) return true; return false;&#125;int main()&#123; int u, v, w, left = INF, right = 0, mid, Max = 0; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;blood); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;f[i]); left = min(left, f[i]), Max = right = max(right, f[i]); &#125; for(int i = 1; i &lt;= m; i++)&#123; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; while(left &lt;= right)&#123; mid = (left + right) &gt;&gt; 1; if(check(mid)) right = mid - 1; else left = mid + 1; &#125; if(left &gt; Max) puts(\"AFK\"); else printf(\"%d\\n\", left); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.gitub.io/tags/题解/"},{"name":"图论","slug":"图论","permalink":"http://tle666.gitub.io/tags/图论/"}]},{"title":"洛谷P1627中位数","slug":"洛谷P1627中位数","date":"2019-01-27T03:33:40.000Z","updated":"2019-01-27T03:48:44.349Z","comments":true,"path":"2019/01/27/洛谷P1627中位数/","link":"","permalink":"http://tle666.gitub.io/2019/01/27/洛谷P1627中位数/","excerpt":"题目传送门","text":"题目传送门 思路标记一遍相对大小，大的标1，小的标-1。只要连续 n 项和为0，就能满足题目条件。首先一遍找到中位数位置 pos，放个数组 flag 标记查找中的数与目标中位数的相对大小：1 -&gt; 比中位数大 -1 -&gt; 比中位数小 0 -&gt; 找到中位数！标记pos 还是举个实例吧…… 数组：1 1 -1 -1 -1 pos 1 -1 1 然后从 (pos - 1) 走一遍到1，也就是反过来。再拿一个变量 sum 标记每往左走一个时数组 flag 这一项与这之前的项之和。怎么标？用哈希的方法！（开个数组 f ）那万一 sum 值为负怎么办？数组的下标可没有负的！凉拌~ 把所有 sum 值统统加上一个足够大的值 “KEY” 。妈妈再也不用担心下标的值为负啦！这时的 sum 数组：-1 -2 -3 -2 -1 这时的 f 数组：f [ -1 + KEY ] = 2 ; f [ -2 + KEY ] = 2 ; f [ -3 + KEY ] = 1 ; 做完这些以后，最后从 (pos + 1) 走一遍到 n ,正着走。和上边一样，记录 sum 值。不过这次得多一个步骤——每次要找 pos 左边的对应值。从 pos 向右 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; sum=0 -&gt; 左边 sum=0 -&gt; 无 sum=1 -&gt; 左边 sum=-1 -&gt; 两次 ∴ ans+=2; 最后输出 ans 即可。C++ 代码如下： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;//头文件#include &lt;cstdlib&gt;//头文件using namespace std;//命名空间#define KEY 100001//定义一个足够大的数int n,b,pos,a[100010],flag[100010],f[200010],s,ans;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;b);//输入 for(int i=1;i&lt;=n;i++)&#123;//第一次循环 scanf(\"%d\",&amp;a[i]); if(a[i]==b) pos=i;//就是中位数 else if(a[i]&gt;b) flag[i]=1;//大的标1 else flag[i]=-1;//小的标-1 &#125; for(int i=pos-1;i&gt;=1;i--)&#123;//第二次循环 s+=flag[i];//计算此次sum值 f[s+KEY]++; if(s==0) ans++;//找到满足题意只在 pos 左侧的连续子序列！ &#125; s=0;//为第三次循环的累加做准备 for(int i=pos+1;i&lt;=n;i++)&#123;//第三次循环 s+=flag[i];//计算此次sum值 if(s==0) ans++;//找到满足题意只在 pos 右侧的连续子序列！ ans+=f[-s+KEY]; &#125; printf(\"%d\\n\",++ans);//还少一次只由 pos 自己组成的连续子序列（也满足条件！） return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"},{"name":"题解","slug":"题解","permalink":"http://tle666.gitub.io/tags/题解/"}]},{"title":"并查集入门","slug":"并查集","date":"2018-10-04T03:21:10.000Z","updated":"2019-01-27T03:43:34.209Z","comments":true,"path":"2018/10/04/并查集/","link":"","permalink":"http://tle666.gitub.io/2018/10/04/并查集/","excerpt":"并查集是维护集合相关问题的利器！","text":"并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"},{"name":"算法讲解","slug":"算法讲解","permalink":"http://tle666.gitub.io/tags/算法讲解/"},{"name":"并查集","slug":"并查集","permalink":"http://tle666.gitub.io/tags/并查集/"}]}]}