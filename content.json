{"meta":{"title":"P_Wang's Blog","subtitle":"自己选择的路，跪着也要走完。","description":"OIer!","author":"P_Wang","url":"http://tle666.gitub.io"},"pages":[{"title":"关于","date":"2018-08-31T07:13:58.000Z","updated":"2018-10-05T03:54:26.705Z","comments":true,"path":"about/index.html","permalink":"http://tle666.gitub.io/about/index.html","excerpt":"","text":"王泽华：本人乃无实力瑟瑟发抖萌新C++是个好东西。。。$QQ$邮箱：patrick_rdfz@qq.com大力推荐洛谷！！！ https://www.luogu.org/ 欢迎加好友 打发时间的好东西——扫雷 和 2048，还有数独！"},{"title":"搜索","date":"2018-08-31T09:49:52.000Z","updated":"2018-08-31T09:51:16.269Z","comments":true,"path":"search/index.html","permalink":"http://tle666.gitub.io/search/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-08-31T07:16:02.000Z","updated":"2018-08-31T07:20:06.448Z","comments":true,"path":"categories/index.html","permalink":"http://tle666.gitub.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-31T07:15:42.000Z","updated":"2018-08-31T07:20:43.294Z","comments":true,"path":"tags/index.html","permalink":"http://tle666.gitub.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"并查集入门","slug":"并查集","date":"2018-10-04T03:21:10.000Z","updated":"2018-12-16T06:48:31.493Z","comments":true,"path":"2018/10/04/并查集/","link":"","permalink":"http://tle666.gitub.io/2018/10/04/并查集/","excerpt":"并查集是维护集合相关问题的利器！","text":"并查集是维护集合相关问题的利器！ 基础知识并查集是个好东西！ 它能搞和集合相关的东西……常用的有：_最小生成树（$Kruskal$）；判联通块、连通图……_ 二话不说，先上代码！ 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,m,fa[MAXN];bool flag[MAXN];inline void init()&#123; for(int i=1;i&lt;=n;i++) fa[i]=i;&#125;inline int Find (int i)&#123; return (fa[i]==i?i:fa[i]=Find(fa[i]));&#125;inline void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v; init(); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); if(Find(u)!=Find(v)) Union(Find(u),Find(v)); &#125; return 0;&#125; $Find()$函数是路径压缩，不用理解，以后自然会懂 $Union()$是将两个队列合到一起。 E.G. 数据： 1233 21 21 3 将1, 2所在的集合合并 $Find(1)=2, Find(2)=2, Find(3)=3$ 将2, 3所在的集合合并 $Find(1)=3, Find(2)=3, Find(3)=3$ ——&gt;&gt; 路径压缩 例题修复公路最小生成树模板题！ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 1010int n,m,ans,fa[MAXN];struct edge&#123;//所有的边（图） int u,v,w; bool operator &lt;(const edge &amp;x)&#123; return w&lt;x.w; &#125;&#125;e[MAXN*MAXN];int Find(int i)&#123; return !fa[i]?i:fa[i]=Find(fa[i]);&#125;//并查集部分void Union(int x,int y)&#123; fa[x]=y;&#125;int main()&#123; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) if(Find(e[i].u)!=Find(e[i].v))&#123;//最小生成树 Kruskal ans=e[i].w; Union(Find(e[i].u),Find(e[i].v)); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(Find(i)!=Find(j))&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"}]},{"title":"OI中卡常的那些事儿","slug":"OI中卡常的那些事儿","date":"2018-10-01T04:56:37.000Z","updated":"2019-01-26T13:25:39.469Z","comments":true,"path":"2018/10/01/OI中卡常的那些事儿/","link":"","permalink":"http://tle666.gitub.io/2018/10/01/OI中卡常的那些事儿/","excerpt":"我们作为$OIer$，在$OI$中卡常数可以说是必备技巧。 在此总结一下我所知卡常数的神奇 玄学 手法","text":"我们作为$OIer$，在$OI$中卡常数可以说是必备技巧。 在此总结一下我所知卡常数的神奇 玄学 手法 1.快读十分常用，建议背下模板！ 原理：$getchar()$比$scanf()$快。 12345678910111213#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;inline int read()&#123; int s=0,w=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') w=-1;ch=getchar();&#125;//如果输入的是换行符、负号……需要判一下！ while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar();//输入数字部分 return s*w;//返回值：符号(+,-) × 数的绝对值&#125;int main()&#123; printf(\"%d\\n\",read());//酷(zuo)炫(si)写法 return 0;&#125; 2.函数声明的$inline$注意：只能在简单函数中使用（才有效）！ 如果这个函数中有$for$或者递归；那就不算简单函数！ 123456789101112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int a,b;inline int add(int a,int b)&#123; return a+b;&#125;int main()&#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",add(a,b)); return 0;&#125; 3.$for$循环的$register$将频繁出现的变量临时寄存在$CPU$中，不可访问位置(&amp;n) 1234567891011#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAXN 100100int n,a[MAXN];int main()&#123; scanf(\"%d\",&amp;n); for(register int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); return 0;&#125; 4.逗号替代分号$RT.$ 12c=a+b;c++;//慢c=a+b,c++;//快 大概日常能够用到的就这些了吧。。。 $END.$","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://tle666.gitub.io/tags/C/"}]}]}